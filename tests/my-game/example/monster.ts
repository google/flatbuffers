// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { Monster as MyGameExample2Monster, MonsterT as MyGameExample2MonsterT } from '../../my-game/example2/monster';
import { Ability, AbilityT } from '../../my-game/example/ability';
import { Any, unionToAny, unionListToAny } from '../../my-game/example/any';
import { AnyAmbiguousAliases, unionToAnyAmbiguousAliases, unionListToAnyAmbiguousAliases } from '../../my-game/example/any-ambiguous-aliases';
import { AnyUniqueAliases, unionToAnyUniqueAliases, unionListToAnyUniqueAliases } from '../../my-game/example/any-unique-aliases';
import { Color } from '../../my-game/example/color';
import { Race } from '../../my-game/example/race';
import { Referrable, ReferrableT } from '../../my-game/example/referrable';
import { Stat, StatT } from '../../my-game/example/stat';
import { Test, TestT } from '../../my-game/example/test';
import { TestSimpleTableWithEnum, TestSimpleTableWithEnumT } from '../../my-game/example/test-simple-table-with-enum';
import { Vec3, Vec3T } from '../../my-game/example/vec3';
import { InParentNamespace, InParentNamespaceT } from '../../my-game/in-parent-namespace';


/**
 * an example documentation comment: "monster object"
 */
export class Monster {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
__init(i:number, bb:flatbuffers.ByteBuffer):Monster {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMonster(bb:flatbuffers.ByteBuffer, obj?:Monster):Monster {
  return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMonster(bb:flatbuffers.ByteBuffer, obj?:Monster):Monster {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('MONS');
}

pos(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new Vec3()).__init(this.bb_pos + offset, this.bb!) : null;
}

mana():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : 150;
}

mutate_mana(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt16(this.bb_pos + offset, value);
  return true;
}

hp():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : 100;
}

mutate_hp(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt16(this.bb_pos + offset, value);
  return true;
}

name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

inventory(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

inventoryLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

inventoryArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

color():Color {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Color.Blue;
}

mutate_color(value:Color):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 16);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint8(this.bb_pos + offset, value);
  return true;
}

testType():Any {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Any.NONE;
}

test<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

test4(index: number, obj?:Test):Test|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? (obj || new Test()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 4, this.bb!) : null;
}

test4Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

testarrayofstring(index: number):string
testarrayofstring(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
testarrayofstring(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

testarrayofstringLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * an example documentation comment: this will end up in the generated code
 * multiline too
 */
testarrayoftables(index: number, obj?:Monster):Monster|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? (obj || new Monster()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

testarrayoftablesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

enemy(obj?:Monster):Monster|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? (obj || new Monster()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

testnestedflatbuffer(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

testnestedflatbufferLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

testnestedflatbufferArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

testempty(obj?:Stat):Stat|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? (obj || new Stat()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

testbool():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

mutate_testbool(value:boolean):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 34);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, +value);
  return true;
}

testhashs32Fnv1():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_testhashs32_fnv1(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 36);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

testhashu32Fnv1():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_testhashu32_fnv1(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 38);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

testhashs64Fnv1():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('0');
}

mutate_testhashs64_fnv1(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 40);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt64(this.bb_pos + offset, value);
  return true;
}

testhashu64Fnv1():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_testhashu64_fnv1(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 42);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

testhashs32Fnv1a():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mutate_testhashs32_fnv1a(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 44);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

testhashu32Fnv1a():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_testhashu32_fnv1a(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 46);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

testhashs64Fnv1a():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('0');
}

mutate_testhashs64_fnv1a(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 48);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt64(this.bb_pos + offset, value);
  return true;
}

testhashu64Fnv1a():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_testhashu64_fnv1a(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 50);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

testarrayofbools(index: number):boolean|null {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
}

testarrayofboolsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

testarrayofboolsArray():Int8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

testf():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 3.14159;
}

mutate_testf(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 54);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeFloat32(this.bb_pos + offset, value);
  return true;
}

testf2():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 3.0;
}

mutate_testf2(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 56);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeFloat32(this.bb_pos + offset, value);
  return true;
}

testf3():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

mutate_testf3(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 58);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeFloat32(this.bb_pos + offset, value);
  return true;
}

testarrayofstring2(index: number):string
testarrayofstring2(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
testarrayofstring2(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

testarrayofstring2Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

testarrayofsortedstruct(index: number, obj?:Ability):Ability|null {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? (obj || new Ability()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 8, this.bb!) : null;
}

testarrayofsortedstructLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

flex(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

flexLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

flexArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

test5(index: number, obj?:Test):Test|null {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? (obj || new Test()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 4, this.bb!) : null;
}

test5Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

vectorOfLongs(index: number):bigint|null {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
}

vectorOfLongsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

vectorOfDoubles(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

vectorOfDoublesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

vectorOfDoublesArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

parentNamespaceTest(obj?:InParentNamespace):InParentNamespace|null {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? (obj || new InParentNamespace()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

vectorOfReferrables(index: number, obj?:Referrable):Referrable|null {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? (obj || new Referrable()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

vectorOfReferrablesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

singleWeakReference():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_single_weak_reference(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 76);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

vectorOfWeakReferences(index: number):bigint|null {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
}

vectorOfWeakReferencesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

vectorOfStrongReferrables(index: number, obj?:Referrable):Referrable|null {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? (obj || new Referrable()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

vectorOfStrongReferrablesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

coOwningReference():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_co_owning_reference(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 82);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

vectorOfCoOwningReferences(index: number):bigint|null {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
}

vectorOfCoOwningReferencesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

nonOwningReference():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_non_owning_reference(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 86);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

vectorOfNonOwningReferences(index: number):bigint|null {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
}

vectorOfNonOwningReferencesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

anyUniqueType():AnyUniqueAliases {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : AnyUniqueAliases.NONE;
}

anyUnique<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

anyAmbiguousType():AnyAmbiguousAliases {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : AnyAmbiguousAliases.NONE;
}

anyAmbiguous<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

vectorOfEnums(index: number):Color|null {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

vectorOfEnumsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

vectorOfEnumsArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

signedEnum():Race {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : Race.None;
}

mutate_signed_enum(value:Race):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 100);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, value);
  return true;
}

testrequirednestedflatbuffer(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
}

testrequirednestedflatbufferLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

testrequirednestedflatbufferArray():Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

scalarKeySortedTables(index: number, obj?:Stat):Stat|null {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? (obj || new Stat()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

scalarKeySortedTablesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static getFullyQualifiedName():string {
  return 'MyGame.Example.Monster';
}

static startMonster(builder:flatbuffers.Builder) {
  builder.startObject(51);
}

static addPos(builder:flatbuffers.Builder, posOffset:flatbuffers.Offset) {
  builder.addFieldStruct(0, posOffset, 0);
}

static addMana(builder:flatbuffers.Builder, mana:number) {
  builder.addFieldInt16(1, mana, 150);
}

static addHp(builder:flatbuffers.Builder, hp:number) {
  builder.addFieldInt16(2, hp, 100);
}

static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, nameOffset, 0);
}

static addInventory(builder:flatbuffers.Builder, inventoryOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, inventoryOffset, 0);
}

static createInventoryVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startInventoryVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addColor(builder:flatbuffers.Builder, color:Color) {
  builder.addFieldInt8(6, color, Color.Blue);
}

static addTestType(builder:flatbuffers.Builder, testType:Any) {
  builder.addFieldInt8(7, testType, Any.NONE);
}

static addTest(builder:flatbuffers.Builder, testOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, testOffset, 0);
}

static addTest4(builder:flatbuffers.Builder, test4Offset:flatbuffers.Offset) {
  builder.addFieldOffset(9, test4Offset, 0);
}

static startTest4Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 2);
}

static addTestarrayofstring(builder:flatbuffers.Builder, testarrayofstringOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, testarrayofstringOffset, 0);
}

static createTestarrayofstringVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTestarrayofstringVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTestarrayoftables(builder:flatbuffers.Builder, testarrayoftablesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, testarrayoftablesOffset, 0);
}

static createTestarrayoftablesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTestarrayoftablesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEnemy(builder:flatbuffers.Builder, enemyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, enemyOffset, 0);
}

static addTestnestedflatbuffer(builder:flatbuffers.Builder, testnestedflatbufferOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, testnestedflatbufferOffset, 0);
}

static createTestnestedflatbufferVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startTestnestedflatbufferVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addTestempty(builder:flatbuffers.Builder, testemptyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, testemptyOffset, 0);
}

static addTestbool(builder:flatbuffers.Builder, testbool:boolean) {
  builder.addFieldInt8(15, +testbool, +false);
}

static addTesthashs32Fnv1(builder:flatbuffers.Builder, testhashs32Fnv1:number) {
  builder.addFieldInt32(16, testhashs32Fnv1, 0);
}

static addTesthashu32Fnv1(builder:flatbuffers.Builder, testhashu32Fnv1:number) {
  builder.addFieldInt32(17, testhashu32Fnv1, 0);
}

static addTesthashs64Fnv1(builder:flatbuffers.Builder, testhashs64Fnv1:bigint) {
  builder.addFieldInt64(18, testhashs64Fnv1, BigInt('0'));
}

static addTesthashu64Fnv1(builder:flatbuffers.Builder, testhashu64Fnv1:bigint) {
  builder.addFieldInt64(19, testhashu64Fnv1, BigInt('0'));
}

static addTesthashs32Fnv1a(builder:flatbuffers.Builder, testhashs32Fnv1a:number) {
  builder.addFieldInt32(20, testhashs32Fnv1a, 0);
}

static addTesthashu32Fnv1a(builder:flatbuffers.Builder, testhashu32Fnv1a:number) {
  builder.addFieldInt32(21, testhashu32Fnv1a, 0);
}

static addTesthashs64Fnv1a(builder:flatbuffers.Builder, testhashs64Fnv1a:bigint) {
  builder.addFieldInt64(22, testhashs64Fnv1a, BigInt('0'));
}

static addTesthashu64Fnv1a(builder:flatbuffers.Builder, testhashu64Fnv1a:bigint) {
  builder.addFieldInt64(23, testhashu64Fnv1a, BigInt('0'));
}

static addTestarrayofbools(builder:flatbuffers.Builder, testarrayofboolsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(24, testarrayofboolsOffset, 0);
}

static createTestarrayofboolsVector(builder:flatbuffers.Builder, data:boolean[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(+data[i]!);
  }
  return builder.endVector();
}

static startTestarrayofboolsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addTestf(builder:flatbuffers.Builder, testf:number) {
  builder.addFieldFloat32(25, testf, 3.14159);
}

static addTestf2(builder:flatbuffers.Builder, testf2:number) {
  builder.addFieldFloat32(26, testf2, 3.0);
}

static addTestf3(builder:flatbuffers.Builder, testf3:number) {
  builder.addFieldFloat32(27, testf3, 0.0);
}

static addTestarrayofstring2(builder:flatbuffers.Builder, testarrayofstring2Offset:flatbuffers.Offset) {
  builder.addFieldOffset(28, testarrayofstring2Offset, 0);
}

static createTestarrayofstring2Vector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTestarrayofstring2Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTestarrayofsortedstruct(builder:flatbuffers.Builder, testarrayofsortedstructOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, testarrayofsortedstructOffset, 0);
}

static startTestarrayofsortedstructVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 4);
}

static addFlex(builder:flatbuffers.Builder, flexOffset:flatbuffers.Offset) {
  builder.addFieldOffset(30, flexOffset, 0);
}

static createFlexVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startFlexVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addTest5(builder:flatbuffers.Builder, test5Offset:flatbuffers.Offset) {
  builder.addFieldOffset(31, test5Offset, 0);
}

static startTest5Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 2);
}

static addVectorOfLongs(builder:flatbuffers.Builder, vectorOfLongsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(32, vectorOfLongsOffset, 0);
}

static createVectorOfLongsVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfLongsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addVectorOfDoubles(builder:flatbuffers.Builder, vectorOfDoublesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(33, vectorOfDoublesOffset, 0);
}

static createVectorOfDoublesVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createVectorOfDoublesVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createVectorOfDoublesVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfDoublesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addParentNamespaceTest(builder:flatbuffers.Builder, parentNamespaceTestOffset:flatbuffers.Offset) {
  builder.addFieldOffset(34, parentNamespaceTestOffset, 0);
}

static addVectorOfReferrables(builder:flatbuffers.Builder, vectorOfReferrablesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(35, vectorOfReferrablesOffset, 0);
}

static createVectorOfReferrablesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfReferrablesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSingleWeakReference(builder:flatbuffers.Builder, singleWeakReference:bigint) {
  builder.addFieldInt64(36, singleWeakReference, BigInt('0'));
}

static addVectorOfWeakReferences(builder:flatbuffers.Builder, vectorOfWeakReferencesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(37, vectorOfWeakReferencesOffset, 0);
}

static createVectorOfWeakReferencesVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfWeakReferencesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addVectorOfStrongReferrables(builder:flatbuffers.Builder, vectorOfStrongReferrablesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(38, vectorOfStrongReferrablesOffset, 0);
}

static createVectorOfStrongReferrablesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfStrongReferrablesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCoOwningReference(builder:flatbuffers.Builder, coOwningReference:bigint) {
  builder.addFieldInt64(39, coOwningReference, BigInt('0'));
}

static addVectorOfCoOwningReferences(builder:flatbuffers.Builder, vectorOfCoOwningReferencesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(40, vectorOfCoOwningReferencesOffset, 0);
}

static createVectorOfCoOwningReferencesVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfCoOwningReferencesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addNonOwningReference(builder:flatbuffers.Builder, nonOwningReference:bigint) {
  builder.addFieldInt64(41, nonOwningReference, BigInt('0'));
}

static addVectorOfNonOwningReferences(builder:flatbuffers.Builder, vectorOfNonOwningReferencesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(42, vectorOfNonOwningReferencesOffset, 0);
}

static createVectorOfNonOwningReferencesVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfNonOwningReferencesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addAnyUniqueType(builder:flatbuffers.Builder, anyUniqueType:AnyUniqueAliases) {
  builder.addFieldInt8(43, anyUniqueType, AnyUniqueAliases.NONE);
}

static addAnyUnique(builder:flatbuffers.Builder, anyUniqueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(44, anyUniqueOffset, 0);
}

static addAnyAmbiguousType(builder:flatbuffers.Builder, anyAmbiguousType:AnyAmbiguousAliases) {
  builder.addFieldInt8(45, anyAmbiguousType, AnyAmbiguousAliases.NONE);
}

static addAnyAmbiguous(builder:flatbuffers.Builder, anyAmbiguousOffset:flatbuffers.Offset) {
  builder.addFieldOffset(46, anyAmbiguousOffset, 0);
}

static addVectorOfEnums(builder:flatbuffers.Builder, vectorOfEnumsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(47, vectorOfEnumsOffset, 0);
}

static createVectorOfEnumsVector(builder:flatbuffers.Builder, data:Color[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startVectorOfEnumsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addSignedEnum(builder:flatbuffers.Builder, signedEnum:Race) {
  builder.addFieldInt8(48, signedEnum, Race.None);
}

static addTestrequirednestedflatbuffer(builder:flatbuffers.Builder, testrequirednestedflatbufferOffset:flatbuffers.Offset) {
  builder.addFieldOffset(49, testrequirednestedflatbufferOffset, 0);
}

static createTestrequirednestedflatbufferVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]!);
  }
  return builder.endVector();
}

static startTestrequirednestedflatbufferVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
}

static addScalarKeySortedTables(builder:flatbuffers.Builder, scalarKeySortedTablesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(50, scalarKeySortedTablesOffset, 0);
}

static createScalarKeySortedTablesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startScalarKeySortedTablesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endMonster(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 10) // name
  return offset;
}

static finishMonsterBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'MONS');
}

static finishSizePrefixedMonsterBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'MONS', true);
}


serialize():Uint8Array {
  return this.bb!.bytes();
}

static deserialize(buffer: Uint8Array):Monster {
  return Monster.getRootAsMonster(new flatbuffers.ByteBuffer(buffer))
}

unpack(): MonsterT {
  return new MonsterT(
    (this.pos() !== null ? this.pos()!.unpack() : null),
    this.mana(),
    this.hp(),
    this.name(),
    this.bb!.createScalarList(this.inventory.bind(this), this.inventoryLength()),
    this.color(),
    this.testType(),
    (() => {
      let temp = unionToAny(this.testType(), this.test.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })(),
    this.bb!.createObjList(this.test4.bind(this), this.test4Length()),
    this.bb!.createScalarList(this.testarrayofstring.bind(this), this.testarrayofstringLength()),
    this.bb!.createObjList(this.testarrayoftables.bind(this), this.testarrayoftablesLength()),
    (this.enemy() !== null ? this.enemy()!.unpack() : null),
    this.bb!.createScalarList(this.testnestedflatbuffer.bind(this), this.testnestedflatbufferLength()),
    (this.testempty() !== null ? this.testempty()!.unpack() : null),
    this.testbool(),
    this.testhashs32Fnv1(),
    this.testhashu32Fnv1(),
    this.testhashs64Fnv1(),
    this.testhashu64Fnv1(),
    this.testhashs32Fnv1a(),
    this.testhashu32Fnv1a(),
    this.testhashs64Fnv1a(),
    this.testhashu64Fnv1a(),
    this.bb!.createScalarList(this.testarrayofbools.bind(this), this.testarrayofboolsLength()),
    this.testf(),
    this.testf2(),
    this.testf3(),
    this.bb!.createScalarList(this.testarrayofstring2.bind(this), this.testarrayofstring2Length()),
    this.bb!.createObjList(this.testarrayofsortedstruct.bind(this), this.testarrayofsortedstructLength()),
    this.bb!.createScalarList(this.flex.bind(this), this.flexLength()),
    this.bb!.createObjList(this.test5.bind(this), this.test5Length()),
    this.bb!.createScalarList(this.vectorOfLongs.bind(this), this.vectorOfLongsLength()),
    this.bb!.createScalarList(this.vectorOfDoubles.bind(this), this.vectorOfDoublesLength()),
    (this.parentNamespaceTest() !== null ? this.parentNamespaceTest()!.unpack() : null),
    this.bb!.createObjList(this.vectorOfReferrables.bind(this), this.vectorOfReferrablesLength()),
    this.singleWeakReference(),
    this.bb!.createScalarList(this.vectorOfWeakReferences.bind(this), this.vectorOfWeakReferencesLength()),
    this.bb!.createObjList(this.vectorOfStrongReferrables.bind(this), this.vectorOfStrongReferrablesLength()),
    this.coOwningReference(),
    this.bb!.createScalarList(this.vectorOfCoOwningReferences.bind(this), this.vectorOfCoOwningReferencesLength()),
    this.nonOwningReference(),
    this.bb!.createScalarList(this.vectorOfNonOwningReferences.bind(this), this.vectorOfNonOwningReferencesLength()),
    this.anyUniqueType(),
    (() => {
      let temp = unionToAnyUniqueAliases(this.anyUniqueType(), this.anyUnique.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })(),
    this.anyAmbiguousType(),
    (() => {
      let temp = unionToAnyAmbiguousAliases(this.anyAmbiguousType(), this.anyAmbiguous.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })(),
    this.bb!.createScalarList(this.vectorOfEnums.bind(this), this.vectorOfEnumsLength()),
    this.signedEnum(),
    this.bb!.createScalarList(this.testrequirednestedflatbuffer.bind(this), this.testrequirednestedflatbufferLength()),
    this.bb!.createObjList(this.scalarKeySortedTables.bind(this), this.scalarKeySortedTablesLength())
  );
}


unpackTo(_o: MonsterT): void {
  _o.pos = (this.pos() !== null ? this.pos()!.unpack() : null);
  _o.mana = this.mana();
  _o.hp = this.hp();
  _o.name = this.name();
  _o.inventory = this.bb!.createScalarList(this.inventory.bind(this), this.inventoryLength());
  _o.color = this.color();
  _o.testType = this.testType();
  _o.test = (() => {
      let temp = unionToAny(this.testType(), this.test.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
  _o.test4 = this.bb!.createObjList(this.test4.bind(this), this.test4Length());
  _o.testarrayofstring = this.bb!.createScalarList(this.testarrayofstring.bind(this), this.testarrayofstringLength());
  _o.testarrayoftables = this.bb!.createObjList(this.testarrayoftables.bind(this), this.testarrayoftablesLength());
  _o.enemy = (this.enemy() !== null ? this.enemy()!.unpack() : null);
  _o.testnestedflatbuffer = this.bb!.createScalarList(this.testnestedflatbuffer.bind(this), this.testnestedflatbufferLength());
  _o.testempty = (this.testempty() !== null ? this.testempty()!.unpack() : null);
  _o.testbool = this.testbool();
  _o.testhashs32Fnv1 = this.testhashs32Fnv1();
  _o.testhashu32Fnv1 = this.testhashu32Fnv1();
  _o.testhashs64Fnv1 = this.testhashs64Fnv1();
  _o.testhashu64Fnv1 = this.testhashu64Fnv1();
  _o.testhashs32Fnv1a = this.testhashs32Fnv1a();
  _o.testhashu32Fnv1a = this.testhashu32Fnv1a();
  _o.testhashs64Fnv1a = this.testhashs64Fnv1a();
  _o.testhashu64Fnv1a = this.testhashu64Fnv1a();
  _o.testarrayofbools = this.bb!.createScalarList(this.testarrayofbools.bind(this), this.testarrayofboolsLength());
  _o.testf = this.testf();
  _o.testf2 = this.testf2();
  _o.testf3 = this.testf3();
  _o.testarrayofstring2 = this.bb!.createScalarList(this.testarrayofstring2.bind(this), this.testarrayofstring2Length());
  _o.testarrayofsortedstruct = this.bb!.createObjList(this.testarrayofsortedstruct.bind(this), this.testarrayofsortedstructLength());
  _o.flex = this.bb!.createScalarList(this.flex.bind(this), this.flexLength());
  _o.test5 = this.bb!.createObjList(this.test5.bind(this), this.test5Length());
  _o.vectorOfLongs = this.bb!.createScalarList(this.vectorOfLongs.bind(this), this.vectorOfLongsLength());
  _o.vectorOfDoubles = this.bb!.createScalarList(this.vectorOfDoubles.bind(this), this.vectorOfDoublesLength());
  _o.parentNamespaceTest = (this.parentNamespaceTest() !== null ? this.parentNamespaceTest()!.unpack() : null);
  _o.vectorOfReferrables = this.bb!.createObjList(this.vectorOfReferrables.bind(this), this.vectorOfReferrablesLength());
  _o.singleWeakReference = this.singleWeakReference();
  _o.vectorOfWeakReferences = this.bb!.createScalarList(this.vectorOfWeakReferences.bind(this), this.vectorOfWeakReferencesLength());
  _o.vectorOfStrongReferrables = this.bb!.createObjList(this.vectorOfStrongReferrables.bind(this), this.vectorOfStrongReferrablesLength());
  _o.coOwningReference = this.coOwningReference();
  _o.vectorOfCoOwningReferences = this.bb!.createScalarList(this.vectorOfCoOwningReferences.bind(this), this.vectorOfCoOwningReferencesLength());
  _o.nonOwningReference = this.nonOwningReference();
  _o.vectorOfNonOwningReferences = this.bb!.createScalarList(this.vectorOfNonOwningReferences.bind(this), this.vectorOfNonOwningReferencesLength());
  _o.anyUniqueType = this.anyUniqueType();
  _o.anyUnique = (() => {
      let temp = unionToAnyUniqueAliases(this.anyUniqueType(), this.anyUnique.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
  _o.anyAmbiguousType = this.anyAmbiguousType();
  _o.anyAmbiguous = (() => {
      let temp = unionToAnyAmbiguousAliases(this.anyAmbiguousType(), this.anyAmbiguous.bind(this));
      if(temp === null) { return null; }
      return temp.unpack()
  })();
  _o.vectorOfEnums = this.bb!.createScalarList(this.vectorOfEnums.bind(this), this.vectorOfEnumsLength());
  _o.signedEnum = this.signedEnum();
  _o.testrequirednestedflatbuffer = this.bb!.createScalarList(this.testrequirednestedflatbuffer.bind(this), this.testrequirednestedflatbufferLength());
  _o.scalarKeySortedTables = this.bb!.createObjList(this.scalarKeySortedTables.bind(this), this.scalarKeySortedTablesLength());
}
}

export class MonsterT {
constructor(
  public pos: Vec3T|null = null,
  public mana: number = 150,
  public hp: number = 100,
  public name: string|Uint8Array|null = null,
  public inventory: (number)[] = [],
  public color: Color = Color.Blue,
  public testType: Any = Any.NONE,
  public test: MonsterT|MyGameExample2MonsterT|TestSimpleTableWithEnumT|null = null,
  public test4: (TestT)[] = [],
  public testarrayofstring: (string)[] = [],
  public testarrayoftables: (MonsterT)[] = [],
  public enemy: MonsterT|null = null,
  public testnestedflatbuffer: (number)[] = [],
  public testempty: StatT|null = null,
  public testbool: boolean = false,
  public testhashs32Fnv1: number = 0,
  public testhashu32Fnv1: number = 0,
  public testhashs64Fnv1: bigint = BigInt('0'),
  public testhashu64Fnv1: bigint = BigInt('0'),
  public testhashs32Fnv1a: number = 0,
  public testhashu32Fnv1a: number = 0,
  public testhashs64Fnv1a: bigint = BigInt('0'),
  public testhashu64Fnv1a: bigint = BigInt('0'),
  public testarrayofbools: (boolean)[] = [],
  public testf: number = 3.14159,
  public testf2: number = 3.0,
  public testf3: number = 0.0,
  public testarrayofstring2: (string)[] = [],
  public testarrayofsortedstruct: (AbilityT)[] = [],
  public flex: (number)[] = [],
  public test5: (TestT)[] = [],
  public vectorOfLongs: (bigint)[] = [],
  public vectorOfDoubles: (number)[] = [],
  public parentNamespaceTest: InParentNamespaceT|null = null,
  public vectorOfReferrables: (ReferrableT)[] = [],
  public singleWeakReference: bigint = BigInt('0'),
  public vectorOfWeakReferences: (bigint)[] = [],
  public vectorOfStrongReferrables: (ReferrableT)[] = [],
  public coOwningReference: bigint = BigInt('0'),
  public vectorOfCoOwningReferences: (bigint)[] = [],
  public nonOwningReference: bigint = BigInt('0'),
  public vectorOfNonOwningReferences: (bigint)[] = [],
  public anyUniqueType: AnyUniqueAliases = AnyUniqueAliases.NONE,
  public anyUnique: MonsterT|MyGameExample2MonsterT|TestSimpleTableWithEnumT|null = null,
  public anyAmbiguousType: AnyAmbiguousAliases = AnyAmbiguousAliases.NONE,
  public anyAmbiguous: MonsterT|null = null,
  public vectorOfEnums: (Color)[] = [],
  public signedEnum: Race = Race.None,
  public testrequirednestedflatbuffer: (number)[] = [],
  public scalarKeySortedTables: (StatT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const name = (this.name !== null ? builder.createString(this.name!) : 0);
  const inventory = Monster.createInventoryVector(builder, this.inventory);
  const test = builder.createObjectOffset(this.test);
  const test4 = builder.createStructOffsetList(this.test4, Monster.startTest4Vector);
  const testarrayofstring = Monster.createTestarrayofstringVector(builder, builder.createObjectOffsetList(this.testarrayofstring));
  const testarrayoftables = Monster.createTestarrayoftablesVector(builder, builder.createObjectOffsetList(this.testarrayoftables));
  const enemy = (this.enemy !== null ? this.enemy!.pack(builder) : 0);
  const testnestedflatbuffer = Monster.createTestnestedflatbufferVector(builder, this.testnestedflatbuffer);
  const testempty = (this.testempty !== null ? this.testempty!.pack(builder) : 0);
  const testarrayofbools = Monster.createTestarrayofboolsVector(builder, this.testarrayofbools);
  const testarrayofstring2 = Monster.createTestarrayofstring2Vector(builder, builder.createObjectOffsetList(this.testarrayofstring2));
  const testarrayofsortedstruct = builder.createStructOffsetList(this.testarrayofsortedstruct, Monster.startTestarrayofsortedstructVector);
  const flex = Monster.createFlexVector(builder, this.flex);
  const test5 = builder.createStructOffsetList(this.test5, Monster.startTest5Vector);
  const vectorOfLongs = Monster.createVectorOfLongsVector(builder, this.vectorOfLongs);
  const vectorOfDoubles = Monster.createVectorOfDoublesVector(builder, this.vectorOfDoubles);
  const parentNamespaceTest = (this.parentNamespaceTest !== null ? this.parentNamespaceTest!.pack(builder) : 0);
  const vectorOfReferrables = Monster.createVectorOfReferrablesVector(builder, builder.createObjectOffsetList(this.vectorOfReferrables));
  const vectorOfWeakReferences = Monster.createVectorOfWeakReferencesVector(builder, this.vectorOfWeakReferences);
  const vectorOfStrongReferrables = Monster.createVectorOfStrongReferrablesVector(builder, builder.createObjectOffsetList(this.vectorOfStrongReferrables));
  const vectorOfCoOwningReferences = Monster.createVectorOfCoOwningReferencesVector(builder, this.vectorOfCoOwningReferences);
  const vectorOfNonOwningReferences = Monster.createVectorOfNonOwningReferencesVector(builder, this.vectorOfNonOwningReferences);
  const anyUnique = builder.createObjectOffset(this.anyUnique);
  const anyAmbiguous = builder.createObjectOffset(this.anyAmbiguous);
  const vectorOfEnums = Monster.createVectorOfEnumsVector(builder, this.vectorOfEnums);
  const testrequirednestedflatbuffer = Monster.createTestrequirednestedflatbufferVector(builder, this.testrequirednestedflatbuffer);
  const scalarKeySortedTables = Monster.createScalarKeySortedTablesVector(builder, builder.createObjectOffsetList(this.scalarKeySortedTables));

  Monster.startMonster(builder);
  Monster.addPos(builder, (this.pos !== null ? this.pos!.pack(builder) : 0));
  Monster.addMana(builder, this.mana);
  Monster.addHp(builder, this.hp);
  Monster.addName(builder, name);
  Monster.addInventory(builder, inventory);
  Monster.addColor(builder, this.color);
  Monster.addTestType(builder, this.testType);
  Monster.addTest(builder, test);
  Monster.addTest4(builder, test4);
  Monster.addTestarrayofstring(builder, testarrayofstring);
  Monster.addTestarrayoftables(builder, testarrayoftables);
  Monster.addEnemy(builder, enemy);
  Monster.addTestnestedflatbuffer(builder, testnestedflatbuffer);
  Monster.addTestempty(builder, testempty);
  Monster.addTestbool(builder, this.testbool);
  Monster.addTesthashs32Fnv1(builder, this.testhashs32Fnv1);
  Monster.addTesthashu32Fnv1(builder, this.testhashu32Fnv1);
  Monster.addTesthashs64Fnv1(builder, this.testhashs64Fnv1);
  Monster.addTesthashu64Fnv1(builder, this.testhashu64Fnv1);
  Monster.addTesthashs32Fnv1a(builder, this.testhashs32Fnv1a);
  Monster.addTesthashu32Fnv1a(builder, this.testhashu32Fnv1a);
  Monster.addTesthashs64Fnv1a(builder, this.testhashs64Fnv1a);
  Monster.addTesthashu64Fnv1a(builder, this.testhashu64Fnv1a);
  Monster.addTestarrayofbools(builder, testarrayofbools);
  Monster.addTestf(builder, this.testf);
  Monster.addTestf2(builder, this.testf2);
  Monster.addTestf3(builder, this.testf3);
  Monster.addTestarrayofstring2(builder, testarrayofstring2);
  Monster.addTestarrayofsortedstruct(builder, testarrayofsortedstruct);
  Monster.addFlex(builder, flex);
  Monster.addTest5(builder, test5);
  Monster.addVectorOfLongs(builder, vectorOfLongs);
  Monster.addVectorOfDoubles(builder, vectorOfDoubles);
  Monster.addParentNamespaceTest(builder, parentNamespaceTest);
  Monster.addVectorOfReferrables(builder, vectorOfReferrables);
  Monster.addSingleWeakReference(builder, this.singleWeakReference);
  Monster.addVectorOfWeakReferences(builder, vectorOfWeakReferences);
  Monster.addVectorOfStrongReferrables(builder, vectorOfStrongReferrables);
  Monster.addCoOwningReference(builder, this.coOwningReference);
  Monster.addVectorOfCoOwningReferences(builder, vectorOfCoOwningReferences);
  Monster.addNonOwningReference(builder, this.nonOwningReference);
  Monster.addVectorOfNonOwningReferences(builder, vectorOfNonOwningReferences);
  Monster.addAnyUniqueType(builder, this.anyUniqueType);
  Monster.addAnyUnique(builder, anyUnique);
  Monster.addAnyAmbiguousType(builder, this.anyAmbiguousType);
  Monster.addAnyAmbiguous(builder, anyAmbiguous);
  Monster.addVectorOfEnums(builder, vectorOfEnums);
  Monster.addSignedEnum(builder, this.signedEnum);
  Monster.addTestrequirednestedflatbuffer(builder, testrequirednestedflatbuffer);
  Monster.addScalarKeySortedTables(builder, scalarKeySortedTables);

  return Monster.endMonster(builder);
}
}

// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package Example

import (
	"bytes"
	"math"
	flatbuffers "github.com/google/flatbuffers/go"

	MyGame "MyGame"
)

/// an example documentation comment: "monster object"
type MonsterT struct {
	Pos *Vec3T `json:"pos"`
	Mana int16 `json:"mana"`
	Hp int16 `json:"hp"`
	Name string `json:"name"`
	Inventory []byte `json:"inventory"`
	Color Color `json:"color"`
	Test *AnyT `json:"test"`
	Test4 []*TestT `json:"test4"`
	Testarrayofstring []string `json:"testarrayofstring"`
	Testarrayoftables []*MonsterT `json:"testarrayoftables"`
	Enemy *MonsterT `json:"enemy"`
	Testnestedflatbuffer []byte `json:"testnestedflatbuffer"`
	Testempty *StatT `json:"testempty"`
	Testbool bool `json:"testbool"`
	Testhashs32Fnv1 int32 `json:"testhashs32_fnv1"`
	Testhashu32Fnv1 uint32 `json:"testhashu32_fnv1"`
	Testhashs64Fnv1 int64 `json:"testhashs64_fnv1"`
	Testhashu64Fnv1 uint64 `json:"testhashu64_fnv1"`
	Testhashs32Fnv1a int32 `json:"testhashs32_fnv1a"`
	Testhashu32Fnv1a uint32 `json:"testhashu32_fnv1a"`
	Testhashs64Fnv1a int64 `json:"testhashs64_fnv1a"`
	Testhashu64Fnv1a uint64 `json:"testhashu64_fnv1a"`
	Testarrayofbools []bool `json:"testarrayofbools"`
	Testf float32 `json:"testf"`
	Testf2 float32 `json:"testf2"`
	Testf3 float32 `json:"testf3"`
	Testarrayofstring2 []string `json:"testarrayofstring2"`
	Testarrayofsortedstruct []*AbilityT `json:"testarrayofsortedstruct"`
	Flex []byte `json:"flex"`
	Test5 []*TestT `json:"test5"`
	VectorOfLongs []int64 `json:"vector_of_longs"`
	VectorOfDoubles []float64 `json:"vector_of_doubles"`
	ParentNamespaceTest *MyGame.InParentNamespaceT `json:"parent_namespace_test"`
	VectorOfReferrables []*ReferrableT `json:"vector_of_referrables"`
	SingleWeakReference uint64 `json:"single_weak_reference"`
	VectorOfWeakReferences []uint64 `json:"vector_of_weak_references"`
	VectorOfStrongReferrables []*ReferrableT `json:"vector_of_strong_referrables"`
	CoOwningReference uint64 `json:"co_owning_reference"`
	VectorOfCoOwningReferences []uint64 `json:"vector_of_co_owning_references"`
	NonOwningReference uint64 `json:"non_owning_reference"`
	VectorOfNonOwningReferences []uint64 `json:"vector_of_non_owning_references"`
	AnyUnique *AnyUniqueAliasesT `json:"any_unique"`
	AnyAmbiguous *AnyAmbiguousAliasesT `json:"any_ambiguous"`
	VectorOfEnums []Color `json:"vector_of_enums"`
	SignedEnum Race `json:"signed_enum"`
	Testrequirednestedflatbuffer []byte `json:"testrequirednestedflatbuffer"`
	ScalarKeySortedTables []*StatT `json:"scalar_key_sorted_tables"`
	NativeInline *TestT `json:"native_inline"`
	LongEnumNonEnumDefault LongEnum `json:"long_enum_non_enum_default"`
	LongEnumNormalDefault LongEnum `json:"long_enum_normal_default"`
	NanDefault float32 `json:"nan_default"`
	InfDefault float32 `json:"inf_default"`
	PositiveInfDefault float32 `json:"positive_inf_default"`
	InfinityDefault float32 `json:"infinity_default"`
	PositiveInfinityDefault float32 `json:"positive_infinity_default"`
	NegativeInfDefault float32 `json:"negative_inf_default"`
	NegativeInfinityDefault float32 `json:"negative_infinity_default"`
	DoubleInfDefault float64 `json:"double_inf_default"`
}

func (t *MonsterT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	nameOffset := flatbuffers.UOffsetT(0)
	if t.Name != "" {
		nameOffset = builder.CreateString(t.Name)
	}
	inventoryOffset := flatbuffers.UOffsetT(0)
	if t.Inventory != nil {
		inventoryOffset = builder.CreateByteString(t.Inventory)
	}
	testOffset := t.Test.Pack(builder)
	
	test4Offset := flatbuffers.UOffsetT(0)
	if t.Test4 != nil {
		test4Length := len(t.Test4)
		MonsterStartTest4Vector(builder, test4Length)
		for j := test4Length - 1; j >= 0; j-- {
			t.Test4[j].Pack(builder)
		}
		test4Offset = builder.EndVector(test4Length)
	}
	testarrayofstringOffset := flatbuffers.UOffsetT(0)
	if t.Testarrayofstring != nil {
		testarrayofstringLength := len(t.Testarrayofstring)
		testarrayofstringOffsets := make([]flatbuffers.UOffsetT, testarrayofstringLength)
		for j := 0; j < testarrayofstringLength; j++ {
			testarrayofstringOffsets[j] = builder.CreateString(t.Testarrayofstring[j])
		}
		MonsterStartTestarrayofstringVector(builder, testarrayofstringLength)
		for j := testarrayofstringLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(testarrayofstringOffsets[j])
		}
		testarrayofstringOffset = builder.EndVector(testarrayofstringLength)
	}
	testarrayoftablesOffset := flatbuffers.UOffsetT(0)
	if t.Testarrayoftables != nil {
		testarrayoftablesLength := len(t.Testarrayoftables)
		testarrayoftablesOffsets := make([]flatbuffers.UOffsetT, testarrayoftablesLength)
		for j := 0; j < testarrayoftablesLength; j++ {
			testarrayoftablesOffsets[j] = t.Testarrayoftables[j].Pack(builder)
		}
		MonsterStartTestarrayoftablesVector(builder, testarrayoftablesLength)
		for j := testarrayoftablesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(testarrayoftablesOffsets[j])
		}
		testarrayoftablesOffset = builder.EndVector(testarrayoftablesLength)
	}
	enemyOffset := t.Enemy.Pack(builder)
	testnestedflatbufferOffset := flatbuffers.UOffsetT(0)
	if t.Testnestedflatbuffer != nil {
		testnestedflatbufferOffset = builder.CreateByteString(t.Testnestedflatbuffer)
	}
	testemptyOffset := t.Testempty.Pack(builder)
	testarrayofboolsOffset := flatbuffers.UOffsetT(0)
	if t.Testarrayofbools != nil {
		testarrayofboolsLength := len(t.Testarrayofbools)
		MonsterStartTestarrayofboolsVector(builder, testarrayofboolsLength)
		for j := testarrayofboolsLength - 1; j >= 0; j-- {
			builder.PrependBool(t.Testarrayofbools[j])
		}
		testarrayofboolsOffset = builder.EndVector(testarrayofboolsLength)
	}
	testarrayofstring2Offset := flatbuffers.UOffsetT(0)
	if t.Testarrayofstring2 != nil {
		testarrayofstring2Length := len(t.Testarrayofstring2)
		testarrayofstring2Offsets := make([]flatbuffers.UOffsetT, testarrayofstring2Length)
		for j := 0; j < testarrayofstring2Length; j++ {
			testarrayofstring2Offsets[j] = builder.CreateString(t.Testarrayofstring2[j])
		}
		MonsterStartTestarrayofstring2Vector(builder, testarrayofstring2Length)
		for j := testarrayofstring2Length - 1; j >= 0; j-- {
			builder.PrependUOffsetT(testarrayofstring2Offsets[j])
		}
		testarrayofstring2Offset = builder.EndVector(testarrayofstring2Length)
	}
	testarrayofsortedstructOffset := flatbuffers.UOffsetT(0)
	if t.Testarrayofsortedstruct != nil {
		testarrayofsortedstructLength := len(t.Testarrayofsortedstruct)
		MonsterStartTestarrayofsortedstructVector(builder, testarrayofsortedstructLength)
		for j := testarrayofsortedstructLength - 1; j >= 0; j-- {
			t.Testarrayofsortedstruct[j].Pack(builder)
		}
		testarrayofsortedstructOffset = builder.EndVector(testarrayofsortedstructLength)
	}
	flexOffset := flatbuffers.UOffsetT(0)
	if t.Flex != nil {
		flexOffset = builder.CreateByteString(t.Flex)
	}
	test5Offset := flatbuffers.UOffsetT(0)
	if t.Test5 != nil {
		test5Length := len(t.Test5)
		MonsterStartTest5Vector(builder, test5Length)
		for j := test5Length - 1; j >= 0; j-- {
			t.Test5[j].Pack(builder)
		}
		test5Offset = builder.EndVector(test5Length)
	}
	vectorOfLongsOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfLongs != nil {
		vectorOfLongsLength := len(t.VectorOfLongs)
		MonsterStartVectorOfLongsVector(builder, vectorOfLongsLength)
		for j := vectorOfLongsLength - 1; j >= 0; j-- {
			builder.PrependInt64(t.VectorOfLongs[j])
		}
		vectorOfLongsOffset = builder.EndVector(vectorOfLongsLength)
	}
	vectorOfDoublesOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfDoubles != nil {
		vectorOfDoublesLength := len(t.VectorOfDoubles)
		MonsterStartVectorOfDoublesVector(builder, vectorOfDoublesLength)
		for j := vectorOfDoublesLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.VectorOfDoubles[j])
		}
		vectorOfDoublesOffset = builder.EndVector(vectorOfDoublesLength)
	}
	parentNamespaceTestOffset := t.ParentNamespaceTest.Pack(builder)
	vectorOfReferrablesOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfReferrables != nil {
		vectorOfReferrablesLength := len(t.VectorOfReferrables)
		vectorOfReferrablesOffsets := make([]flatbuffers.UOffsetT, vectorOfReferrablesLength)
		for j := 0; j < vectorOfReferrablesLength; j++ {
			vectorOfReferrablesOffsets[j] = t.VectorOfReferrables[j].Pack(builder)
		}
		MonsterStartVectorOfReferrablesVector(builder, vectorOfReferrablesLength)
		for j := vectorOfReferrablesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(vectorOfReferrablesOffsets[j])
		}
		vectorOfReferrablesOffset = builder.EndVector(vectorOfReferrablesLength)
	}
	vectorOfWeakReferencesOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfWeakReferences != nil {
		vectorOfWeakReferencesLength := len(t.VectorOfWeakReferences)
		MonsterStartVectorOfWeakReferencesVector(builder, vectorOfWeakReferencesLength)
		for j := vectorOfWeakReferencesLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.VectorOfWeakReferences[j])
		}
		vectorOfWeakReferencesOffset = builder.EndVector(vectorOfWeakReferencesLength)
	}
	vectorOfStrongReferrablesOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfStrongReferrables != nil {
		vectorOfStrongReferrablesLength := len(t.VectorOfStrongReferrables)
		vectorOfStrongReferrablesOffsets := make([]flatbuffers.UOffsetT, vectorOfStrongReferrablesLength)
		for j := 0; j < vectorOfStrongReferrablesLength; j++ {
			vectorOfStrongReferrablesOffsets[j] = t.VectorOfStrongReferrables[j].Pack(builder)
		}
		MonsterStartVectorOfStrongReferrablesVector(builder, vectorOfStrongReferrablesLength)
		for j := vectorOfStrongReferrablesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(vectorOfStrongReferrablesOffsets[j])
		}
		vectorOfStrongReferrablesOffset = builder.EndVector(vectorOfStrongReferrablesLength)
	}
	vectorOfCoOwningReferencesOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfCoOwningReferences != nil {
		vectorOfCoOwningReferencesLength := len(t.VectorOfCoOwningReferences)
		MonsterStartVectorOfCoOwningReferencesVector(builder, vectorOfCoOwningReferencesLength)
		for j := vectorOfCoOwningReferencesLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.VectorOfCoOwningReferences[j])
		}
		vectorOfCoOwningReferencesOffset = builder.EndVector(vectorOfCoOwningReferencesLength)
	}
	vectorOfNonOwningReferencesOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfNonOwningReferences != nil {
		vectorOfNonOwningReferencesLength := len(t.VectorOfNonOwningReferences)
		MonsterStartVectorOfNonOwningReferencesVector(builder, vectorOfNonOwningReferencesLength)
		for j := vectorOfNonOwningReferencesLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.VectorOfNonOwningReferences[j])
		}
		vectorOfNonOwningReferencesOffset = builder.EndVector(vectorOfNonOwningReferencesLength)
	}
	anyUniqueOffset := t.AnyUnique.Pack(builder)
	
	anyAmbiguousOffset := t.AnyAmbiguous.Pack(builder)
	
	vectorOfEnumsOffset := flatbuffers.UOffsetT(0)
	if t.VectorOfEnums != nil {
		vectorOfEnumsLength := len(t.VectorOfEnums)
		MonsterStartVectorOfEnumsVector(builder, vectorOfEnumsLength)
		for j := vectorOfEnumsLength - 1; j >= 0; j-- {
			builder.PrependByte(byte(t.VectorOfEnums[j]))
		}
		vectorOfEnumsOffset = builder.EndVector(vectorOfEnumsLength)
	}
	testrequirednestedflatbufferOffset := flatbuffers.UOffsetT(0)
	if t.Testrequirednestedflatbuffer != nil {
		testrequirednestedflatbufferOffset = builder.CreateByteString(t.Testrequirednestedflatbuffer)
	}
	scalarKeySortedTablesOffset := flatbuffers.UOffsetT(0)
	if t.ScalarKeySortedTables != nil {
		scalarKeySortedTablesLength := len(t.ScalarKeySortedTables)
		scalarKeySortedTablesOffsets := make([]flatbuffers.UOffsetT, scalarKeySortedTablesLength)
		for j := 0; j < scalarKeySortedTablesLength; j++ {
			scalarKeySortedTablesOffsets[j] = t.ScalarKeySortedTables[j].Pack(builder)
		}
		MonsterStartScalarKeySortedTablesVector(builder, scalarKeySortedTablesLength)
		for j := scalarKeySortedTablesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(scalarKeySortedTablesOffsets[j])
		}
		scalarKeySortedTablesOffset = builder.EndVector(scalarKeySortedTablesLength)
	}
	MonsterStart(builder)
	posOffset := t.Pos.Pack(builder)
	MonsterAddPos(builder, posOffset)
	MonsterAddMana(builder, t.Mana)
	MonsterAddHp(builder, t.Hp)
	MonsterAddName(builder, nameOffset)
	MonsterAddInventory(builder, inventoryOffset)
	MonsterAddColor(builder, t.Color)
	if t.Test != nil {
		MonsterAddTestType(builder, t.Test.Type)
	}
	MonsterAddTest(builder, testOffset)
	MonsterAddTest4(builder, test4Offset)
	MonsterAddTestarrayofstring(builder, testarrayofstringOffset)
	MonsterAddTestarrayoftables(builder, testarrayoftablesOffset)
	MonsterAddEnemy(builder, enemyOffset)
	MonsterAddTestnestedflatbuffer(builder, testnestedflatbufferOffset)
	MonsterAddTestempty(builder, testemptyOffset)
	MonsterAddTestbool(builder, t.Testbool)
	MonsterAddTesthashs32Fnv1(builder, t.Testhashs32Fnv1)
	MonsterAddTesthashu32Fnv1(builder, t.Testhashu32Fnv1)
	MonsterAddTesthashs64Fnv1(builder, t.Testhashs64Fnv1)
	MonsterAddTesthashu64Fnv1(builder, t.Testhashu64Fnv1)
	MonsterAddTesthashs32Fnv1a(builder, t.Testhashs32Fnv1a)
	MonsterAddTesthashu32Fnv1a(builder, t.Testhashu32Fnv1a)
	MonsterAddTesthashs64Fnv1a(builder, t.Testhashs64Fnv1a)
	MonsterAddTesthashu64Fnv1a(builder, t.Testhashu64Fnv1a)
	MonsterAddTestarrayofbools(builder, testarrayofboolsOffset)
	MonsterAddTestf(builder, t.Testf)
	MonsterAddTestf2(builder, t.Testf2)
	MonsterAddTestf3(builder, t.Testf3)
	MonsterAddTestarrayofstring2(builder, testarrayofstring2Offset)
	MonsterAddTestarrayofsortedstruct(builder, testarrayofsortedstructOffset)
	MonsterAddFlex(builder, flexOffset)
	MonsterAddTest5(builder, test5Offset)
	MonsterAddVectorOfLongs(builder, vectorOfLongsOffset)
	MonsterAddVectorOfDoubles(builder, vectorOfDoublesOffset)
	MonsterAddParentNamespaceTest(builder, parentNamespaceTestOffset)
	MonsterAddVectorOfReferrables(builder, vectorOfReferrablesOffset)
	MonsterAddSingleWeakReference(builder, t.SingleWeakReference)
	MonsterAddVectorOfWeakReferences(builder, vectorOfWeakReferencesOffset)
	MonsterAddVectorOfStrongReferrables(builder, vectorOfStrongReferrablesOffset)
	MonsterAddCoOwningReference(builder, t.CoOwningReference)
	MonsterAddVectorOfCoOwningReferences(builder, vectorOfCoOwningReferencesOffset)
	MonsterAddNonOwningReference(builder, t.NonOwningReference)
	MonsterAddVectorOfNonOwningReferences(builder, vectorOfNonOwningReferencesOffset)
	if t.AnyUnique != nil {
		MonsterAddAnyUniqueType(builder, t.AnyUnique.Type)
	}
	MonsterAddAnyUnique(builder, anyUniqueOffset)
	if t.AnyAmbiguous != nil {
		MonsterAddAnyAmbiguousType(builder, t.AnyAmbiguous.Type)
	}
	MonsterAddAnyAmbiguous(builder, anyAmbiguousOffset)
	MonsterAddVectorOfEnums(builder, vectorOfEnumsOffset)
	MonsterAddSignedEnum(builder, t.SignedEnum)
	MonsterAddTestrequirednestedflatbuffer(builder, testrequirednestedflatbufferOffset)
	MonsterAddScalarKeySortedTables(builder, scalarKeySortedTablesOffset)
	nativeInlineOffset := t.NativeInline.Pack(builder)
	MonsterAddNativeInline(builder, nativeInlineOffset)
	MonsterAddLongEnumNonEnumDefault(builder, t.LongEnumNonEnumDefault)
	MonsterAddLongEnumNormalDefault(builder, t.LongEnumNormalDefault)
	MonsterAddNanDefault(builder, t.NanDefault)
	MonsterAddInfDefault(builder, t.InfDefault)
	MonsterAddPositiveInfDefault(builder, t.PositiveInfDefault)
	MonsterAddInfinityDefault(builder, t.InfinityDefault)
	MonsterAddPositiveInfinityDefault(builder, t.PositiveInfinityDefault)
	MonsterAddNegativeInfDefault(builder, t.NegativeInfDefault)
	MonsterAddNegativeInfinityDefault(builder, t.NegativeInfinityDefault)
	MonsterAddDoubleInfDefault(builder, t.DoubleInfDefault)
	return MonsterEnd(builder)
}

func (rcv *Monster) UnPackTo(t *MonsterT) {
	t.Pos = rcv.Pos(nil).UnPack()
	t.Mana = rcv.Mana()
	t.Hp = rcv.Hp()
	t.Name = string(rcv.Name())
	t.Inventory = rcv.InventoryBytes()
	t.Color = rcv.Color()
	testTable := flatbuffers.Table{}
	if rcv.Test(&testTable) {
		t.Test = rcv.TestType().UnPack(testTable)
	}
	test4Length := rcv.Test4Length()
	t.Test4 = make([]*TestT, test4Length)
	for j := 0; j < test4Length; j++ {
		x := Test{}
		rcv.Test4(&x, j)
		t.Test4[j] = x.UnPack()
	}
	testarrayofstringLength := rcv.TestarrayofstringLength()
	t.Testarrayofstring = make([]string, testarrayofstringLength)
	for j := 0; j < testarrayofstringLength; j++ {
		t.Testarrayofstring[j] = string(rcv.Testarrayofstring(j))
	}
	testarrayoftablesLength := rcv.TestarrayoftablesLength()
	t.Testarrayoftables = make([]*MonsterT, testarrayoftablesLength)
	for j := 0; j < testarrayoftablesLength; j++ {
		x := Monster{}
		rcv.Testarrayoftables(&x, j)
		t.Testarrayoftables[j] = x.UnPack()
	}
	t.Enemy = rcv.Enemy(nil).UnPack()
	t.Testnestedflatbuffer = rcv.TestnestedflatbufferBytes()
	t.Testempty = rcv.Testempty(nil).UnPack()
	t.Testbool = rcv.Testbool()
	t.Testhashs32Fnv1 = rcv.Testhashs32Fnv1()
	t.Testhashu32Fnv1 = rcv.Testhashu32Fnv1()
	t.Testhashs64Fnv1 = rcv.Testhashs64Fnv1()
	t.Testhashu64Fnv1 = rcv.Testhashu64Fnv1()
	t.Testhashs32Fnv1a = rcv.Testhashs32Fnv1a()
	t.Testhashu32Fnv1a = rcv.Testhashu32Fnv1a()
	t.Testhashs64Fnv1a = rcv.Testhashs64Fnv1a()
	t.Testhashu64Fnv1a = rcv.Testhashu64Fnv1a()
	testarrayofboolsLength := rcv.TestarrayofboolsLength()
	t.Testarrayofbools = make([]bool, testarrayofboolsLength)
	for j := 0; j < testarrayofboolsLength; j++ {
		t.Testarrayofbools[j] = rcv.Testarrayofbools(j)
	}
	t.Testf = rcv.Testf()
	t.Testf2 = rcv.Testf2()
	t.Testf3 = rcv.Testf3()
	testarrayofstring2Length := rcv.Testarrayofstring2Length()
	t.Testarrayofstring2 = make([]string, testarrayofstring2Length)
	for j := 0; j < testarrayofstring2Length; j++ {
		t.Testarrayofstring2[j] = string(rcv.Testarrayofstring2(j))
	}
	testarrayofsortedstructLength := rcv.TestarrayofsortedstructLength()
	t.Testarrayofsortedstruct = make([]*AbilityT, testarrayofsortedstructLength)
	for j := 0; j < testarrayofsortedstructLength; j++ {
		x := Ability{}
		rcv.Testarrayofsortedstruct(&x, j)
		t.Testarrayofsortedstruct[j] = x.UnPack()
	}
	t.Flex = rcv.FlexBytes()
	test5Length := rcv.Test5Length()
	t.Test5 = make([]*TestT, test5Length)
	for j := 0; j < test5Length; j++ {
		x := Test{}
		rcv.Test5(&x, j)
		t.Test5[j] = x.UnPack()
	}
	vectorOfLongsLength := rcv.VectorOfLongsLength()
	t.VectorOfLongs = make([]int64, vectorOfLongsLength)
	for j := 0; j < vectorOfLongsLength; j++ {
		t.VectorOfLongs[j] = rcv.VectorOfLongs(j)
	}
	vectorOfDoublesLength := rcv.VectorOfDoublesLength()
	t.VectorOfDoubles = make([]float64, vectorOfDoublesLength)
	for j := 0; j < vectorOfDoublesLength; j++ {
		t.VectorOfDoubles[j] = rcv.VectorOfDoubles(j)
	}
	t.ParentNamespaceTest = rcv.ParentNamespaceTest(nil).UnPack()
	vectorOfReferrablesLength := rcv.VectorOfReferrablesLength()
	t.VectorOfReferrables = make([]*ReferrableT, vectorOfReferrablesLength)
	for j := 0; j < vectorOfReferrablesLength; j++ {
		x := Referrable{}
		rcv.VectorOfReferrables(&x, j)
		t.VectorOfReferrables[j] = x.UnPack()
	}
	t.SingleWeakReference = rcv.SingleWeakReference()
	vectorOfWeakReferencesLength := rcv.VectorOfWeakReferencesLength()
	t.VectorOfWeakReferences = make([]uint64, vectorOfWeakReferencesLength)
	for j := 0; j < vectorOfWeakReferencesLength; j++ {
		t.VectorOfWeakReferences[j] = rcv.VectorOfWeakReferences(j)
	}
	vectorOfStrongReferrablesLength := rcv.VectorOfStrongReferrablesLength()
	t.VectorOfStrongReferrables = make([]*ReferrableT, vectorOfStrongReferrablesLength)
	for j := 0; j < vectorOfStrongReferrablesLength; j++ {
		x := Referrable{}
		rcv.VectorOfStrongReferrables(&x, j)
		t.VectorOfStrongReferrables[j] = x.UnPack()
	}
	t.CoOwningReference = rcv.CoOwningReference()
	vectorOfCoOwningReferencesLength := rcv.VectorOfCoOwningReferencesLength()
	t.VectorOfCoOwningReferences = make([]uint64, vectorOfCoOwningReferencesLength)
	for j := 0; j < vectorOfCoOwningReferencesLength; j++ {
		t.VectorOfCoOwningReferences[j] = rcv.VectorOfCoOwningReferences(j)
	}
	t.NonOwningReference = rcv.NonOwningReference()
	vectorOfNonOwningReferencesLength := rcv.VectorOfNonOwningReferencesLength()
	t.VectorOfNonOwningReferences = make([]uint64, vectorOfNonOwningReferencesLength)
	for j := 0; j < vectorOfNonOwningReferencesLength; j++ {
		t.VectorOfNonOwningReferences[j] = rcv.VectorOfNonOwningReferences(j)
	}
	anyUniqueTable := flatbuffers.Table{}
	if rcv.AnyUnique(&anyUniqueTable) {
		t.AnyUnique = rcv.AnyUniqueType().UnPack(anyUniqueTable)
	}
	anyAmbiguousTable := flatbuffers.Table{}
	if rcv.AnyAmbiguous(&anyAmbiguousTable) {
		t.AnyAmbiguous = rcv.AnyAmbiguousType().UnPack(anyAmbiguousTable)
	}
	vectorOfEnumsLength := rcv.VectorOfEnumsLength()
	t.VectorOfEnums = make([]Color, vectorOfEnumsLength)
	for j := 0; j < vectorOfEnumsLength; j++ {
		t.VectorOfEnums[j] = rcv.VectorOfEnums(j)
	}
	t.SignedEnum = rcv.SignedEnum()
	t.Testrequirednestedflatbuffer = rcv.TestrequirednestedflatbufferBytes()
	scalarKeySortedTablesLength := rcv.ScalarKeySortedTablesLength()
	t.ScalarKeySortedTables = make([]*StatT, scalarKeySortedTablesLength)
	for j := 0; j < scalarKeySortedTablesLength; j++ {
		x := Stat{}
		rcv.ScalarKeySortedTables(&x, j)
		t.ScalarKeySortedTables[j] = x.UnPack()
	}
	t.NativeInline = rcv.NativeInline(nil).UnPack()
	t.LongEnumNonEnumDefault = rcv.LongEnumNonEnumDefault()
	t.LongEnumNormalDefault = rcv.LongEnumNormalDefault()
	t.NanDefault = rcv.NanDefault()
	t.InfDefault = rcv.InfDefault()
	t.PositiveInfDefault = rcv.PositiveInfDefault()
	t.InfinityDefault = rcv.InfinityDefault()
	t.PositiveInfinityDefault = rcv.PositiveInfinityDefault()
	t.NegativeInfDefault = rcv.NegativeInfDefault()
	t.NegativeInfinityDefault = rcv.NegativeInfinityDefault()
	t.DoubleInfDefault = rcv.DoubleInfDefault()
}

func (rcv *Monster) UnPack() *MonsterT {
	if rcv == nil { return nil }
	t := &MonsterT{}
	rcv.UnPackTo(t)
	return t
}

type Monster struct {
	_tab flatbuffers.Table
}

func GetRootAsMonster(buf []byte, offset flatbuffers.UOffsetT) *Monster {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Monster{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsMonster(buf []byte, offset flatbuffers.UOffsetT) *Monster {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Monster{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Monster) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Monster) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Monster) Pos(obj *Vec3) *Vec3 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Vec3)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Monster) Mana() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 150
}

func (rcv *Monster) MutateMana(n int16) bool {
	return rcv._tab.MutateInt16Slot(6, n)
}

func (rcv *Monster) Hp() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 100
}

func (rcv *Monster) MutateHp(n int16) bool {
	return rcv._tab.MutateInt16Slot(8, n)
}

func (rcv *Monster) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func MonsterKeyCompare(o1, o2 flatbuffers.UOffsetT, buf []byte) bool {
	obj1 := &Monster{}
	obj2 := &Monster{}
	obj1.Init(buf, flatbuffers.UOffsetT(len(buf)) - o1)
	obj2.Init(buf, flatbuffers.UOffsetT(len(buf)) - o2)
	return string(obj1.Name()) < string(obj2.Name())
}

func (rcv *Monster) LookupByKey(key string, vectorLocation flatbuffers.UOffsetT, buf []byte) bool {
	span := flatbuffers.GetUOffsetT(buf[vectorLocation - 4:])
	start := flatbuffers.UOffsetT(0)
	bKey := []byte(key)
	for span != 0 {
		middle := span / 2
		tableOffset := flatbuffers.GetIndirectOffset(buf, vectorLocation+ 4 * (start + middle))
		obj := &Monster{}
		obj.Init(buf, tableOffset)
		comp := bytes.Compare(obj.Name(), bKey)
		if comp > 0 {
			span = middle
		} else if comp < 0 {
			middle += 1
			start += middle
			span -= middle
		} else {
			rcv.Init(buf, tableOffset)
			return true
		}
	}
	return false
}

func (rcv *Monster) Inventory(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Monster) InventoryLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) InventoryBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Monster) MutateInventory(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Monster) Color() Color {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return Color(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 8
}

func (rcv *Monster) MutateColor(n Color) bool {
	return rcv._tab.MutateByteSlot(16, byte(n))
}

func (rcv *Monster) TestType() Any {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return Any(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Monster) MutateTestType(n Any) bool {
	return rcv._tab.MutateByteSlot(18, byte(n))
}

func (rcv *Monster) Test(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *Monster) Test4(obj *Test, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) Test4Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) Testarrayofstring(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Monster) TestarrayofstringLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// an example documentation comment: this will end up in the generated code
/// multiline too
func (rcv *Monster) Testarrayoftables(obj *Monster, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) TestarrayoftablesByKey(obj *Monster, key string) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Monster) TestarrayoftablesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// an example documentation comment: this will end up in the generated code
/// multiline too
func (rcv *Monster) Enemy(obj *Monster) *Monster {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Monster)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Monster) Testnestedflatbuffer(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Monster) TestnestedflatbufferLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) TestnestedflatbufferBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Monster) MutateTestnestedflatbuffer(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Monster) Testempty(obj *Stat) *Stat {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Stat)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Monster) Testbool() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *Monster) MutateTestbool(n bool) bool {
	return rcv._tab.MutateBoolSlot(34, n)
}

func (rcv *Monster) Testhashs32Fnv1() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashs32Fnv1(n int32) bool {
	return rcv._tab.MutateInt32Slot(36, n)
}

func (rcv *Monster) Testhashu32Fnv1() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashu32Fnv1(n uint32) bool {
	return rcv._tab.MutateUint32Slot(38, n)
}

func (rcv *Monster) Testhashs64Fnv1() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashs64Fnv1(n int64) bool {
	return rcv._tab.MutateInt64Slot(40, n)
}

func (rcv *Monster) Testhashu64Fnv1() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashu64Fnv1(n uint64) bool {
	return rcv._tab.MutateUint64Slot(42, n)
}

func (rcv *Monster) Testhashs32Fnv1a() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashs32Fnv1a(n int32) bool {
	return rcv._tab.MutateInt32Slot(44, n)
}

func (rcv *Monster) Testhashu32Fnv1a() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashu32Fnv1a(n uint32) bool {
	return rcv._tab.MutateUint32Slot(46, n)
}

func (rcv *Monster) Testhashs64Fnv1a() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashs64Fnv1a(n int64) bool {
	return rcv._tab.MutateInt64Slot(48, n)
}

func (rcv *Monster) Testhashu64Fnv1a() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateTesthashu64Fnv1a(n uint64) bool {
	return rcv._tab.MutateUint64Slot(50, n)
}

func (rcv *Monster) Testarrayofbools(j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetBool(a + flatbuffers.UOffsetT(j*1))
	}
	return false
}

func (rcv *Monster) TestarrayofboolsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) MutateTestarrayofbools(j int, n bool) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateBool(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Monster) Testf() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 3.14159
}

func (rcv *Monster) MutateTestf(n float32) bool {
	return rcv._tab.MutateFloat32Slot(54, n)
}

func (rcv *Monster) Testf2() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 3.0
}

func (rcv *Monster) MutateTestf2(n float32) bool {
	return rcv._tab.MutateFloat32Slot(56, n)
}

func (rcv *Monster) Testf3() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *Monster) MutateTestf3(n float32) bool {
	return rcv._tab.MutateFloat32Slot(58, n)
}

func (rcv *Monster) Testarrayofstring2(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Monster) Testarrayofstring2Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) Testarrayofsortedstruct(obj *Ability, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 8
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) TestarrayofsortedstructLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) Flex(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Monster) FlexLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) FlexBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Monster) MutateFlex(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Monster) Test5(obj *Test, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) Test5Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) VectorOfLongs(j int) int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Monster) VectorOfLongsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) MutateVectorOfLongs(j int, n int64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Monster) VectorOfDoubles(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Monster) VectorOfDoublesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) MutateVectorOfDoubles(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Monster) ParentNamespaceTest(obj *MyGame.InParentNamespace) *MyGame.InParentNamespace {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(MyGame.InParentNamespace)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Monster) VectorOfReferrables(obj *Referrable, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) VectorOfReferrablesByKey(obj *Referrable, key uint64) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Monster) VectorOfReferrablesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(74))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) SingleWeakReference() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(76))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateSingleWeakReference(n uint64) bool {
	return rcv._tab.MutateUint64Slot(76, n)
}

func (rcv *Monster) VectorOfWeakReferences(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Monster) VectorOfWeakReferencesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) MutateVectorOfWeakReferences(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(78))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Monster) VectorOfStrongReferrables(obj *Referrable, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) VectorOfStrongReferrablesByKey(obj *Referrable, key uint64) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Monster) VectorOfStrongReferrablesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(80))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) CoOwningReference() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(82))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateCoOwningReference(n uint64) bool {
	return rcv._tab.MutateUint64Slot(82, n)
}

func (rcv *Monster) VectorOfCoOwningReferences(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Monster) VectorOfCoOwningReferencesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) MutateVectorOfCoOwningReferences(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(84))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Monster) NonOwningReference() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(86))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Monster) MutateNonOwningReference(n uint64) bool {
	return rcv._tab.MutateUint64Slot(86, n)
}

func (rcv *Monster) VectorOfNonOwningReferences(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Monster) VectorOfNonOwningReferencesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) MutateVectorOfNonOwningReferences(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(88))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Monster) AnyUniqueType() AnyUniqueAliases {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(90))
	if o != 0 {
		return AnyUniqueAliases(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Monster) MutateAnyUniqueType(n AnyUniqueAliases) bool {
	return rcv._tab.MutateByteSlot(90, byte(n))
}

func (rcv *Monster) AnyUnique(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(92))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *Monster) AnyAmbiguousType() AnyAmbiguousAliases {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(94))
	if o != 0 {
		return AnyAmbiguousAliases(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Monster) MutateAnyAmbiguousType(n AnyAmbiguousAliases) bool {
	return rcv._tab.MutateByteSlot(94, byte(n))
}

func (rcv *Monster) AnyAmbiguous(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(96))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func (rcv *Monster) VectorOfEnums(j int) Color {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return Color(rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1)))
	}
	return 0
}

func (rcv *Monster) VectorOfEnumsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) VectorOfEnumsBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Monster) MutateVectorOfEnums(j int, n Color) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(98))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), byte(n))
	}
	return false
}

func (rcv *Monster) SignedEnum() Race {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(100))
	if o != 0 {
		return Race(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return -1
}

func (rcv *Monster) MutateSignedEnum(n Race) bool {
	return rcv._tab.MutateInt8Slot(100, int8(n))
}

func (rcv *Monster) Testrequirednestedflatbuffer(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Monster) TestrequirednestedflatbufferLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) TestrequirednestedflatbufferBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Monster) MutateTestrequirednestedflatbuffer(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(102))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Monster) ScalarKeySortedTables(obj *Stat, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Monster) ScalarKeySortedTablesByKey(obj *Stat, key uint16) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Monster) ScalarKeySortedTablesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(104))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Monster) NativeInline(obj *Test) *Test {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(106))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Test)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Monster) LongEnumNonEnumDefault() LongEnum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(108))
	if o != 0 {
		return LongEnum(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Monster) MutateLongEnumNonEnumDefault(n LongEnum) bool {
	return rcv._tab.MutateUint64Slot(108, uint64(n))
}

func (rcv *Monster) LongEnumNormalDefault() LongEnum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(110))
	if o != 0 {
		return LongEnum(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 2
}

func (rcv *Monster) MutateLongEnumNormalDefault(n LongEnum) bool {
	return rcv._tab.MutateUint64Slot(110, uint64(n))
}

func (rcv *Monster) NanDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(112))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.NaN())
}

func (rcv *Monster) MutateNanDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(112, n)
}

func (rcv *Monster) InfDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(114))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.Inf(1))
}

func (rcv *Monster) MutateInfDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(114, n)
}

func (rcv *Monster) PositiveInfDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(116))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.Inf(1))
}

func (rcv *Monster) MutatePositiveInfDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(116, n)
}

func (rcv *Monster) InfinityDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(118))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.Inf(1))
}

func (rcv *Monster) MutateInfinityDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(118, n)
}

func (rcv *Monster) PositiveInfinityDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(120))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.Inf(1))
}

func (rcv *Monster) MutatePositiveInfinityDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(120, n)
}

func (rcv *Monster) NegativeInfDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(122))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.Inf(-1))
}

func (rcv *Monster) MutateNegativeInfDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(122, n)
}

func (rcv *Monster) NegativeInfinityDefault() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(124))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return float32(math.Inf(-1))
}

func (rcv *Monster) MutateNegativeInfinityDefault(n float32) bool {
	return rcv._tab.MutateFloat32Slot(124, n)
}

func (rcv *Monster) DoubleInfDefault() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(126))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return float64(math.Inf(1))
}

func (rcv *Monster) MutateDoubleInfDefault(n float64) bool {
	return rcv._tab.MutateFloat64Slot(126, n)
}

func MonsterStart(builder *flatbuffers.Builder) {
	builder.StartObject(62)
}
func MonsterAddPos(builder *flatbuffers.Builder, pos flatbuffers.UOffsetT) {
	builder.PrependStructSlot(0, flatbuffers.UOffsetT(pos), 0)
}
func MonsterAddMana(builder *flatbuffers.Builder, mana int16) {
	builder.PrependInt16Slot(1, mana, 150)
}
func MonsterAddHp(builder *flatbuffers.Builder, hp int16) {
	builder.PrependInt16Slot(2, hp, 100)
}
func MonsterAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(name), 0)
}
func MonsterAddInventory(builder *flatbuffers.Builder, inventory flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(inventory), 0)
}
func MonsterStartInventoryVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MonsterAddColor(builder *flatbuffers.Builder, color Color) {
	builder.PrependByteSlot(6, byte(color), 8)
}
func MonsterAddTestType(builder *flatbuffers.Builder, testType Any) {
	builder.PrependByteSlot(7, byte(testType), 0)
}
func MonsterAddTest(builder *flatbuffers.Builder, test flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(test), 0)
}
func MonsterAddTest4(builder *flatbuffers.Builder, test4 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(test4), 0)
}
func MonsterStartTest4Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 2)
}
func MonsterAddTestarrayofstring(builder *flatbuffers.Builder, testarrayofstring flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(testarrayofstring), 0)
}
func MonsterStartTestarrayofstringVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MonsterAddTestarrayoftables(builder *flatbuffers.Builder, testarrayoftables flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(testarrayoftables), 0)
}
func MonsterStartTestarrayoftablesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MonsterAddEnemy(builder *flatbuffers.Builder, enemy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(enemy), 0)
}
func MonsterAddTestnestedflatbuffer(builder *flatbuffers.Builder, testnestedflatbuffer flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(testnestedflatbuffer), 0)
}
func MonsterStartTestnestedflatbufferVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MonsterAddTestempty(builder *flatbuffers.Builder, testempty flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(testempty), 0)
}
func MonsterAddTestbool(builder *flatbuffers.Builder, testbool bool) {
	builder.PrependBoolSlot(15, testbool, false)
}
func MonsterAddTesthashs32Fnv1(builder *flatbuffers.Builder, testhashs32Fnv1 int32) {
	builder.PrependInt32Slot(16, testhashs32Fnv1, 0)
}
func MonsterAddTesthashu32Fnv1(builder *flatbuffers.Builder, testhashu32Fnv1 uint32) {
	builder.PrependUint32Slot(17, testhashu32Fnv1, 0)
}
func MonsterAddTesthashs64Fnv1(builder *flatbuffers.Builder, testhashs64Fnv1 int64) {
	builder.PrependInt64Slot(18, testhashs64Fnv1, 0)
}
func MonsterAddTesthashu64Fnv1(builder *flatbuffers.Builder, testhashu64Fnv1 uint64) {
	builder.PrependUint64Slot(19, testhashu64Fnv1, 0)
}
func MonsterAddTesthashs32Fnv1a(builder *flatbuffers.Builder, testhashs32Fnv1a int32) {
	builder.PrependInt32Slot(20, testhashs32Fnv1a, 0)
}
func MonsterAddTesthashu32Fnv1a(builder *flatbuffers.Builder, testhashu32Fnv1a uint32) {
	builder.PrependUint32Slot(21, testhashu32Fnv1a, 0)
}
func MonsterAddTesthashs64Fnv1a(builder *flatbuffers.Builder, testhashs64Fnv1a int64) {
	builder.PrependInt64Slot(22, testhashs64Fnv1a, 0)
}
func MonsterAddTesthashu64Fnv1a(builder *flatbuffers.Builder, testhashu64Fnv1a uint64) {
	builder.PrependUint64Slot(23, testhashu64Fnv1a, 0)
}
func MonsterAddTestarrayofbools(builder *flatbuffers.Builder, testarrayofbools flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(testarrayofbools), 0)
}
func MonsterStartTestarrayofboolsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MonsterAddTestf(builder *flatbuffers.Builder, testf float32) {
	builder.PrependFloat32Slot(25, testf, 3.14159)
}
func MonsterAddTestf2(builder *flatbuffers.Builder, testf2 float32) {
	builder.PrependFloat32Slot(26, testf2, 3.0)
}
func MonsterAddTestf3(builder *flatbuffers.Builder, testf3 float32) {
	builder.PrependFloat32Slot(27, testf3, 0.0)
}
func MonsterAddTestarrayofstring2(builder *flatbuffers.Builder, testarrayofstring2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(testarrayofstring2), 0)
}
func MonsterStartTestarrayofstring2Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MonsterAddTestarrayofsortedstruct(builder *flatbuffers.Builder, testarrayofsortedstruct flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(29, flatbuffers.UOffsetT(testarrayofsortedstruct), 0)
}
func MonsterStartTestarrayofsortedstructVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 4)
}
func MonsterAddFlex(builder *flatbuffers.Builder, flex flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(30, flatbuffers.UOffsetT(flex), 0)
}
func MonsterStartFlexVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MonsterAddTest5(builder *flatbuffers.Builder, test5 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(31, flatbuffers.UOffsetT(test5), 0)
}
func MonsterStartTest5Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 2)
}
func MonsterAddVectorOfLongs(builder *flatbuffers.Builder, vectorOfLongs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(32, flatbuffers.UOffsetT(vectorOfLongs), 0)
}
func MonsterStartVectorOfLongsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MonsterAddVectorOfDoubles(builder *flatbuffers.Builder, vectorOfDoubles flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(33, flatbuffers.UOffsetT(vectorOfDoubles), 0)
}
func MonsterStartVectorOfDoublesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MonsterAddParentNamespaceTest(builder *flatbuffers.Builder, parentNamespaceTest flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(34, flatbuffers.UOffsetT(parentNamespaceTest), 0)
}
func MonsterAddVectorOfReferrables(builder *flatbuffers.Builder, vectorOfReferrables flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(35, flatbuffers.UOffsetT(vectorOfReferrables), 0)
}
func MonsterStartVectorOfReferrablesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MonsterAddSingleWeakReference(builder *flatbuffers.Builder, singleWeakReference uint64) {
	builder.PrependUint64Slot(36, singleWeakReference, 0)
}
func MonsterAddVectorOfWeakReferences(builder *flatbuffers.Builder, vectorOfWeakReferences flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(37, flatbuffers.UOffsetT(vectorOfWeakReferences), 0)
}
func MonsterStartVectorOfWeakReferencesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MonsterAddVectorOfStrongReferrables(builder *flatbuffers.Builder, vectorOfStrongReferrables flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(38, flatbuffers.UOffsetT(vectorOfStrongReferrables), 0)
}
func MonsterStartVectorOfStrongReferrablesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MonsterAddCoOwningReference(builder *flatbuffers.Builder, coOwningReference uint64) {
	builder.PrependUint64Slot(39, coOwningReference, 0)
}
func MonsterAddVectorOfCoOwningReferences(builder *flatbuffers.Builder, vectorOfCoOwningReferences flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(40, flatbuffers.UOffsetT(vectorOfCoOwningReferences), 0)
}
func MonsterStartVectorOfCoOwningReferencesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MonsterAddNonOwningReference(builder *flatbuffers.Builder, nonOwningReference uint64) {
	builder.PrependUint64Slot(41, nonOwningReference, 0)
}
func MonsterAddVectorOfNonOwningReferences(builder *flatbuffers.Builder, vectorOfNonOwningReferences flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(42, flatbuffers.UOffsetT(vectorOfNonOwningReferences), 0)
}
func MonsterStartVectorOfNonOwningReferencesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func MonsterAddAnyUniqueType(builder *flatbuffers.Builder, anyUniqueType AnyUniqueAliases) {
	builder.PrependByteSlot(43, byte(anyUniqueType), 0)
}
func MonsterAddAnyUnique(builder *flatbuffers.Builder, anyUnique flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(44, flatbuffers.UOffsetT(anyUnique), 0)
}
func MonsterAddAnyAmbiguousType(builder *flatbuffers.Builder, anyAmbiguousType AnyAmbiguousAliases) {
	builder.PrependByteSlot(45, byte(anyAmbiguousType), 0)
}
func MonsterAddAnyAmbiguous(builder *flatbuffers.Builder, anyAmbiguous flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(46, flatbuffers.UOffsetT(anyAmbiguous), 0)
}
func MonsterAddVectorOfEnums(builder *flatbuffers.Builder, vectorOfEnums flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(47, flatbuffers.UOffsetT(vectorOfEnums), 0)
}
func MonsterStartVectorOfEnumsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MonsterAddSignedEnum(builder *flatbuffers.Builder, signedEnum Race) {
	builder.PrependInt8Slot(48, int8(signedEnum), -1)
}
func MonsterAddTestrequirednestedflatbuffer(builder *flatbuffers.Builder, testrequirednestedflatbuffer flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(49, flatbuffers.UOffsetT(testrequirednestedflatbuffer), 0)
}
func MonsterStartTestrequirednestedflatbufferVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func MonsterAddScalarKeySortedTables(builder *flatbuffers.Builder, scalarKeySortedTables flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(50, flatbuffers.UOffsetT(scalarKeySortedTables), 0)
}
func MonsterStartScalarKeySortedTablesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MonsterAddNativeInline(builder *flatbuffers.Builder, nativeInline flatbuffers.UOffsetT) {
	builder.PrependStructSlot(51, flatbuffers.UOffsetT(nativeInline), 0)
}
func MonsterAddLongEnumNonEnumDefault(builder *flatbuffers.Builder, longEnumNonEnumDefault LongEnum) {
	builder.PrependUint64Slot(52, uint64(longEnumNonEnumDefault), 0)
}
func MonsterAddLongEnumNormalDefault(builder *flatbuffers.Builder, longEnumNormalDefault LongEnum) {
	builder.PrependUint64Slot(53, uint64(longEnumNormalDefault), 2)
}
func MonsterAddNanDefault(builder *flatbuffers.Builder, nanDefault float32) {
	builder.PrependFloat32Slot(54, nanDefault, float32(math.NaN()))
}
func MonsterAddInfDefault(builder *flatbuffers.Builder, infDefault float32) {
	builder.PrependFloat32Slot(55, infDefault, float32(math.Inf(1)))
}
func MonsterAddPositiveInfDefault(builder *flatbuffers.Builder, positiveInfDefault float32) {
	builder.PrependFloat32Slot(56, positiveInfDefault, float32(math.Inf(1)))
}
func MonsterAddInfinityDefault(builder *flatbuffers.Builder, infinityDefault float32) {
	builder.PrependFloat32Slot(57, infinityDefault, float32(math.Inf(1)))
}
func MonsterAddPositiveInfinityDefault(builder *flatbuffers.Builder, positiveInfinityDefault float32) {
	builder.PrependFloat32Slot(58, positiveInfinityDefault, float32(math.Inf(1)))
}
func MonsterAddNegativeInfDefault(builder *flatbuffers.Builder, negativeInfDefault float32) {
	builder.PrependFloat32Slot(59, negativeInfDefault, float32(math.Inf(-1)))
}
func MonsterAddNegativeInfinityDefault(builder *flatbuffers.Builder, negativeInfinityDefault float32) {
	builder.PrependFloat32Slot(60, negativeInfinityDefault, float32(math.Inf(-1)))
}
func MonsterAddDoubleInfDefault(builder *flatbuffers.Builder, doubleInfDefault float64) {
	builder.PrependFloat64Slot(61, doubleInfDefault, float64(math.Inf(1)))
}
func MonsterEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Enum, EnumT } from '../reflection/Enum.js';
import { Object_, Object_T } from '../reflection/Object.js';
import { SchemaFile, SchemaFileT } from '../reflection/SchemaFile.js';
import { Service, ServiceT } from '../reflection/Service.js';


export class Schema implements flatbuffers.IUnpackableObject<SchemaT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Schema {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsSchema(bb:flatbuffers.ByteBuffer, obj?:Schema):Schema {
  return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsSchema(bb:flatbuffers.ByteBuffer, obj?:Schema):Schema {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('BFBS');
}

objects(index: number, obj?:Object_):Object_|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new Object_()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

objects_Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

enums(index: number, obj?:Enum):Enum|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Enum()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

enums_Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

file_ident():string|null
file_ident(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
file_ident(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

file_ext():string|null
file_ext(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
file_ext(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

root_table(obj?:Object_):Object_|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new Object_()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

services(index: number, obj?:Service):Service|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new Service()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

services_Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

advanced_features():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');
}

mutate_advanced_features(value:bigint):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 16);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint64(this.bb_pos + offset, value);
  return true;
}

/**
 * All the files used in this compilation. Files are relative to where
 * flatc was invoked.
 */
fbs_files(index: number, obj?:SchemaFile):SchemaFile|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? (obj || new SchemaFile()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

fbs_files_Length():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static getFullyQualifiedName():string {
  return 'reflection.Schema';
}

static startSchema(builder:flatbuffers.Builder) {
  builder.startObject(8);
}

static add_objects(builder:flatbuffers.Builder, objectsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, objectsOffset, 0);
}

static create_objects_Vector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static start_objects_Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static add_enums(builder:flatbuffers.Builder, enumsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, enumsOffset, 0);
}

static create_enums_Vector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static start_enums_Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static add_file_ident(builder:flatbuffers.Builder, file_identOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, file_identOffset, 0);
}

static add_file_ext(builder:flatbuffers.Builder, file_extOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, file_extOffset, 0);
}

static add_root_table(builder:flatbuffers.Builder, root_tableOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, root_tableOffset, 0);
}

static add_services(builder:flatbuffers.Builder, servicesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, servicesOffset, 0);
}

static create_services_Vector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static start_services_Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static add_advanced_features(builder:flatbuffers.Builder, advanced_features:bigint) {
  builder.addFieldInt64(6, advanced_features, BigInt('0'));
}

static add_fbs_files(builder:flatbuffers.Builder, fbs_filesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, fbs_filesOffset, 0);
}

static create_fbs_files_Vector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static start_fbs_files_Vector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endSchema(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // objects
  builder.requiredField(offset, 6) // enums
  return offset;
}

static finishSchemaBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'BFBS');
}

static finishSizePrefixedSchemaBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'BFBS', true);
}


unpack(): SchemaT {
  return new SchemaT(
    this.bb!.createObjList<Object_, Object_T>(this.objects.bind(this), this.objects_Length()),
    this.bb!.createObjList<Enum, EnumT>(this.enums.bind(this), this.enums_Length()),
    this.file_ident(),
    this.file_ext(),
    (this.root_table() !== null ? this.root_table()!.unpack() : null),
    this.bb!.createObjList<Service, ServiceT>(this.services.bind(this), this.services_Length()),
    this.advanced_features(),
    this.bb!.createObjList<SchemaFile, SchemaFileT>(this.fbs_files.bind(this), this.fbs_files_Length())
  );
}


unpackTo(_o: SchemaT): void {
  _o.objects = this.bb!.createObjList<Object_, Object_T>(this.objects.bind(this), this.objects_Length());
  _o.enums = this.bb!.createObjList<Enum, EnumT>(this.enums.bind(this), this.enums_Length());
  _o.file_ident = this.file_ident();
  _o.file_ext = this.file_ext();
  _o.root_table = (this.root_table() !== null ? this.root_table()!.unpack() : null);
  _o.services = this.bb!.createObjList<Service, ServiceT>(this.services.bind(this), this.services_Length());
  _o.advanced_features = this.advanced_features();
  _o.fbs_files = this.bb!.createObjList<SchemaFile, SchemaFileT>(this.fbs_files.bind(this), this.fbs_files_Length());
}
}

export class SchemaT implements flatbuffers.IGeneratedObject {
constructor(
  public objects: (Object_T)[] = [],
  public enums: (EnumT)[] = [],
  public file_ident: string|Uint8Array|null = null,
  public file_ext: string|Uint8Array|null = null,
  public root_table: Object_T|null = null,
  public services: (ServiceT)[] = [],
  public advanced_features: bigint = BigInt('0'),
  public fbs_files: (SchemaFileT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const objects = Schema.create_objects_Vector(builder, builder.createObjectOffsetList(this.objects));
  const enums = Schema.create_enums_Vector(builder, builder.createObjectOffsetList(this.enums));
  const file_ident = (this.file_ident !== null ? builder.createString(this.file_ident!) : 0);
  const file_ext = (this.file_ext !== null ? builder.createString(this.file_ext!) : 0);
  const root_table = (this.root_table !== null ? this.root_table!.pack(builder) : 0);
  const services = Schema.create_services_Vector(builder, builder.createObjectOffsetList(this.services));
  const fbs_files = Schema.create_fbs_files_Vector(builder, builder.createObjectOffsetList(this.fbs_files));

  Schema.startSchema(builder);
  Schema.add_objects(builder, objects);
  Schema.add_enums(builder, enums);
  Schema.add_file_ident(builder, file_ident);
  Schema.add_file_ext(builder, file_ext);
  Schema.add_root_table(builder, root_table);
  Schema.add_services(builder, services);
  Schema.add_advanced_features(builder, this.advanced_features);
  Schema.add_fbs_files(builder, fbs_files);

  return Schema.endSchema(builder);
}
}

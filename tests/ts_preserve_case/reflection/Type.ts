// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { BaseType } from '../reflection/BaseType.js';


export class Type implements flatbuffers.IUnpackableObject<TypeT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Type {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsType(bb:flatbuffers.ByteBuffer, obj?:Type):Type {
  return (obj || new Type()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsType(bb:flatbuffers.ByteBuffer, obj?:Type):Type {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Type()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

base_type():BaseType {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : BaseType.None;
}

mutate_base_type(value:BaseType):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, value);
  return true;
}

element():BaseType {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : BaseType.None;
}

mutate_element(value:BaseType):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 6);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt8(this.bb_pos + offset, value);
  return true;
}

index():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : -1;
}

mutate_index(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
}

fixed_length():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

mutate_fixed_length(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint16(this.bb_pos + offset, value);
  return true;
}

/**
 * The size (octets) of the `base_type` field.
 */
base_size():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 4;
}

mutate_base_size(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

/**
 * The size (octets) of the `element` field, if present.
 */
element_size():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

mutate_element_size(value:number):boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeUint32(this.bb_pos + offset, value);
  return true;
}

static getFullyQualifiedName():string {
  return 'reflection.Type';
}

static startType(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static add_base_type(builder:flatbuffers.Builder, base_type:BaseType) {
  builder.addFieldInt8(0, base_type, BaseType.None);
}

static add_element(builder:flatbuffers.Builder, element:BaseType) {
  builder.addFieldInt8(1, element, BaseType.None);
}

static add_index(builder:flatbuffers.Builder, index:number) {
  builder.addFieldInt32(2, index, -1);
}

static add_fixed_length(builder:flatbuffers.Builder, fixed_length:number) {
  builder.addFieldInt16(3, fixed_length, 0);
}

static add_base_size(builder:flatbuffers.Builder, base_size:number) {
  builder.addFieldInt32(4, base_size, 4);
}

static add_element_size(builder:flatbuffers.Builder, element_size:number) {
  builder.addFieldInt32(5, element_size, 0);
}

static endType(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createType(builder:flatbuffers.Builder, base_type:BaseType, element:BaseType, index:number, fixed_length:number, base_size:number, element_size:number):flatbuffers.Offset {
  Type.startType(builder);
  Type.add_base_type(builder, base_type);
  Type.add_element(builder, element);
  Type.add_index(builder, index);
  Type.add_fixed_length(builder, fixed_length);
  Type.add_base_size(builder, base_size);
  Type.add_element_size(builder, element_size);
  return Type.endType(builder);
}

unpack(): TypeT {
  return new TypeT(
    this.base_type(),
    this.element(),
    this.index(),
    this.fixed_length(),
    this.base_size(),
    this.element_size()
  );
}


unpackTo(_o: TypeT): void {
  _o.base_type = this.base_type();
  _o.element = this.element();
  _o.index = this.index();
  _o.fixed_length = this.fixed_length();
  _o.base_size = this.base_size();
  _o.element_size = this.element_size();
}
}

export class TypeT implements flatbuffers.IGeneratedObject {
constructor(
  public base_type: BaseType = BaseType.None,
  public element: BaseType = BaseType.None,
  public index: number = -1,
  public fixed_length: number = 0,
  public base_size: number = 4,
  public element_size: number = 0
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return Type.createType(builder,
    this.base_type,
    this.element,
    this.index,
    this.fixed_length,
    this.base_size,
    this.element_size
  );
}
}

// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { Character, unionToCharacter, unionListToCharacter } from './Character.js';
export class Movie {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMovie(bb, obj) {
        return (obj || new Movie()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMovie(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Movie()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('MOVI');
    }
    main_character_type() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : Character.NONE;
    }
    main_character(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union_with_string(obj, this.bb_pos + offset) : null;
    }
    characters_type(index) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : null;
    }
    characters_type_Length() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    characters_type_Array() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    characters(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union_with_string(obj, this.bb.__vector(this.bb_pos + offset) + index * 4) : null;
    }
    characters_Length() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static getFullyQualifiedName() {
        return 'Movie';
    }
    static startMovie(builder) {
        builder.startObject(4);
    }
    static add_main_character_type(builder, main_character_type) {
        builder.addFieldInt8(0, main_character_type, Character.NONE);
    }
    static add_main_character(builder, main_characterOffset) {
        builder.addFieldOffset(1, main_characterOffset, 0);
    }
    static add_characters_type(builder, characters_typeOffset) {
        builder.addFieldOffset(2, characters_typeOffset, 0);
    }
    static create_characters_type_Vector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static start_characters_type_Vector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static add_characters(builder, charactersOffset) {
        builder.addFieldOffset(3, charactersOffset, 0);
    }
    static create_characters_Vector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static start_characters_Vector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMovie(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMovieBuffer(builder, offset) {
        builder.finish(offset, 'MOVI');
    }
    static finishSizePrefixedMovieBuffer(builder, offset) {
        builder.finish(offset, 'MOVI', true);
    }
    static createMovie(builder, main_character_type, main_characterOffset, characters_typeOffset, charactersOffset) {
        Movie.startMovie(builder);
        Movie.add_main_character_type(builder, main_character_type);
        Movie.add_main_character(builder, main_characterOffset);
        Movie.add_characters_type(builder, characters_typeOffset);
        Movie.add_characters(builder, charactersOffset);
        return Movie.endMovie(builder);
    }
    unpack() {
        return new MovieT(this.main_character_type(), (() => {
            const temp = unionToCharacter(this.main_character_type(), this.main_character.bind(this));
            if (temp === null) {
                return null;
            }
            if (typeof temp === 'string') {
                return temp;
            }
            return temp.unpack();
        })(), this.bb.createScalarList(this.characters_type.bind(this), this.characters_type_Length()), (() => {
            const ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.characters_type_Length(); ++targetEnumIndex) {
                const targetEnum = this.characters_type(targetEnumIndex);
                if (targetEnum === null || Character[targetEnum] === 'NONE') {
                    continue;
                }
                const temp = unionListToCharacter(targetEnum, this.characters.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                if (typeof temp === 'string') {
                    ret.push(temp);
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })());
    }
    unpackTo(_o) {
        _o.main_character_type = this.main_character_type();
        _o.main_character = (() => {
            const temp = unionToCharacter(this.main_character_type(), this.main_character.bind(this));
            if (temp === null) {
                return null;
            }
            if (typeof temp === 'string') {
                return temp;
            }
            return temp.unpack();
        })();
        _o.characters_type = this.bb.createScalarList(this.characters_type.bind(this), this.characters_type_Length());
        _o.characters = (() => {
            const ret = [];
            for (let targetEnumIndex = 0; targetEnumIndex < this.characters_type_Length(); ++targetEnumIndex) {
                const targetEnum = this.characters_type(targetEnumIndex);
                if (targetEnum === null || Character[targetEnum] === 'NONE') {
                    continue;
                }
                const temp = unionListToCharacter(targetEnum, this.characters.bind(this), targetEnumIndex);
                if (temp === null) {
                    continue;
                }
                if (typeof temp === 'string') {
                    ret.push(temp);
                    continue;
                }
                ret.push(temp.unpack());
            }
            return ret;
        })();
    }
}
export class MovieT {
    constructor(main_character_type = Character.NONE, main_character = null, characters_type = [], characters = []) {
        this.main_character_type = main_character_type;
        this.main_character = main_character;
        this.characters_type = characters_type;
        this.characters = characters;
    }
    pack(builder) {
        const main_character = builder.createObjectOffset(this.main_character);
        const characters_type = Movie.create_characters_type_Vector(builder, this.characters_type);
        const characters = Movie.create_characters_Vector(builder, builder.createObjectOffsetList(this.characters));
        return Movie.createMovie(builder, this.main_character_type, main_character, characters_type, characters);
    }
}

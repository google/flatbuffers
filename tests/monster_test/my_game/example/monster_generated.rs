// automatically generated by the FlatBuffers compiler, do not modify
extern crate flatbuffers;
use std::mem;
use std::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MonsterOffset {}
#[derive(Copy, Clone, PartialEq)]

/// an example documentation comment: "monster object"
pub struct Monster<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Monster<'a> {
  type Inner = Monster<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Monster<'a> {
  pub const VT_POS: flatbuffers::VOffsetT = 4;
  pub const VT_MANA: flatbuffers::VOffsetT = 6;
  pub const VT_HP: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_INVENTORY: flatbuffers::VOffsetT = 14;
  pub const VT_COLOR: flatbuffers::VOffsetT = 16;
  pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 18;
  pub const VT_TEST: flatbuffers::VOffsetT = 20;
  pub const VT_TEST4: flatbuffers::VOffsetT = 22;
  pub const VT_TESTARRAYOFSTRING: flatbuffers::VOffsetT = 24;
  pub const VT_TESTARRAYOFTABLES: flatbuffers::VOffsetT = 26;
  pub const VT_ENEMY: flatbuffers::VOffsetT = 28;
  pub const VT_TESTNESTEDFLATBUFFER: flatbuffers::VOffsetT = 30;
  pub const VT_TESTEMPTY: flatbuffers::VOffsetT = 32;
  pub const VT_TESTBOOL: flatbuffers::VOffsetT = 34;
  pub const VT_TESTHASHS32_FNV1: flatbuffers::VOffsetT = 36;
  pub const VT_TESTHASHU32_FNV1: flatbuffers::VOffsetT = 38;
  pub const VT_TESTHASHS64_FNV1: flatbuffers::VOffsetT = 40;
  pub const VT_TESTHASHU64_FNV1: flatbuffers::VOffsetT = 42;
  pub const VT_TESTHASHS32_FNV1A: flatbuffers::VOffsetT = 44;
  pub const VT_TESTHASHU32_FNV1A: flatbuffers::VOffsetT = 46;
  pub const VT_TESTHASHS64_FNV1A: flatbuffers::VOffsetT = 48;
  pub const VT_TESTHASHU64_FNV1A: flatbuffers::VOffsetT = 50;
  pub const VT_TESTARRAYOFBOOLS: flatbuffers::VOffsetT = 52;
  pub const VT_TESTF: flatbuffers::VOffsetT = 54;
  pub const VT_TESTF2: flatbuffers::VOffsetT = 56;
  pub const VT_TESTF3: flatbuffers::VOffsetT = 58;
  pub const VT_TESTARRAYOFSTRING2: flatbuffers::VOffsetT = 60;
  pub const VT_TESTARRAYOFSORTEDSTRUCT: flatbuffers::VOffsetT = 62;
  pub const VT_FLEX: flatbuffers::VOffsetT = 64;
  pub const VT_TEST5: flatbuffers::VOffsetT = 66;
  pub const VT_VECTOR_OF_LONGS: flatbuffers::VOffsetT = 68;
  pub const VT_VECTOR_OF_DOUBLES: flatbuffers::VOffsetT = 70;
  pub const VT_PARENT_NAMESPACE_TEST: flatbuffers::VOffsetT = 72;
  pub const VT_VECTOR_OF_REFERRABLES: flatbuffers::VOffsetT = 74;
  pub const VT_SINGLE_WEAK_REFERENCE: flatbuffers::VOffsetT = 76;
  pub const VT_VECTOR_OF_WEAK_REFERENCES: flatbuffers::VOffsetT = 78;
  pub const VT_VECTOR_OF_STRONG_REFERRABLES: flatbuffers::VOffsetT = 80;
  pub const VT_CO_OWNING_REFERENCE: flatbuffers::VOffsetT = 82;
  pub const VT_VECTOR_OF_CO_OWNING_REFERENCES: flatbuffers::VOffsetT = 84;
  pub const VT_NON_OWNING_REFERENCE: flatbuffers::VOffsetT = 86;
  pub const VT_VECTOR_OF_NON_OWNING_REFERENCES: flatbuffers::VOffsetT = 88;
  pub const VT_ANY_UNIQUE_TYPE: flatbuffers::VOffsetT = 90;
  pub const VT_ANY_UNIQUE: flatbuffers::VOffsetT = 92;
  pub const VT_ANY_AMBIGUOUS_TYPE: flatbuffers::VOffsetT = 94;
  pub const VT_ANY_AMBIGUOUS: flatbuffers::VOffsetT = 96;
  pub const VT_VECTOR_OF_ENUMS: flatbuffers::VOffsetT = 98;
  pub const VT_SIGNED_ENUM: flatbuffers::VOffsetT = 100;
  pub const VT_TESTREQUIREDNESTEDFLATBUFFER: flatbuffers::VOffsetT = 102;
  pub const VT_SCALAR_KEY_SORTED_TABLES: flatbuffers::VOffsetT = 104;

  pub const fn get_fully_qualified_name() -> &'static str {
    "MyGame.Example.Monster"
  }

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Monster { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MonsterArgs<'args>
  ) -> flatbuffers::WIPOffset<Monster<'bldr>> {
    let mut builder = MonsterBuilder::new(_fbb);
    builder.add_non_owning_reference(args.non_owning_reference);
    builder.add_co_owning_reference(args.co_owning_reference);
    builder.add_single_weak_reference(args.single_weak_reference);
    builder.add_testhashu64_fnv1a(args.testhashu64_fnv1a);
    builder.add_testhashs64_fnv1a(args.testhashs64_fnv1a);
    builder.add_testhashu64_fnv1(args.testhashu64_fnv1);
    builder.add_testhashs64_fnv1(args.testhashs64_fnv1);
    if let Some(x) = args.scalar_key_sorted_tables { builder.add_scalar_key_sorted_tables(x); }
    if let Some(x) = args.testrequirednestedflatbuffer { builder.add_testrequirednestedflatbuffer(x); }
    if let Some(x) = args.vector_of_enums { builder.add_vector_of_enums(x); }
    if let Some(x) = args.any_ambiguous { builder.add_any_ambiguous(x); }
    if let Some(x) = args.any_unique { builder.add_any_unique(x); }
    if let Some(x) = args.vector_of_non_owning_references { builder.add_vector_of_non_owning_references(x); }
    if let Some(x) = args.vector_of_co_owning_references { builder.add_vector_of_co_owning_references(x); }
    if let Some(x) = args.vector_of_strong_referrables { builder.add_vector_of_strong_referrables(x); }
    if let Some(x) = args.vector_of_weak_references { builder.add_vector_of_weak_references(x); }
    if let Some(x) = args.vector_of_referrables { builder.add_vector_of_referrables(x); }
    if let Some(x) = args.parent_namespace_test { builder.add_parent_namespace_test(x); }
    if let Some(x) = args.vector_of_doubles { builder.add_vector_of_doubles(x); }
    if let Some(x) = args.vector_of_longs { builder.add_vector_of_longs(x); }
    if let Some(x) = args.test5 { builder.add_test5(x); }
    if let Some(x) = args.flex { builder.add_flex(x); }
    if let Some(x) = args.testarrayofsortedstruct { builder.add_testarrayofsortedstruct(x); }
    if let Some(x) = args.testarrayofstring2 { builder.add_testarrayofstring2(x); }
    builder.add_testf3(args.testf3);
    builder.add_testf2(args.testf2);
    builder.add_testf(args.testf);
    if let Some(x) = args.testarrayofbools { builder.add_testarrayofbools(x); }
    builder.add_testhashu32_fnv1a(args.testhashu32_fnv1a);
    builder.add_testhashs32_fnv1a(args.testhashs32_fnv1a);
    builder.add_testhashu32_fnv1(args.testhashu32_fnv1);
    builder.add_testhashs32_fnv1(args.testhashs32_fnv1);
    if let Some(x) = args.testempty { builder.add_testempty(x); }
    if let Some(x) = args.testnestedflatbuffer { builder.add_testnestedflatbuffer(x); }
    if let Some(x) = args.enemy { builder.add_enemy(x); }
    if let Some(x) = args.testarrayoftables { builder.add_testarrayoftables(x); }
    if let Some(x) = args.testarrayofstring { builder.add_testarrayofstring(x); }
    if let Some(x) = args.test4 { builder.add_test4(x); }
    if let Some(x) = args.test { builder.add_test(x); }
    if let Some(x) = args.inventory { builder.add_inventory(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.pos { builder.add_pos(x); }
    builder.add_hp(args.hp);
    builder.add_mana(args.mana);
    builder.add_signed_enum(args.signed_enum);
    builder.add_any_ambiguous_type(args.any_ambiguous_type);
    builder.add_any_unique_type(args.any_unique_type);
    builder.add_testbool(args.testbool);
    builder.add_test_type(args.test_type);
    builder.add_color(args.color);
    builder.finish()
  }

  pub fn unpack(&self) -> MonsterT {
    let pos = self.pos().map(|x| {
      x.unpack()
    });
    let mana = self.mana();
    let hp = self.hp();
    let name = {
      let x = self.name();
      x.to_string()
    };
    let inventory = self.inventory().map(|x| {
      x.to_vec()
    });
    let color = self.color();
    let test = match self.test_type() {
      Any::NONE => AnyT::NONE,
      Any::Monster => AnyT::Monster(Box::new(
        self.test_as_monster()
            .expect("Invalid union table, expected `Any::Monster`.")
            .unpack()
      )),
      Any::TestSimpleTableWithEnum => AnyT::TestSimpleTableWithEnum(Box::new(
        self.test_as_test_simple_table_with_enum()
            .expect("Invalid union table, expected `Any::TestSimpleTableWithEnum`.")
            .unpack()
      )),
      Any::MyGame_Example2_Monster => AnyT::MyGameExample2Monster(Box::new(
        self.test_as_my_game_example_2_monster()
            .expect("Invalid union table, expected `Any::MyGame_Example2_Monster`.")
            .unpack()
      )),
      _ => AnyT::NONE,
    };
    let test4 = self.test4().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let testarrayofstring = self.testarrayofstring().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let testarrayoftables = self.testarrayoftables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let enemy = self.enemy().map(|x| {
      Box::new(x.unpack())
    });
    let testnestedflatbuffer = self.testnestedflatbuffer().map(|x| {
      x.to_vec()
    });
    let testempty = self.testempty().map(|x| {
      Box::new(x.unpack())
    });
    let testbool = self.testbool();
    let testhashs32_fnv1 = self.testhashs32_fnv1();
    let testhashu32_fnv1 = self.testhashu32_fnv1();
    let testhashs64_fnv1 = self.testhashs64_fnv1();
    let testhashu64_fnv1 = self.testhashu64_fnv1();
    let testhashs32_fnv1a = self.testhashs32_fnv1a();
    let testhashu32_fnv1a = self.testhashu32_fnv1a();
    let testhashs64_fnv1a = self.testhashs64_fnv1a();
    let testhashu64_fnv1a = self.testhashu64_fnv1a();
    let testarrayofbools = self.testarrayofbools().map(|x| {
      x.to_vec()
    });
    let testf = self.testf();
    let testf2 = self.testf2();
    let testf3 = self.testf3();
    let testarrayofstring2 = self.testarrayofstring2().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let testarrayofsortedstruct = self.testarrayofsortedstruct().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let flex = self.flex().map(|x| {
      x.to_vec()
    });
    let test5 = self.test5().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let vector_of_longs = self.vector_of_longs().map(|x| {
      x.into_iter().collect()
    });
    let vector_of_doubles = self.vector_of_doubles().map(|x| {
      x.into_iter().collect()
    });
    let parent_namespace_test = self.parent_namespace_test().map(|x| {
      Box::new(x.unpack())
    });
    let vector_of_referrables = self.vector_of_referrables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let single_weak_reference = self.single_weak_reference();
    let vector_of_weak_references = self.vector_of_weak_references().map(|x| {
      x.into_iter().collect()
    });
    let vector_of_strong_referrables = self.vector_of_strong_referrables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let co_owning_reference = self.co_owning_reference();
    let vector_of_co_owning_references = self.vector_of_co_owning_references().map(|x| {
      x.into_iter().collect()
    });
    let non_owning_reference = self.non_owning_reference();
    let vector_of_non_owning_references = self.vector_of_non_owning_references().map(|x| {
      x.into_iter().collect()
    });
    let any_unique = match self.any_unique_type() {
      AnyUniqueAliases::NONE => AnyUniqueAliasesT::NONE,
      AnyUniqueAliases::M => AnyUniqueAliasesT::M(Box::new(
        self.any_unique_as_m()
            .expect("Invalid union table, expected `AnyUniqueAliases::M`.")
            .unpack()
      )),
      AnyUniqueAliases::TS => AnyUniqueAliasesT::TS(Box::new(
        self.any_unique_as_ts()
            .expect("Invalid union table, expected `AnyUniqueAliases::TS`.")
            .unpack()
      )),
      AnyUniqueAliases::M2 => AnyUniqueAliasesT::M2(Box::new(
        self.any_unique_as_m2()
            .expect("Invalid union table, expected `AnyUniqueAliases::M2`.")
            .unpack()
      )),
      _ => AnyUniqueAliasesT::NONE,
    };
    let any_ambiguous = match self.any_ambiguous_type() {
      AnyAmbiguousAliases::NONE => AnyAmbiguousAliasesT::NONE,
      AnyAmbiguousAliases::M1 => AnyAmbiguousAliasesT::M1(Box::new(
        self.any_ambiguous_as_m1()
            .expect("Invalid union table, expected `AnyAmbiguousAliases::M1`.")
            .unpack()
      )),
      AnyAmbiguousAliases::M2 => AnyAmbiguousAliasesT::M2(Box::new(
        self.any_ambiguous_as_m2()
            .expect("Invalid union table, expected `AnyAmbiguousAliases::M2`.")
            .unpack()
      )),
      AnyAmbiguousAliases::M3 => AnyAmbiguousAliasesT::M3(Box::new(
        self.any_ambiguous_as_m3()
            .expect("Invalid union table, expected `AnyAmbiguousAliases::M3`.")
            .unpack()
      )),
      _ => AnyAmbiguousAliasesT::NONE,
    };
    let vector_of_enums = self.vector_of_enums().map(|x| {
      x.into_iter().collect()
    });
    let signed_enum = self.signed_enum();
    let testrequirednestedflatbuffer = self.testrequirednestedflatbuffer().map(|x| {
      x.to_vec()
    });
    let scalar_key_sorted_tables = self.scalar_key_sorted_tables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MonsterT {
      pos,
      mana,
      hp,
      name,
      inventory,
      color,
      test,
      test4,
      testarrayofstring,
      testarrayoftables,
      enemy,
      testnestedflatbuffer,
      testempty,
      testbool,
      testhashs32_fnv1,
      testhashu32_fnv1,
      testhashs64_fnv1,
      testhashu64_fnv1,
      testhashs32_fnv1a,
      testhashu32_fnv1a,
      testhashs64_fnv1a,
      testhashu64_fnv1a,
      testarrayofbools,
      testf,
      testf2,
      testf3,
      testarrayofstring2,
      testarrayofsortedstruct,
      flex,
      test5,
      vector_of_longs,
      vector_of_doubles,
      parent_namespace_test,
      vector_of_referrables,
      single_weak_reference,
      vector_of_weak_references,
      vector_of_strong_referrables,
      co_owning_reference,
      vector_of_co_owning_references,
      non_owning_reference,
      vector_of_non_owning_references,
      any_unique,
      any_ambiguous,
      vector_of_enums,
      signed_enum,
      testrequirednestedflatbuffer,
      scalar_key_sorted_tables,
    }
  }

  #[inline]
  pub fn pos(&self) -> Option<&'a Vec3> {
    self._tab.get::<Vec3>(Monster::VT_POS, None)
  }
  #[inline]
  pub fn mana(&self) -> i16 {
    self._tab.get::<i16>(Monster::VT_MANA, Some(150)).unwrap()
  }
  #[inline]
  pub fn hp(&self) -> i16 {
    self._tab.get::<i16>(Monster::VT_HP, Some(100)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Monster) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn inventory(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_INVENTORY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn color(&self) -> Color {
    self._tab.get::<Color>(Monster::VT_COLOR, Some(Color::Blue)).unwrap()
  }
  #[inline]
  pub fn test_type(&self) -> Any {
    self._tab.get::<Any>(Monster::VT_TEST_TYPE, Some(Any::NONE)).unwrap()
  }
  #[inline]
  pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_TEST, None)
  }
  #[inline]
  pub fn test4(&self) -> Option<&'a [Test]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Test>>>(Monster::VT_TEST4, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn testarrayofstring(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Monster::VT_TESTARRAYOFSTRING, None)
  }
  /// an example documentation comment: this will end up in the generated code
  /// multiline too
  #[inline]
  pub fn testarrayoftables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster>>>>(Monster::VT_TESTARRAYOFTABLES, None)
  }
  #[inline]
  pub fn enemy(&self) -> Option<Monster<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Monster>>(Monster::VT_ENEMY, None)
  }
  #[inline]
  pub fn testnestedflatbuffer(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_TESTNESTEDFLATBUFFER, None).map(|v| v.safe_slice())
  }
  pub fn testnestedflatbuffer_nested_flatbuffer(&'a self) -> Option<Monster<'a>> {
    self.testnestedflatbuffer().map(|data| {
      use flatbuffers::Follow;
      <flatbuffers::ForwardsUOffset<Monster<'a>>>::follow(data, 0)
    })
  }
  #[inline]
  pub fn testempty(&self) -> Option<Stat<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Stat>>(Monster::VT_TESTEMPTY, None)
  }
  #[inline]
  pub fn testbool(&self) -> bool {
    self._tab.get::<bool>(Monster::VT_TESTBOOL, Some(false)).unwrap()
  }
  #[inline]
  pub fn testhashs32_fnv1(&self) -> i32 {
    self._tab.get::<i32>(Monster::VT_TESTHASHS32_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu32_fnv1(&self) -> u32 {
    self._tab.get::<u32>(Monster::VT_TESTHASHU32_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashs64_fnv1(&self) -> i64 {
    self._tab.get::<i64>(Monster::VT_TESTHASHS64_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu64_fnv1(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_TESTHASHU64_FNV1, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashs32_fnv1a(&self) -> i32 {
    self._tab.get::<i32>(Monster::VT_TESTHASHS32_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu32_fnv1a(&self) -> u32 {
    self._tab.get::<u32>(Monster::VT_TESTHASHU32_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashs64_fnv1a(&self) -> i64 {
    self._tab.get::<i64>(Monster::VT_TESTHASHS64_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testhashu64_fnv1a(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_TESTHASHU64_FNV1A, Some(0)).unwrap()
  }
  #[inline]
  pub fn testarrayofbools(&self) -> Option<&'a [bool]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(Monster::VT_TESTARRAYOFBOOLS, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn testf(&self) -> f32 {
    self._tab.get::<f32>(Monster::VT_TESTF, Some(3.14159)).unwrap()
  }
  #[inline]
  pub fn testf2(&self) -> f32 {
    self._tab.get::<f32>(Monster::VT_TESTF2, Some(3.0)).unwrap()
  }
  #[inline]
  pub fn testf3(&self) -> f32 {
    self._tab.get::<f32>(Monster::VT_TESTF3, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn testarrayofstring2(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Monster::VT_TESTARRAYOFSTRING2, None)
  }
  #[inline]
  pub fn testarrayofsortedstruct(&self) -> Option<&'a [Ability]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Ability>>>(Monster::VT_TESTARRAYOFSORTEDSTRUCT, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn flex(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_FLEX, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn test5(&self) -> Option<&'a [Test]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Test>>>(Monster::VT_TEST5, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn vector_of_longs(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Monster::VT_VECTOR_OF_LONGS, None)
  }
  #[inline]
  pub fn vector_of_doubles(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Monster::VT_VECTOR_OF_DOUBLES, None)
  }
  #[inline]
  pub fn parent_namespace_test(&self) -> Option<super::InParentNamespace<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::InParentNamespace>>(Monster::VT_PARENT_NAMESPACE_TEST, None)
  }
  #[inline]
  pub fn vector_of_referrables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable>>>>(Monster::VT_VECTOR_OF_REFERRABLES, None)
  }
  #[inline]
  pub fn single_weak_reference(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_SINGLE_WEAK_REFERENCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn vector_of_weak_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_WEAK_REFERENCES, None)
  }
  #[inline]
  pub fn vector_of_strong_referrables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable>>>>(Monster::VT_VECTOR_OF_STRONG_REFERRABLES, None)
  }
  #[inline]
  pub fn co_owning_reference(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_CO_OWNING_REFERENCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn vector_of_co_owning_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_CO_OWNING_REFERENCES, None)
  }
  #[inline]
  pub fn non_owning_reference(&self) -> u64 {
    self._tab.get::<u64>(Monster::VT_NON_OWNING_REFERENCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn vector_of_non_owning_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_NON_OWNING_REFERENCES, None)
  }
  #[inline]
  pub fn any_unique_type(&self) -> AnyUniqueAliases {
    self._tab.get::<AnyUniqueAliases>(Monster::VT_ANY_UNIQUE_TYPE, Some(AnyUniqueAliases::NONE)).unwrap()
  }
  #[inline]
  pub fn any_unique(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_ANY_UNIQUE, None)
  }
  #[inline]
  pub fn any_ambiguous_type(&self) -> AnyAmbiguousAliases {
    self._tab.get::<AnyAmbiguousAliases>(Monster::VT_ANY_AMBIGUOUS_TYPE, Some(AnyAmbiguousAliases::NONE)).unwrap()
  }
  #[inline]
  pub fn any_ambiguous(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_ANY_AMBIGUOUS, None)
  }
  #[inline]
  pub fn vector_of_enums(&self) -> Option<flatbuffers::Vector<'a, Color>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Color>>>(Monster::VT_VECTOR_OF_ENUMS, None)
  }
  #[inline]
  pub fn signed_enum(&self) -> Race {
    self._tab.get::<Race>(Monster::VT_SIGNED_ENUM, Some(Race::None)).unwrap()
  }
  #[inline]
  pub fn testrequirednestedflatbuffer(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_TESTREQUIREDNESTEDFLATBUFFER, None).map(|v| v.safe_slice())
  }
  pub fn testrequirednestedflatbuffer_nested_flatbuffer(&'a self) -> Option<Monster<'a>> {
    self.testrequirednestedflatbuffer().map(|data| {
      use flatbuffers::Follow;
      <flatbuffers::ForwardsUOffset<Monster<'a>>>::follow(data, 0)
    })
  }
  #[inline]
  pub fn scalar_key_sorted_tables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat>>>>(Monster::VT_SCALAR_KEY_SORTED_TABLES, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_monster(&self) -> Option<Monster<'a>> {
    if self.test_type() == Any::Monster {
      self.test().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_test_simple_table_with_enum(&self) -> Option<TestSimpleTableWithEnum<'a>> {
    if self.test_type() == Any::TestSimpleTableWithEnum {
      self.test().map(TestSimpleTableWithEnum::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_my_game_example_2_monster(&self) -> Option<super::example_2::Monster<'a>> {
    if self.test_type() == Any::MyGame_Example2_Monster {
      self.test().map(super::example_2::Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_m(&self) -> Option<Monster<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::M {
      self.any_unique().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_ts(&self) -> Option<TestSimpleTableWithEnum<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::TS {
      self.any_unique().map(TestSimpleTableWithEnum::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_m2(&self) -> Option<super::example_2::Monster<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::M2 {
      self.any_unique().map(super::example_2::Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m1(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M1 {
      self.any_ambiguous().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m2(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M2 {
      self.any_ambiguous().map(Monster::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m3(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M3 {
      self.any_ambiguous().map(Monster::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Monster<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3>("pos", Self::VT_POS, false)?
     .visit_field::<i16>("mana", Self::VT_MANA, false)?
     .visit_field::<i16>("hp", Self::VT_HP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("inventory", Self::VT_INVENTORY, false)?
     .visit_field::<Color>("color", Self::VT_COLOR, false)?
     .visit_union::<Any, _>("test_type", Self::VT_TEST_TYPE, "test", Self::VT_TEST, false, |key, v, pos| {
        match key {
          Any::Monster => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("Any::Monster", pos),
          Any::TestSimpleTableWithEnum => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestSimpleTableWithEnum>>("Any::TestSimpleTableWithEnum", pos),
          Any::MyGame_Example2_Monster => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::example_2::Monster>>("Any::MyGame_Example2_Monster", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Test>>>("test4", Self::VT_TEST4, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("testarrayofstring", Self::VT_TESTARRAYOFSTRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Monster>>>>("testarrayoftables", Self::VT_TESTARRAYOFTABLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Monster>>("enemy", Self::VT_ENEMY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("testnestedflatbuffer", Self::VT_TESTNESTEDFLATBUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Stat>>("testempty", Self::VT_TESTEMPTY, false)?
     .visit_field::<bool>("testbool", Self::VT_TESTBOOL, false)?
     .visit_field::<i32>("testhashs32_fnv1", Self::VT_TESTHASHS32_FNV1, false)?
     .visit_field::<u32>("testhashu32_fnv1", Self::VT_TESTHASHU32_FNV1, false)?
     .visit_field::<i64>("testhashs64_fnv1", Self::VT_TESTHASHS64_FNV1, false)?
     .visit_field::<u64>("testhashu64_fnv1", Self::VT_TESTHASHU64_FNV1, false)?
     .visit_field::<i32>("testhashs32_fnv1a", Self::VT_TESTHASHS32_FNV1A, false)?
     .visit_field::<u32>("testhashu32_fnv1a", Self::VT_TESTHASHU32_FNV1A, false)?
     .visit_field::<i64>("testhashs64_fnv1a", Self::VT_TESTHASHS64_FNV1A, false)?
     .visit_field::<u64>("testhashu64_fnv1a", Self::VT_TESTHASHU64_FNV1A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("testarrayofbools", Self::VT_TESTARRAYOFBOOLS, false)?
     .visit_field::<f32>("testf", Self::VT_TESTF, false)?
     .visit_field::<f32>("testf2", Self::VT_TESTF2, false)?
     .visit_field::<f32>("testf3", Self::VT_TESTF3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("testarrayofstring2", Self::VT_TESTARRAYOFSTRING2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Ability>>>("testarrayofsortedstruct", Self::VT_TESTARRAYOFSORTEDSTRUCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("flex", Self::VT_FLEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Test>>>("test5", Self::VT_TEST5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("vector_of_longs", Self::VT_VECTOR_OF_LONGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("vector_of_doubles", Self::VT_VECTOR_OF_DOUBLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::InParentNamespace>>("parent_namespace_test", Self::VT_PARENT_NAMESPACE_TEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Referrable>>>>("vector_of_referrables", Self::VT_VECTOR_OF_REFERRABLES, false)?
     .visit_field::<u64>("single_weak_reference", Self::VT_SINGLE_WEAK_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("vector_of_weak_references", Self::VT_VECTOR_OF_WEAK_REFERENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Referrable>>>>("vector_of_strong_referrables", Self::VT_VECTOR_OF_STRONG_REFERRABLES, false)?
     .visit_field::<u64>("co_owning_reference", Self::VT_CO_OWNING_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("vector_of_co_owning_references", Self::VT_VECTOR_OF_CO_OWNING_REFERENCES, false)?
     .visit_field::<u64>("non_owning_reference", Self::VT_NON_OWNING_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("vector_of_non_owning_references", Self::VT_VECTOR_OF_NON_OWNING_REFERENCES, false)?
     .visit_union::<AnyUniqueAliases, _>("any_unique_type", Self::VT_ANY_UNIQUE_TYPE, "any_unique", Self::VT_ANY_UNIQUE, false, |key, v, pos| {
        match key {
          AnyUniqueAliases::M => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyUniqueAliases::M", pos),
          AnyUniqueAliases::TS => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestSimpleTableWithEnum>>("AnyUniqueAliases::TS", pos),
          AnyUniqueAliases::M2 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::example_2::Monster>>("AnyUniqueAliases::M2", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<AnyAmbiguousAliases, _>("any_ambiguous_type", Self::VT_ANY_AMBIGUOUS_TYPE, "any_ambiguous", Self::VT_ANY_AMBIGUOUS, false, |key, v, pos| {
        match key {
          AnyAmbiguousAliases::M1 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M1", pos),
          AnyAmbiguousAliases::M2 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M2", pos),
          AnyAmbiguousAliases::M3 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M3", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Color>>>("vector_of_enums", Self::VT_VECTOR_OF_ENUMS, false)?
     .visit_field::<Race>("signed_enum", Self::VT_SIGNED_ENUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("testrequirednestedflatbuffer", Self::VT_TESTREQUIREDNESTEDFLATBUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Stat>>>>("scalar_key_sorted_tables", Self::VT_SCALAR_KEY_SORTED_TABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct MonsterArgs<'a> {
    pub pos: Option<&'a Vec3>,
    pub mana: i16,
    pub hp: i16,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub color: Color,
    pub test_type: Any,
    pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub test4: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Test>>>,
    pub testarrayofstring: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub testarrayoftables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster<'a>>>>>,
    pub enemy: Option<flatbuffers::WIPOffset<Monster<'a>>>,
    pub testnestedflatbuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub testempty: Option<flatbuffers::WIPOffset<Stat<'a>>>,
    pub testbool: bool,
    pub testhashs32_fnv1: i32,
    pub testhashu32_fnv1: u32,
    pub testhashs64_fnv1: i64,
    pub testhashu64_fnv1: u64,
    pub testhashs32_fnv1a: i32,
    pub testhashu32_fnv1a: u32,
    pub testhashs64_fnv1a: i64,
    pub testhashu64_fnv1a: u64,
    pub testarrayofbools: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub testf: f32,
    pub testf2: f32,
    pub testf3: f32,
    pub testarrayofstring2: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub testarrayofsortedstruct: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Ability>>>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub test5: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Test>>>,
    pub vector_of_longs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub vector_of_doubles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub parent_namespace_test: Option<flatbuffers::WIPOffset<super::InParentNamespace<'a>>>,
    pub vector_of_referrables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>>>,
    pub single_weak_reference: u64,
    pub vector_of_weak_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub vector_of_strong_referrables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>>>,
    pub co_owning_reference: u64,
    pub vector_of_co_owning_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub non_owning_reference: u64,
    pub vector_of_non_owning_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub any_unique_type: AnyUniqueAliases,
    pub any_unique: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub any_ambiguous_type: AnyAmbiguousAliases,
    pub any_ambiguous: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vector_of_enums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Color>>>,
    pub signed_enum: Race,
    pub testrequirednestedflatbuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub scalar_key_sorted_tables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat<'a>>>>>,
}
impl<'a> Default for MonsterArgs<'a> {
  #[inline]
  fn default() -> Self {
    MonsterArgs {
      pos: None,
      mana: 150,
      hp: 100,
      name: None, // required field
      inventory: None,
      color: Color::Blue,
      test_type: Any::NONE,
      test: None,
      test4: None,
      testarrayofstring: None,
      testarrayoftables: None,
      enemy: None,
      testnestedflatbuffer: None,
      testempty: None,
      testbool: false,
      testhashs32_fnv1: 0,
      testhashu32_fnv1: 0,
      testhashs64_fnv1: 0,
      testhashu64_fnv1: 0,
      testhashs32_fnv1a: 0,
      testhashu32_fnv1a: 0,
      testhashs64_fnv1a: 0,
      testhashu64_fnv1a: 0,
      testarrayofbools: None,
      testf: 3.14159,
      testf2: 3.0,
      testf3: 0.0,
      testarrayofstring2: None,
      testarrayofsortedstruct: None,
      flex: None,
      test5: None,
      vector_of_longs: None,
      vector_of_doubles: None,
      parent_namespace_test: None,
      vector_of_referrables: None,
      single_weak_reference: 0,
      vector_of_weak_references: None,
      vector_of_strong_referrables: None,
      co_owning_reference: 0,
      vector_of_co_owning_references: None,
      non_owning_reference: 0,
      vector_of_non_owning_references: None,
      any_unique_type: AnyUniqueAliases::NONE,
      any_unique: None,
      any_ambiguous_type: AnyAmbiguousAliases::NONE,
      any_ambiguous: None,
      vector_of_enums: None,
      signed_enum: Race::None,
      testrequirednestedflatbuffer: None,
      scalar_key_sorted_tables: None,
    }
  }
}
pub struct MonsterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MonsterBuilder<'a, 'b> {
  #[inline]
  pub fn add_pos(&mut self, pos: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(Monster::VT_POS, pos);
  }
  #[inline]
  pub fn add_mana(&mut self, mana: i16) {
    self.fbb_.push_slot::<i16>(Monster::VT_MANA, mana, 150);
  }
  #[inline]
  pub fn add_hp(&mut self, hp: i16) {
    self.fbb_.push_slot::<i16>(Monster::VT_HP, hp, 100);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_NAME, name);
  }
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn add_color(&mut self, color: Color) {
    self.fbb_.push_slot::<Color>(Monster::VT_COLOR, color, Color::Blue);
  }
  #[inline]
  pub fn add_test_type(&mut self, test_type: Any) {
    self.fbb_.push_slot::<Any>(Monster::VT_TEST_TYPE, test_type, Any::NONE);
  }
  #[inline]
  pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST, test);
  }
  #[inline]
  pub fn add_test4(&mut self, test4: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Test>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST4, test4);
  }
  #[inline]
  pub fn add_testarrayofstring(&mut self, testarrayofstring: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSTRING, testarrayofstring);
  }
  #[inline]
  pub fn add_testarrayoftables(&mut self, testarrayoftables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Monster<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFTABLES, testarrayoftables);
  }
  #[inline]
  pub fn add_enemy(&mut self, enemy: flatbuffers::WIPOffset<Monster<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Monster>>(Monster::VT_ENEMY, enemy);
  }
  #[inline]
  pub fn add_testnestedflatbuffer(&mut self, testnestedflatbuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTNESTEDFLATBUFFER, testnestedflatbuffer);
  }
  #[inline]
  pub fn add_testempty(&mut self, testempty: flatbuffers::WIPOffset<Stat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Stat>>(Monster::VT_TESTEMPTY, testempty);
  }
  #[inline]
  pub fn add_testbool(&mut self, testbool: bool) {
    self.fbb_.push_slot::<bool>(Monster::VT_TESTBOOL, testbool, false);
  }
  #[inline]
  pub fn add_testhashs32_fnv1(&mut self, testhashs32_fnv1: i32) {
    self.fbb_.push_slot::<i32>(Monster::VT_TESTHASHS32_FNV1, testhashs32_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashu32_fnv1(&mut self, testhashu32_fnv1: u32) {
    self.fbb_.push_slot::<u32>(Monster::VT_TESTHASHU32_FNV1, testhashu32_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashs64_fnv1(&mut self, testhashs64_fnv1: i64) {
    self.fbb_.push_slot::<i64>(Monster::VT_TESTHASHS64_FNV1, testhashs64_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashu64_fnv1(&mut self, testhashu64_fnv1: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_TESTHASHU64_FNV1, testhashu64_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashs32_fnv1a(&mut self, testhashs32_fnv1a: i32) {
    self.fbb_.push_slot::<i32>(Monster::VT_TESTHASHS32_FNV1A, testhashs32_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashu32_fnv1a(&mut self, testhashu32_fnv1a: u32) {
    self.fbb_.push_slot::<u32>(Monster::VT_TESTHASHU32_FNV1A, testhashu32_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashs64_fnv1a(&mut self, testhashs64_fnv1a: i64) {
    self.fbb_.push_slot::<i64>(Monster::VT_TESTHASHS64_FNV1A, testhashs64_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashu64_fnv1a(&mut self, testhashu64_fnv1a: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_TESTHASHU64_FNV1A, testhashu64_fnv1a, 0);
  }
  #[inline]
  pub fn add_testarrayofbools(&mut self, testarrayofbools: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFBOOLS, testarrayofbools);
  }
  #[inline]
  pub fn add_testf(&mut self, testf: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF, testf, 3.14159);
  }
  #[inline]
  pub fn add_testf2(&mut self, testf2: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF2, testf2, 3.0);
  }
  #[inline]
  pub fn add_testf3(&mut self, testf3: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF3, testf3, 0.0);
  }
  #[inline]
  pub fn add_testarrayofstring2(&mut self, testarrayofstring2: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSTRING2, testarrayofstring2);
  }
  #[inline]
  pub fn add_testarrayofsortedstruct(&mut self, testarrayofsortedstruct: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Ability>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSORTEDSTRUCT, testarrayofsortedstruct);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_FLEX, flex);
  }
  #[inline]
  pub fn add_test5(&mut self, test5: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Test>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST5, test5);
  }
  #[inline]
  pub fn add_vector_of_longs(&mut self, vector_of_longs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_LONGS, vector_of_longs);
  }
  #[inline]
  pub fn add_vector_of_doubles(&mut self, vector_of_doubles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_DOUBLES, vector_of_doubles);
  }
  #[inline]
  pub fn add_parent_namespace_test(&mut self, parent_namespace_test: flatbuffers::WIPOffset<super::InParentNamespace<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::InParentNamespace>>(Monster::VT_PARENT_NAMESPACE_TEST, parent_namespace_test);
  }
  #[inline]
  pub fn add_vector_of_referrables(&mut self, vector_of_referrables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Referrable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_REFERRABLES, vector_of_referrables);
  }
  #[inline]
  pub fn add_single_weak_reference(&mut self, single_weak_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_SINGLE_WEAK_REFERENCE, single_weak_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_weak_references(&mut self, vector_of_weak_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_WEAK_REFERENCES, vector_of_weak_references);
  }
  #[inline]
  pub fn add_vector_of_strong_referrables(&mut self, vector_of_strong_referrables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Referrable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_STRONG_REFERRABLES, vector_of_strong_referrables);
  }
  #[inline]
  pub fn add_co_owning_reference(&mut self, co_owning_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_CO_OWNING_REFERENCE, co_owning_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_co_owning_references(&mut self, vector_of_co_owning_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_CO_OWNING_REFERENCES, vector_of_co_owning_references);
  }
  #[inline]
  pub fn add_non_owning_reference(&mut self, non_owning_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_NON_OWNING_REFERENCE, non_owning_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_non_owning_references(&mut self, vector_of_non_owning_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_NON_OWNING_REFERENCES, vector_of_non_owning_references);
  }
  #[inline]
  pub fn add_any_unique_type(&mut self, any_unique_type: AnyUniqueAliases) {
    self.fbb_.push_slot::<AnyUniqueAliases>(Monster::VT_ANY_UNIQUE_TYPE, any_unique_type, AnyUniqueAliases::NONE);
  }
  #[inline]
  pub fn add_any_unique(&mut self, any_unique: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_ANY_UNIQUE, any_unique);
  }
  #[inline]
  pub fn add_any_ambiguous_type(&mut self, any_ambiguous_type: AnyAmbiguousAliases) {
    self.fbb_.push_slot::<AnyAmbiguousAliases>(Monster::VT_ANY_AMBIGUOUS_TYPE, any_ambiguous_type, AnyAmbiguousAliases::NONE);
  }
  #[inline]
  pub fn add_any_ambiguous(&mut self, any_ambiguous: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_ANY_AMBIGUOUS, any_ambiguous);
  }
  #[inline]
  pub fn add_vector_of_enums(&mut self, vector_of_enums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Color>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_ENUMS, vector_of_enums);
  }
  #[inline]
  pub fn add_signed_enum(&mut self, signed_enum: Race) {
    self.fbb_.push_slot::<Race>(Monster::VT_SIGNED_ENUM, signed_enum, Race::None);
  }
  #[inline]
  pub fn add_testrequirednestedflatbuffer(&mut self, testrequirednestedflatbuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTREQUIREDNESTEDFLATBUFFER, testrequirednestedflatbuffer);
  }
  #[inline]
  pub fn add_scalar_key_sorted_tables(&mut self, scalar_key_sorted_tables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Stat<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_SCALAR_KEY_SORTED_TABLES, scalar_key_sorted_tables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonsterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MonsterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Monster<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Monster::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Monster<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Monster");
      ds.field("pos", &self.pos());
      ds.field("mana", &self.mana());
      ds.field("hp", &self.hp());
      ds.field("name", &self.name());
      ds.field("inventory", &self.inventory());
      ds.field("color", &self.color());
      ds.field("test_type", &self.test_type());
      match self.test_type() {
        Any::Monster => {
          if let Some(x) = self.test_as_monster() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Any::TestSimpleTableWithEnum => {
          if let Some(x) = self.test_as_test_simple_table_with_enum() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Any::MyGame_Example2_Monster => {
          if let Some(x) = self.test_as_my_game_example_2_monster() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("test", &x)
        },
      };
      ds.field("test4", &self.test4());
      ds.field("testarrayofstring", &self.testarrayofstring());
      ds.field("testarrayoftables", &self.testarrayoftables());
      ds.field("enemy", &self.enemy());
      ds.field("testnestedflatbuffer", &self.testnestedflatbuffer());
      ds.field("testempty", &self.testempty());
      ds.field("testbool", &self.testbool());
      ds.field("testhashs32_fnv1", &self.testhashs32_fnv1());
      ds.field("testhashu32_fnv1", &self.testhashu32_fnv1());
      ds.field("testhashs64_fnv1", &self.testhashs64_fnv1());
      ds.field("testhashu64_fnv1", &self.testhashu64_fnv1());
      ds.field("testhashs32_fnv1a", &self.testhashs32_fnv1a());
      ds.field("testhashu32_fnv1a", &self.testhashu32_fnv1a());
      ds.field("testhashs64_fnv1a", &self.testhashs64_fnv1a());
      ds.field("testhashu64_fnv1a", &self.testhashu64_fnv1a());
      ds.field("testarrayofbools", &self.testarrayofbools());
      ds.field("testf", &self.testf());
      ds.field("testf2", &self.testf2());
      ds.field("testf3", &self.testf3());
      ds.field("testarrayofstring2", &self.testarrayofstring2());
      ds.field("testarrayofsortedstruct", &self.testarrayofsortedstruct());
      ds.field("flex", &self.flex());
      ds.field("test5", &self.test5());
      ds.field("vector_of_longs", &self.vector_of_longs());
      ds.field("vector_of_doubles", &self.vector_of_doubles());
      ds.field("parent_namespace_test", &self.parent_namespace_test());
      ds.field("vector_of_referrables", &self.vector_of_referrables());
      ds.field("single_weak_reference", &self.single_weak_reference());
      ds.field("vector_of_weak_references", &self.vector_of_weak_references());
      ds.field("vector_of_strong_referrables", &self.vector_of_strong_referrables());
      ds.field("co_owning_reference", &self.co_owning_reference());
      ds.field("vector_of_co_owning_references", &self.vector_of_co_owning_references());
      ds.field("non_owning_reference", &self.non_owning_reference());
      ds.field("vector_of_non_owning_references", &self.vector_of_non_owning_references());
      ds.field("any_unique_type", &self.any_unique_type());
      match self.any_unique_type() {
        AnyUniqueAliases::M => {
          if let Some(x) = self.any_unique_as_m() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyUniqueAliases::TS => {
          if let Some(x) = self.any_unique_as_ts() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyUniqueAliases::M2 => {
          if let Some(x) = self.any_unique_as_m2() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_unique", &x)
        },
      };
      ds.field("any_ambiguous_type", &self.any_ambiguous_type());
      match self.any_ambiguous_type() {
        AnyAmbiguousAliases::M1 => {
          if let Some(x) = self.any_ambiguous_as_m1() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyAmbiguousAliases::M2 => {
          if let Some(x) = self.any_ambiguous_as_m2() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyAmbiguousAliases::M3 => {
          if let Some(x) = self.any_ambiguous_as_m3() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_ambiguous", &x)
        },
      };
      ds.field("vector_of_enums", &self.vector_of_enums());
      ds.field("signed_enum", &self.signed_enum());
      ds.field("testrequirednestedflatbuffer", &self.testrequirednestedflatbuffer());
      ds.field("scalar_key_sorted_tables", &self.scalar_key_sorted_tables());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MonsterT {
  pub pos: Option<Vec3T>,
  pub mana: i16,
  pub hp: i16,
  pub name: String,
  pub inventory: Option<Vec<u8>>,
  pub color: Color,
  pub test: AnyT,
  pub test4: Option<Vec<TestT>>,
  pub testarrayofstring: Option<Vec<String>>,
  pub testarrayoftables: Option<Vec<MonsterT>>,
  pub enemy: Option<Box<MonsterT>>,
  pub testnestedflatbuffer: Option<Vec<u8>>,
  pub testempty: Option<Box<StatT>>,
  pub testbool: bool,
  pub testhashs32_fnv1: i32,
  pub testhashu32_fnv1: u32,
  pub testhashs64_fnv1: i64,
  pub testhashu64_fnv1: u64,
  pub testhashs32_fnv1a: i32,
  pub testhashu32_fnv1a: u32,
  pub testhashs64_fnv1a: i64,
  pub testhashu64_fnv1a: u64,
  pub testarrayofbools: Option<Vec<bool>>,
  pub testf: f32,
  pub testf2: f32,
  pub testf3: f32,
  pub testarrayofstring2: Option<Vec<String>>,
  pub testarrayofsortedstruct: Option<Vec<AbilityT>>,
  pub flex: Option<Vec<u8>>,
  pub test5: Option<Vec<TestT>>,
  pub vector_of_longs: Option<Vec<i64>>,
  pub vector_of_doubles: Option<Vec<f64>>,
  pub parent_namespace_test: Option<Box<super::InParentNamespaceT>>,
  pub vector_of_referrables: Option<Vec<ReferrableT>>,
  pub single_weak_reference: u64,
  pub vector_of_weak_references: Option<Vec<u64>>,
  pub vector_of_strong_referrables: Option<Vec<ReferrableT>>,
  pub co_owning_reference: u64,
  pub vector_of_co_owning_references: Option<Vec<u64>>,
  pub non_owning_reference: u64,
  pub vector_of_non_owning_references: Option<Vec<u64>>,
  pub any_unique: AnyUniqueAliasesT,
  pub any_ambiguous: AnyAmbiguousAliasesT,
  pub vector_of_enums: Option<Vec<Color>>,
  pub signed_enum: Race,
  pub testrequirednestedflatbuffer: Option<Vec<u8>>,
  pub scalar_key_sorted_tables: Option<Vec<StatT>>,
}
impl Default for MonsterT {
  fn default() -> Self {
    Self {
      pos: None,
      mana: 150,
      hp: 100,
      name: "".to_string(),
      inventory: None,
      color: Color::Blue,
      test: AnyT::NONE,
      test4: None,
      testarrayofstring: None,
      testarrayoftables: None,
      enemy: None,
      testnestedflatbuffer: None,
      testempty: None,
      testbool: false,
      testhashs32_fnv1: 0,
      testhashu32_fnv1: 0,
      testhashs64_fnv1: 0,
      testhashu64_fnv1: 0,
      testhashs32_fnv1a: 0,
      testhashu32_fnv1a: 0,
      testhashs64_fnv1a: 0,
      testhashu64_fnv1a: 0,
      testarrayofbools: None,
      testf: 3.14159,
      testf2: 3.0,
      testf3: 0.0,
      testarrayofstring2: None,
      testarrayofsortedstruct: None,
      flex: None,
      test5: None,
      vector_of_longs: None,
      vector_of_doubles: None,
      parent_namespace_test: None,
      vector_of_referrables: None,
      single_weak_reference: 0,
      vector_of_weak_references: None,
      vector_of_strong_referrables: None,
      co_owning_reference: 0,
      vector_of_co_owning_references: None,
      non_owning_reference: 0,
      vector_of_non_owning_references: None,
      any_unique: AnyUniqueAliasesT::NONE,
      any_ambiguous: AnyAmbiguousAliasesT::NONE,
      vector_of_enums: None,
      signed_enum: Race::None,
      testrequirednestedflatbuffer: None,
      scalar_key_sorted_tables: None,
    }
  }
}
impl MonsterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Monster<'b>> {
    let pos_tmp = self.pos.as_ref().map(|x| x.pack());
    let pos = pos_tmp.as_ref();
    let mana = self.mana;
    let hp = self.hp;
    let name = Some({
      let x = &self.name;
      _fbb.create_string(x)
    });
    let inventory = self.inventory.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let color = self.color;
    let test_type = self.test.any_type();
    let test = self.test.pack(_fbb);
    let test4 = self.test4.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let testarrayofstring = self.testarrayofstring.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| s.as_ref()).collect();_fbb.create_vector_of_strings(&w)
    });
    let testarrayoftables = self.testarrayoftables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let enemy = self.enemy.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let testnestedflatbuffer = self.testnestedflatbuffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let testempty = self.testempty.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let testbool = self.testbool;
    let testhashs32_fnv1 = self.testhashs32_fnv1;
    let testhashu32_fnv1 = self.testhashu32_fnv1;
    let testhashs64_fnv1 = self.testhashs64_fnv1;
    let testhashu64_fnv1 = self.testhashu64_fnv1;
    let testhashs32_fnv1a = self.testhashs32_fnv1a;
    let testhashu32_fnv1a = self.testhashu32_fnv1a;
    let testhashs64_fnv1a = self.testhashs64_fnv1a;
    let testhashu64_fnv1a = self.testhashu64_fnv1a;
    let testarrayofbools = self.testarrayofbools.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let testf = self.testf;
    let testf2 = self.testf2;
    let testf3 = self.testf3;
    let testarrayofstring2 = self.testarrayofstring2.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| s.as_ref()).collect();_fbb.create_vector_of_strings(&w)
    });
    let testarrayofsortedstruct = self.testarrayofsortedstruct.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let test5 = self.test5.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let vector_of_longs = self.vector_of_longs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vector_of_doubles = self.vector_of_doubles.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let parent_namespace_test = self.parent_namespace_test.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let vector_of_referrables = self.vector_of_referrables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let single_weak_reference = self.single_weak_reference;
    let vector_of_weak_references = self.vector_of_weak_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vector_of_strong_referrables = self.vector_of_strong_referrables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let co_owning_reference = self.co_owning_reference;
    let vector_of_co_owning_references = self.vector_of_co_owning_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let non_owning_reference = self.non_owning_reference;
    let vector_of_non_owning_references = self.vector_of_non_owning_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let any_unique_type = self.any_unique.any_unique_aliases_type();
    let any_unique = self.any_unique.pack(_fbb);
    let any_ambiguous_type = self.any_ambiguous.any_ambiguous_aliases_type();
    let any_ambiguous = self.any_ambiguous.pack(_fbb);
    let vector_of_enums = self.vector_of_enums.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let signed_enum = self.signed_enum;
    let testrequirednestedflatbuffer = self.testrequirednestedflatbuffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let scalar_key_sorted_tables = self.scalar_key_sorted_tables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Monster::create(_fbb, &MonsterArgs{
      pos,
      mana,
      hp,
      name,
      inventory,
      color,
      test_type,
      test,
      test4,
      testarrayofstring,
      testarrayoftables,
      enemy,
      testnestedflatbuffer,
      testempty,
      testbool,
      testhashs32_fnv1,
      testhashu32_fnv1,
      testhashs64_fnv1,
      testhashu64_fnv1,
      testhashs32_fnv1a,
      testhashu32_fnv1a,
      testhashs64_fnv1a,
      testhashu64_fnv1a,
      testarrayofbools,
      testf,
      testf2,
      testf3,
      testarrayofstring2,
      testarrayofsortedstruct,
      flex,
      test5,
      vector_of_longs,
      vector_of_doubles,
      parent_namespace_test,
      vector_of_referrables,
      single_weak_reference,
      vector_of_weak_references,
      vector_of_strong_referrables,
      co_owning_reference,
      vector_of_co_owning_references,
      non_owning_reference,
      vector_of_non_owning_references,
      any_unique_type,
      any_unique,
      any_ambiguous_type,
      any_ambiguous,
      vector_of_enums,
      signed_enum,
      testrequirednestedflatbuffer,
      scalar_key_sorted_tables,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
  unsafe { flatbuffers::root_unchecked::<Monster<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Monster<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Monster`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Monster>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Monster` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_monster_unchecked`.
pub fn size_prefixed_root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Monster>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Monster` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn root_as_monster_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Monster<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Monster` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn size_prefixed_root_as_monster_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Monster<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Monster and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Monster`.
pub unsafe fn root_as_monster_unchecked(buf: &[u8]) -> Monster {
  flatbuffers::root_unchecked::<Monster>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Monster and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Monster`.
pub unsafe fn size_prefixed_root_as_monster_unchecked(buf: &[u8]) -> Monster {
  flatbuffers::size_prefixed_root_unchecked::<Monster>(buf)
}
pub const MONSTER_IDENTIFIER: &str = "MONS";

#[inline]
pub fn monster_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MONSTER_IDENTIFIER, false)
}

#[inline]
pub fn monster_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MONSTER_IDENTIFIER, true)
}

pub const MONSTER_EXTENSION: &str = "mon";

#[inline]
pub fn finish_monster_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Monster<'a>>) {
  fbb.finish(root, Some(MONSTER_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_monster_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Monster<'a>>) {
  fbb.finish_size_prefixed(root, Some(MONSTER_IDENTIFIER));
}

// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { Ability } from '../../my-game/example/ability.js';
import { Any, unionToAny } from '../../my-game/example/any.js';
import { AnyAmbiguousAliases, unionToAnyAmbiguousAliases } from '../../my-game/example/any-ambiguous-aliases.js';
import { AnyUniqueAliases, unionToAnyUniqueAliases } from '../../my-game/example/any-unique-aliases.js';
import { Color } from '../../my-game/example/color.js';
import { Race } from '../../my-game/example/race.js';
import { Referrable } from '../../my-game/example/referrable.js';
import { Stat } from '../../my-game/example/stat.js';
import { Test } from '../../my-game/example/test.js';
import { Vec3 } from '../../my-game/example/vec3.js';
import { InParentNamespace } from '../../my-game/in-parent-namespace.js';
/**
 * an example documentation comment: "monster object"
 */
export class Monster {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMonster(bb, obj) {
        return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMonster(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('MONS');
    }
    pos(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new Vec3()).__init(this.bb_pos + offset, this.bb) : null;
    }
    mana() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 150;
    }
    mutate_mana(value) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt16(this.bb_pos + offset, value);
        return true;
    }
    hp() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 100;
    }
    mutate_hp(value) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt16(this.bb_pos + offset, value);
        return true;
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    inventory(index) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    inventoryLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    inventoryArray() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    color() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : Color.Blue;
    }
    mutate_color(value) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint8(this.bb_pos + offset, value);
        return true;
    }
    testType() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : Any.NONE;
    }
    test(obj) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    test4(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new Test()).__init(this.bb.__vector(this.bb_pos + offset) + index * 4, this.bb) : null;
    }
    test4Length() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    testarrayofstring(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    testarrayofstringLength() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * an example documentation comment: this will end up in the generated code
     * multiline too
     */
    testarrayoftables(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? (obj || new Monster()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    testarrayoftablesLength() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    enemy(obj) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? (obj || new Monster()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    testnestedflatbuffer(index) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    testnestedflatbufferLength() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    testnestedflatbufferArray() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    testempty(obj) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? (obj || new Stat()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    testbool() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    mutate_testbool(value) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt8(this.bb_pos + offset, +value);
        return true;
    }
    testhashs32Fnv1() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    mutate_testhashs32_fnv1(value) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt32(this.bb_pos + offset, value);
        return true;
    }
    testhashu32Fnv1() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    mutate_testhashu32_fnv1(value) {
        const offset = this.bb.__offset(this.bb_pos, 38);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint32(this.bb_pos + offset, value);
        return true;
    }
    testhashs64Fnv1() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_testhashs64_fnv1(value) {
        const offset = this.bb.__offset(this.bb_pos, 40);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt64(this.bb_pos + offset, value);
        return true;
    }
    testhashu64Fnv1() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_testhashu64_fnv1(value) {
        const offset = this.bb.__offset(this.bb_pos, 42);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    testhashs32Fnv1a() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    mutate_testhashs32_fnv1a(value) {
        const offset = this.bb.__offset(this.bb_pos, 44);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt32(this.bb_pos + offset, value);
        return true;
    }
    testhashu32Fnv1a() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    mutate_testhashu32_fnv1a(value) {
        const offset = this.bb.__offset(this.bb_pos, 46);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint32(this.bb_pos + offset, value);
        return true;
    }
    testhashs64Fnv1a() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_testhashs64_fnv1a(value) {
        const offset = this.bb.__offset(this.bb_pos, 48);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt64(this.bb_pos + offset, value);
        return true;
    }
    testhashu64Fnv1a() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_testhashu64_fnv1a(value) {
        const offset = this.bb.__offset(this.bb_pos, 50);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    testarrayofbools(index) {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? !!this.bb.readInt8(this.bb.__vector(this.bb_pos + offset) + index) : false;
    }
    testarrayofboolsLength() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    testarrayofboolsArray() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? new Int8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    testf() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 3.14159;
    }
    mutate_testf(value) {
        const offset = this.bb.__offset(this.bb_pos, 54);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    testf2() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 3.0;
    }
    mutate_testf2(value) {
        const offset = this.bb.__offset(this.bb_pos, 56);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    testf3() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    mutate_testf3(value) {
        const offset = this.bb.__offset(this.bb_pos, 58);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    testarrayofstring2(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    testarrayofstring2Length() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    testarrayofsortedstruct(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? (obj || new Ability()).__init(this.bb.__vector(this.bb_pos + offset) + index * 8, this.bb) : null;
    }
    testarrayofsortedstructLength() {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    flex(index) {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    flexLength() {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    flexArray() {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    test5(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? (obj || new Test()).__init(this.bb.__vector(this.bb_pos + offset) + index * 4, this.bb) : null;
    }
    test5Length() {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    vectorOfLongs(index) {
        const offset = this.bb.__offset(this.bb_pos, 68);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    vectorOfLongsLength() {
        const offset = this.bb.__offset(this.bb_pos, 68);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    vectorOfDoubles(index) {
        const offset = this.bb.__offset(this.bb_pos, 70);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    vectorOfDoublesLength() {
        const offset = this.bb.__offset(this.bb_pos, 70);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    vectorOfDoublesArray() {
        const offset = this.bb.__offset(this.bb_pos, 70);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    parentNamespaceTest(obj) {
        const offset = this.bb.__offset(this.bb_pos, 72);
        return offset ? (obj || new InParentNamespace()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    vectorOfReferrables(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 74);
        return offset ? (obj || new Referrable()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    vectorOfReferrablesLength() {
        const offset = this.bb.__offset(this.bb_pos, 74);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    singleWeakReference() {
        const offset = this.bb.__offset(this.bb_pos, 76);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_single_weak_reference(value) {
        const offset = this.bb.__offset(this.bb_pos, 76);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    vectorOfWeakReferences(index) {
        const offset = this.bb.__offset(this.bb_pos, 78);
        return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    vectorOfWeakReferencesLength() {
        const offset = this.bb.__offset(this.bb_pos, 78);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    vectorOfStrongReferrables(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 80);
        return offset ? (obj || new Referrable()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    vectorOfStrongReferrablesLength() {
        const offset = this.bb.__offset(this.bb_pos, 80);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    coOwningReference() {
        const offset = this.bb.__offset(this.bb_pos, 82);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_co_owning_reference(value) {
        const offset = this.bb.__offset(this.bb_pos, 82);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    vectorOfCoOwningReferences(index) {
        const offset = this.bb.__offset(this.bb_pos, 84);
        return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    vectorOfCoOwningReferencesLength() {
        const offset = this.bb.__offset(this.bb_pos, 84);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    nonOwningReference() {
        const offset = this.bb.__offset(this.bb_pos, 86);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_non_owning_reference(value) {
        const offset = this.bb.__offset(this.bb_pos, 86);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    vectorOfNonOwningReferences(index) {
        const offset = this.bb.__offset(this.bb_pos, 88);
        return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    vectorOfNonOwningReferencesLength() {
        const offset = this.bb.__offset(this.bb_pos, 88);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    anyUniqueType() {
        const offset = this.bb.__offset(this.bb_pos, 90);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : AnyUniqueAliases.NONE;
    }
    anyUnique(obj) {
        const offset = this.bb.__offset(this.bb_pos, 92);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    anyAmbiguousType() {
        const offset = this.bb.__offset(this.bb_pos, 94);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : AnyAmbiguousAliases.NONE;
    }
    anyAmbiguous(obj) {
        const offset = this.bb.__offset(this.bb_pos, 96);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    vectorOfEnums(index) {
        const offset = this.bb.__offset(this.bb_pos, 98);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    vectorOfEnumsLength() {
        const offset = this.bb.__offset(this.bb_pos, 98);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    vectorOfEnumsArray() {
        const offset = this.bb.__offset(this.bb_pos, 98);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    signedEnum() {
        const offset = this.bb.__offset(this.bb_pos, 100);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : Race.None;
    }
    mutate_signed_enum(value) {
        const offset = this.bb.__offset(this.bb_pos, 100);
        if (offset === 0) {
            return false;
        }
        this.bb.writeInt8(this.bb_pos + offset, value);
        return true;
    }
    testrequirednestedflatbuffer(index) {
        const offset = this.bb.__offset(this.bb_pos, 102);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    testrequirednestedflatbufferLength() {
        const offset = this.bb.__offset(this.bb_pos, 102);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    testrequirednestedflatbufferArray() {
        const offset = this.bb.__offset(this.bb_pos, 102);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    scalarKeySortedTables(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 104);
        return offset ? (obj || new Stat()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    scalarKeySortedTablesLength() {
        const offset = this.bb.__offset(this.bb_pos, 104);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    nativeInline(obj) {
        const offset = this.bb.__offset(this.bb_pos, 106);
        return offset ? (obj || new Test()).__init(this.bb_pos + offset, this.bb) : null;
    }
    longEnumNonEnumDefault() {
        const offset = this.bb.__offset(this.bb_pos, 108);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    mutate_long_enum_non_enum_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 108);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    longEnumNormalDefault() {
        const offset = this.bb.__offset(this.bb_pos, 110);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('2');
    }
    mutate_long_enum_normal_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 110);
        if (offset === 0) {
            return false;
        }
        this.bb.writeUint64(this.bb_pos + offset, value);
        return true;
    }
    nanDefault() {
        const offset = this.bb.__offset(this.bb_pos, 112);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : NaN;
    }
    mutate_nan_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 112);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    infDefault() {
        const offset = this.bb.__offset(this.bb_pos, 114);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : Infinity;
    }
    mutate_inf_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 114);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    positiveInfDefault() {
        const offset = this.bb.__offset(this.bb_pos, 116);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : Infinity;
    }
    mutate_positive_inf_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 116);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    infinityDefault() {
        const offset = this.bb.__offset(this.bb_pos, 118);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : Infinity;
    }
    mutate_infinity_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 118);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    positiveInfinityDefault() {
        const offset = this.bb.__offset(this.bb_pos, 120);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : Infinity;
    }
    mutate_positive_infinity_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 120);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    negativeInfDefault() {
        const offset = this.bb.__offset(this.bb_pos, 122);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : -Infinity;
    }
    mutate_negative_inf_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 122);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    negativeInfinityDefault() {
        const offset = this.bb.__offset(this.bb_pos, 124);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : -Infinity;
    }
    mutate_negative_infinity_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 124);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat32(this.bb_pos + offset, value);
        return true;
    }
    doubleInfDefault() {
        const offset = this.bb.__offset(this.bb_pos, 126);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : Infinity;
    }
    mutate_double_inf_default(value) {
        const offset = this.bb.__offset(this.bb_pos, 126);
        if (offset === 0) {
            return false;
        }
        this.bb.writeFloat64(this.bb_pos + offset, value);
        return true;
    }
    static getFullyQualifiedName() {
        return 'MyGame.Example.Monster';
    }
    static startMonster(builder) {
        builder.startObject(62);
    }
    static addPos(builder, posOffset) {
        builder.addFieldStruct(0, posOffset, 0);
    }
    static addMana(builder, mana) {
        builder.addFieldInt16(1, mana, 150);
    }
    static addHp(builder, hp) {
        builder.addFieldInt16(2, hp, 100);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(3, nameOffset, 0);
    }
    static addInventory(builder, inventoryOffset) {
        builder.addFieldOffset(5, inventoryOffset, 0);
    }
    static createInventoryVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startInventoryVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addColor(builder, color) {
        builder.addFieldInt8(6, color, Color.Blue);
    }
    static addTestType(builder, testType) {
        builder.addFieldInt8(7, testType, Any.NONE);
    }
    static addTest(builder, testOffset) {
        builder.addFieldOffset(8, testOffset, 0);
    }
    static addTest4(builder, test4Offset) {
        builder.addFieldOffset(9, test4Offset, 0);
    }
    static startTest4Vector(builder, numElems) {
        builder.startVector(4, numElems, 2);
    }
    static addTestarrayofstring(builder, testarrayofstringOffset) {
        builder.addFieldOffset(10, testarrayofstringOffset, 0);
    }
    static createTestarrayofstringVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTestarrayofstringVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTestarrayoftables(builder, testarrayoftablesOffset) {
        builder.addFieldOffset(11, testarrayoftablesOffset, 0);
    }
    static createTestarrayoftablesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTestarrayoftablesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addEnemy(builder, enemyOffset) {
        builder.addFieldOffset(12, enemyOffset, 0);
    }
    static addTestnestedflatbuffer(builder, testnestedflatbufferOffset) {
        builder.addFieldOffset(13, testnestedflatbufferOffset, 0);
    }
    static createTestnestedflatbufferVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startTestnestedflatbufferVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addTestempty(builder, testemptyOffset) {
        builder.addFieldOffset(14, testemptyOffset, 0);
    }
    static addTestbool(builder, testbool) {
        builder.addFieldInt8(15, +testbool, +false);
    }
    static addTesthashs32Fnv1(builder, testhashs32Fnv1) {
        builder.addFieldInt32(16, testhashs32Fnv1, 0);
    }
    static addTesthashu32Fnv1(builder, testhashu32Fnv1) {
        builder.addFieldInt32(17, testhashu32Fnv1, 0);
    }
    static addTesthashs64Fnv1(builder, testhashs64Fnv1) {
        builder.addFieldInt64(18, testhashs64Fnv1, BigInt('0'));
    }
    static addTesthashu64Fnv1(builder, testhashu64Fnv1) {
        builder.addFieldInt64(19, testhashu64Fnv1, BigInt('0'));
    }
    static addTesthashs32Fnv1a(builder, testhashs32Fnv1a) {
        builder.addFieldInt32(20, testhashs32Fnv1a, 0);
    }
    static addTesthashu32Fnv1a(builder, testhashu32Fnv1a) {
        builder.addFieldInt32(21, testhashu32Fnv1a, 0);
    }
    static addTesthashs64Fnv1a(builder, testhashs64Fnv1a) {
        builder.addFieldInt64(22, testhashs64Fnv1a, BigInt('0'));
    }
    static addTesthashu64Fnv1a(builder, testhashu64Fnv1a) {
        builder.addFieldInt64(23, testhashu64Fnv1a, BigInt('0'));
    }
    static addTestarrayofbools(builder, testarrayofboolsOffset) {
        builder.addFieldOffset(24, testarrayofboolsOffset, 0);
    }
    static createTestarrayofboolsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(+data[i]);
        }
        return builder.endVector();
    }
    static startTestarrayofboolsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addTestf(builder, testf) {
        builder.addFieldFloat32(25, testf, 3.14159);
    }
    static addTestf2(builder, testf2) {
        builder.addFieldFloat32(26, testf2, 3.0);
    }
    static addTestf3(builder, testf3) {
        builder.addFieldFloat32(27, testf3, 0.0);
    }
    static addTestarrayofstring2(builder, testarrayofstring2Offset) {
        builder.addFieldOffset(28, testarrayofstring2Offset, 0);
    }
    static createTestarrayofstring2Vector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTestarrayofstring2Vector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTestarrayofsortedstruct(builder, testarrayofsortedstructOffset) {
        builder.addFieldOffset(29, testarrayofsortedstructOffset, 0);
    }
    static startTestarrayofsortedstructVector(builder, numElems) {
        builder.startVector(8, numElems, 4);
    }
    static addFlex(builder, flexOffset) {
        builder.addFieldOffset(30, flexOffset, 0);
    }
    static createFlexVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startFlexVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addTest5(builder, test5Offset) {
        builder.addFieldOffset(31, test5Offset, 0);
    }
    static startTest5Vector(builder, numElems) {
        builder.startVector(4, numElems, 2);
    }
    static addVectorOfLongs(builder, vectorOfLongsOffset) {
        builder.addFieldOffset(32, vectorOfLongsOffset, 0);
    }
    static createVectorOfLongsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfLongsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addVectorOfDoubles(builder, vectorOfDoublesOffset) {
        builder.addFieldOffset(33, vectorOfDoublesOffset, 0);
    }
    static createVectorOfDoublesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfDoublesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addParentNamespaceTest(builder, parentNamespaceTestOffset) {
        builder.addFieldOffset(34, parentNamespaceTestOffset, 0);
    }
    static addVectorOfReferrables(builder, vectorOfReferrablesOffset) {
        builder.addFieldOffset(35, vectorOfReferrablesOffset, 0);
    }
    static createVectorOfReferrablesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfReferrablesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addSingleWeakReference(builder, singleWeakReference) {
        builder.addFieldInt64(36, singleWeakReference, BigInt('0'));
    }
    static addVectorOfWeakReferences(builder, vectorOfWeakReferencesOffset) {
        builder.addFieldOffset(37, vectorOfWeakReferencesOffset, 0);
    }
    static createVectorOfWeakReferencesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfWeakReferencesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addVectorOfStrongReferrables(builder, vectorOfStrongReferrablesOffset) {
        builder.addFieldOffset(38, vectorOfStrongReferrablesOffset, 0);
    }
    static createVectorOfStrongReferrablesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfStrongReferrablesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCoOwningReference(builder, coOwningReference) {
        builder.addFieldInt64(39, coOwningReference, BigInt('0'));
    }
    static addVectorOfCoOwningReferences(builder, vectorOfCoOwningReferencesOffset) {
        builder.addFieldOffset(40, vectorOfCoOwningReferencesOffset, 0);
    }
    static createVectorOfCoOwningReferencesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfCoOwningReferencesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addNonOwningReference(builder, nonOwningReference) {
        builder.addFieldInt64(41, nonOwningReference, BigInt('0'));
    }
    static addVectorOfNonOwningReferences(builder, vectorOfNonOwningReferencesOffset) {
        builder.addFieldOffset(42, vectorOfNonOwningReferencesOffset, 0);
    }
    static createVectorOfNonOwningReferencesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfNonOwningReferencesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addAnyUniqueType(builder, anyUniqueType) {
        builder.addFieldInt8(43, anyUniqueType, AnyUniqueAliases.NONE);
    }
    static addAnyUnique(builder, anyUniqueOffset) {
        builder.addFieldOffset(44, anyUniqueOffset, 0);
    }
    static addAnyAmbiguousType(builder, anyAmbiguousType) {
        builder.addFieldInt8(45, anyAmbiguousType, AnyAmbiguousAliases.NONE);
    }
    static addAnyAmbiguous(builder, anyAmbiguousOffset) {
        builder.addFieldOffset(46, anyAmbiguousOffset, 0);
    }
    static addVectorOfEnums(builder, vectorOfEnumsOffset) {
        builder.addFieldOffset(47, vectorOfEnumsOffset, 0);
    }
    static createVectorOfEnumsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startVectorOfEnumsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addSignedEnum(builder, signedEnum) {
        builder.addFieldInt8(48, signedEnum, Race.None);
    }
    static addTestrequirednestedflatbuffer(builder, testrequirednestedflatbufferOffset) {
        builder.addFieldOffset(49, testrequirednestedflatbufferOffset, 0);
    }
    static createTestrequirednestedflatbufferVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startTestrequirednestedflatbufferVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addScalarKeySortedTables(builder, scalarKeySortedTablesOffset) {
        builder.addFieldOffset(50, scalarKeySortedTablesOffset, 0);
    }
    static createScalarKeySortedTablesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startScalarKeySortedTablesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addNativeInline(builder, nativeInlineOffset) {
        builder.addFieldStruct(51, nativeInlineOffset, 0);
    }
    static addLongEnumNonEnumDefault(builder, longEnumNonEnumDefault) {
        builder.addFieldInt64(52, longEnumNonEnumDefault, BigInt('0'));
    }
    static addLongEnumNormalDefault(builder, longEnumNormalDefault) {
        builder.addFieldInt64(53, longEnumNormalDefault, BigInt('2'));
    }
    static addNanDefault(builder, nanDefault) {
        builder.addFieldFloat32(54, nanDefault, NaN);
    }
    static addInfDefault(builder, infDefault) {
        builder.addFieldFloat32(55, infDefault, Infinity);
    }
    static addPositiveInfDefault(builder, positiveInfDefault) {
        builder.addFieldFloat32(56, positiveInfDefault, Infinity);
    }
    static addInfinityDefault(builder, infinityDefault) {
        builder.addFieldFloat32(57, infinityDefault, Infinity);
    }
    static addPositiveInfinityDefault(builder, positiveInfinityDefault) {
        builder.addFieldFloat32(58, positiveInfinityDefault, Infinity);
    }
    static addNegativeInfDefault(builder, negativeInfDefault) {
        builder.addFieldFloat32(59, negativeInfDefault, -Infinity);
    }
    static addNegativeInfinityDefault(builder, negativeInfinityDefault) {
        builder.addFieldFloat32(60, negativeInfinityDefault, -Infinity);
    }
    static addDoubleInfDefault(builder, doubleInfDefault) {
        builder.addFieldFloat64(61, doubleInfDefault, Infinity);
    }
    static endMonster(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 10); // name
        return offset;
    }
    static finishMonsterBuffer(builder, offset) {
        builder.finish(offset, 'MONS');
    }
    static finishSizePrefixedMonsterBuffer(builder, offset) {
        builder.finish(offset, 'MONS', true);
    }
    serialize() {
        return this.bb.bytes();
    }
    static deserialize(buffer) {
        return Monster.getRootAsMonster(new flatbuffers.ByteBuffer(buffer));
    }
    unpack() {
        return new MonsterT((this.pos() !== null ? this.pos().unpack() : null), this.mana(), this.hp(), this.name(), this.bb.createScalarList(this.inventory.bind(this), this.inventoryLength()), this.color(), this.testType(), (() => {
            const temp = unionToAny(this.testType(), this.test.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.bb.createObjList(this.test4.bind(this), this.test4Length()), this.bb.createScalarList(this.testarrayofstring.bind(this), this.testarrayofstringLength()), this.bb.createObjList(this.testarrayoftables.bind(this), this.testarrayoftablesLength()), (this.enemy() !== null ? this.enemy().unpack() : null), this.bb.createScalarList(this.testnestedflatbuffer.bind(this), this.testnestedflatbufferLength()), (this.testempty() !== null ? this.testempty().unpack() : null), this.testbool(), this.testhashs32Fnv1(), this.testhashu32Fnv1(), this.testhashs64Fnv1(), this.testhashu64Fnv1(), this.testhashs32Fnv1a(), this.testhashu32Fnv1a(), this.testhashs64Fnv1a(), this.testhashu64Fnv1a(), this.bb.createScalarList(this.testarrayofbools.bind(this), this.testarrayofboolsLength()), this.testf(), this.testf2(), this.testf3(), this.bb.createScalarList(this.testarrayofstring2.bind(this), this.testarrayofstring2Length()), this.bb.createObjList(this.testarrayofsortedstruct.bind(this), this.testarrayofsortedstructLength()), this.bb.createScalarList(this.flex.bind(this), this.flexLength()), this.bb.createObjList(this.test5.bind(this), this.test5Length()), this.bb.createScalarList(this.vectorOfLongs.bind(this), this.vectorOfLongsLength()), this.bb.createScalarList(this.vectorOfDoubles.bind(this), this.vectorOfDoublesLength()), (this.parentNamespaceTest() !== null ? this.parentNamespaceTest().unpack() : null), this.bb.createObjList(this.vectorOfReferrables.bind(this), this.vectorOfReferrablesLength()), this.singleWeakReference(), this.bb.createScalarList(this.vectorOfWeakReferences.bind(this), this.vectorOfWeakReferencesLength()), this.bb.createObjList(this.vectorOfStrongReferrables.bind(this), this.vectorOfStrongReferrablesLength()), this.coOwningReference(), this.bb.createScalarList(this.vectorOfCoOwningReferences.bind(this), this.vectorOfCoOwningReferencesLength()), this.nonOwningReference(), this.bb.createScalarList(this.vectorOfNonOwningReferences.bind(this), this.vectorOfNonOwningReferencesLength()), this.anyUniqueType(), (() => {
            const temp = unionToAnyUniqueAliases(this.anyUniqueType(), this.anyUnique.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.anyAmbiguousType(), (() => {
            const temp = unionToAnyAmbiguousAliases(this.anyAmbiguousType(), this.anyAmbiguous.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), this.bb.createScalarList(this.vectorOfEnums.bind(this), this.vectorOfEnumsLength()), this.signedEnum(), this.bb.createScalarList(this.testrequirednestedflatbuffer.bind(this), this.testrequirednestedflatbufferLength()), this.bb.createObjList(this.scalarKeySortedTables.bind(this), this.scalarKeySortedTablesLength()), (this.nativeInline() !== null ? this.nativeInline().unpack() : null), this.longEnumNonEnumDefault(), this.longEnumNormalDefault(), this.nanDefault(), this.infDefault(), this.positiveInfDefault(), this.infinityDefault(), this.positiveInfinityDefault(), this.negativeInfDefault(), this.negativeInfinityDefault(), this.doubleInfDefault());
    }
    unpackTo(_o) {
        _o.pos = (this.pos() !== null ? this.pos().unpack() : null);
        _o.mana = this.mana();
        _o.hp = this.hp();
        _o.name = this.name();
        _o.inventory = this.bb.createScalarList(this.inventory.bind(this), this.inventoryLength());
        _o.color = this.color();
        _o.testType = this.testType();
        _o.test = (() => {
            const temp = unionToAny(this.testType(), this.test.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.test4 = this.bb.createObjList(this.test4.bind(this), this.test4Length());
        _o.testarrayofstring = this.bb.createScalarList(this.testarrayofstring.bind(this), this.testarrayofstringLength());
        _o.testarrayoftables = this.bb.createObjList(this.testarrayoftables.bind(this), this.testarrayoftablesLength());
        _o.enemy = (this.enemy() !== null ? this.enemy().unpack() : null);
        _o.testnestedflatbuffer = this.bb.createScalarList(this.testnestedflatbuffer.bind(this), this.testnestedflatbufferLength());
        _o.testempty = (this.testempty() !== null ? this.testempty().unpack() : null);
        _o.testbool = this.testbool();
        _o.testhashs32Fnv1 = this.testhashs32Fnv1();
        _o.testhashu32Fnv1 = this.testhashu32Fnv1();
        _o.testhashs64Fnv1 = this.testhashs64Fnv1();
        _o.testhashu64Fnv1 = this.testhashu64Fnv1();
        _o.testhashs32Fnv1a = this.testhashs32Fnv1a();
        _o.testhashu32Fnv1a = this.testhashu32Fnv1a();
        _o.testhashs64Fnv1a = this.testhashs64Fnv1a();
        _o.testhashu64Fnv1a = this.testhashu64Fnv1a();
        _o.testarrayofbools = this.bb.createScalarList(this.testarrayofbools.bind(this), this.testarrayofboolsLength());
        _o.testf = this.testf();
        _o.testf2 = this.testf2();
        _o.testf3 = this.testf3();
        _o.testarrayofstring2 = this.bb.createScalarList(this.testarrayofstring2.bind(this), this.testarrayofstring2Length());
        _o.testarrayofsortedstruct = this.bb.createObjList(this.testarrayofsortedstruct.bind(this), this.testarrayofsortedstructLength());
        _o.flex = this.bb.createScalarList(this.flex.bind(this), this.flexLength());
        _o.test5 = this.bb.createObjList(this.test5.bind(this), this.test5Length());
        _o.vectorOfLongs = this.bb.createScalarList(this.vectorOfLongs.bind(this), this.vectorOfLongsLength());
        _o.vectorOfDoubles = this.bb.createScalarList(this.vectorOfDoubles.bind(this), this.vectorOfDoublesLength());
        _o.parentNamespaceTest = (this.parentNamespaceTest() !== null ? this.parentNamespaceTest().unpack() : null);
        _o.vectorOfReferrables = this.bb.createObjList(this.vectorOfReferrables.bind(this), this.vectorOfReferrablesLength());
        _o.singleWeakReference = this.singleWeakReference();
        _o.vectorOfWeakReferences = this.bb.createScalarList(this.vectorOfWeakReferences.bind(this), this.vectorOfWeakReferencesLength());
        _o.vectorOfStrongReferrables = this.bb.createObjList(this.vectorOfStrongReferrables.bind(this), this.vectorOfStrongReferrablesLength());
        _o.coOwningReference = this.coOwningReference();
        _o.vectorOfCoOwningReferences = this.bb.createScalarList(this.vectorOfCoOwningReferences.bind(this), this.vectorOfCoOwningReferencesLength());
        _o.nonOwningReference = this.nonOwningReference();
        _o.vectorOfNonOwningReferences = this.bb.createScalarList(this.vectorOfNonOwningReferences.bind(this), this.vectorOfNonOwningReferencesLength());
        _o.anyUniqueType = this.anyUniqueType();
        _o.anyUnique = (() => {
            const temp = unionToAnyUniqueAliases(this.anyUniqueType(), this.anyUnique.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.anyAmbiguousType = this.anyAmbiguousType();
        _o.anyAmbiguous = (() => {
            const temp = unionToAnyAmbiguousAliases(this.anyAmbiguousType(), this.anyAmbiguous.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.vectorOfEnums = this.bb.createScalarList(this.vectorOfEnums.bind(this), this.vectorOfEnumsLength());
        _o.signedEnum = this.signedEnum();
        _o.testrequirednestedflatbuffer = this.bb.createScalarList(this.testrequirednestedflatbuffer.bind(this), this.testrequirednestedflatbufferLength());
        _o.scalarKeySortedTables = this.bb.createObjList(this.scalarKeySortedTables.bind(this), this.scalarKeySortedTablesLength());
        _o.nativeInline = (this.nativeInline() !== null ? this.nativeInline().unpack() : null);
        _o.longEnumNonEnumDefault = this.longEnumNonEnumDefault();
        _o.longEnumNormalDefault = this.longEnumNormalDefault();
        _o.nanDefault = this.nanDefault();
        _o.infDefault = this.infDefault();
        _o.positiveInfDefault = this.positiveInfDefault();
        _o.infinityDefault = this.infinityDefault();
        _o.positiveInfinityDefault = this.positiveInfinityDefault();
        _o.negativeInfDefault = this.negativeInfDefault();
        _o.negativeInfinityDefault = this.negativeInfinityDefault();
        _o.doubleInfDefault = this.doubleInfDefault();
    }
}
export class MonsterT {
    constructor(pos = null, mana = 150, hp = 100, name = null, inventory = [], color = Color.Blue, testType = Any.NONE, test = null, test4 = [], testarrayofstring = [], testarrayoftables = [], enemy = null, testnestedflatbuffer = [], testempty = null, testbool = false, testhashs32Fnv1 = 0, testhashu32Fnv1 = 0, testhashs64Fnv1 = BigInt('0'), testhashu64Fnv1 = BigInt('0'), testhashs32Fnv1a = 0, testhashu32Fnv1a = 0, testhashs64Fnv1a = BigInt('0'), testhashu64Fnv1a = BigInt('0'), testarrayofbools = [], testf = 3.14159, testf2 = 3.0, testf3 = 0.0, testarrayofstring2 = [], testarrayofsortedstruct = [], flex = [], test5 = [], vectorOfLongs = [], vectorOfDoubles = [], parentNamespaceTest = null, vectorOfReferrables = [], singleWeakReference = BigInt('0'), vectorOfWeakReferences = [], vectorOfStrongReferrables = [], coOwningReference = BigInt('0'), vectorOfCoOwningReferences = [], nonOwningReference = BigInt('0'), vectorOfNonOwningReferences = [], anyUniqueType = AnyUniqueAliases.NONE, anyUnique = null, anyAmbiguousType = AnyAmbiguousAliases.NONE, anyAmbiguous = null, vectorOfEnums = [], signedEnum = Race.None, testrequirednestedflatbuffer = [], scalarKeySortedTables = [], nativeInline = null, longEnumNonEnumDefault = BigInt('0'), longEnumNormalDefault = BigInt('2'), nanDefault = NaN, infDefault = Infinity, positiveInfDefault = Infinity, infinityDefault = Infinity, positiveInfinityDefault = Infinity, negativeInfDefault = -Infinity, negativeInfinityDefault = -Infinity, doubleInfDefault = Infinity) {
        this.pos = pos;
        this.mana = mana;
        this.hp = hp;
        this.name = name;
        this.inventory = inventory;
        this.color = color;
        this.testType = testType;
        this.test = test;
        this.test4 = test4;
        this.testarrayofstring = testarrayofstring;
        this.testarrayoftables = testarrayoftables;
        this.enemy = enemy;
        this.testnestedflatbuffer = testnestedflatbuffer;
        this.testempty = testempty;
        this.testbool = testbool;
        this.testhashs32Fnv1 = testhashs32Fnv1;
        this.testhashu32Fnv1 = testhashu32Fnv1;
        this.testhashs64Fnv1 = testhashs64Fnv1;
        this.testhashu64Fnv1 = testhashu64Fnv1;
        this.testhashs32Fnv1a = testhashs32Fnv1a;
        this.testhashu32Fnv1a = testhashu32Fnv1a;
        this.testhashs64Fnv1a = testhashs64Fnv1a;
        this.testhashu64Fnv1a = testhashu64Fnv1a;
        this.testarrayofbools = testarrayofbools;
        this.testf = testf;
        this.testf2 = testf2;
        this.testf3 = testf3;
        this.testarrayofstring2 = testarrayofstring2;
        this.testarrayofsortedstruct = testarrayofsortedstruct;
        this.flex = flex;
        this.test5 = test5;
        this.vectorOfLongs = vectorOfLongs;
        this.vectorOfDoubles = vectorOfDoubles;
        this.parentNamespaceTest = parentNamespaceTest;
        this.vectorOfReferrables = vectorOfReferrables;
        this.singleWeakReference = singleWeakReference;
        this.vectorOfWeakReferences = vectorOfWeakReferences;
        this.vectorOfStrongReferrables = vectorOfStrongReferrables;
        this.coOwningReference = coOwningReference;
        this.vectorOfCoOwningReferences = vectorOfCoOwningReferences;
        this.nonOwningReference = nonOwningReference;
        this.vectorOfNonOwningReferences = vectorOfNonOwningReferences;
        this.anyUniqueType = anyUniqueType;
        this.anyUnique = anyUnique;
        this.anyAmbiguousType = anyAmbiguousType;
        this.anyAmbiguous = anyAmbiguous;
        this.vectorOfEnums = vectorOfEnums;
        this.signedEnum = signedEnum;
        this.testrequirednestedflatbuffer = testrequirednestedflatbuffer;
        this.scalarKeySortedTables = scalarKeySortedTables;
        this.nativeInline = nativeInline;
        this.longEnumNonEnumDefault = longEnumNonEnumDefault;
        this.longEnumNormalDefault = longEnumNormalDefault;
        this.nanDefault = nanDefault;
        this.infDefault = infDefault;
        this.positiveInfDefault = positiveInfDefault;
        this.infinityDefault = infinityDefault;
        this.positiveInfinityDefault = positiveInfinityDefault;
        this.negativeInfDefault = negativeInfDefault;
        this.negativeInfinityDefault = negativeInfinityDefault;
        this.doubleInfDefault = doubleInfDefault;
    }
    pack(builder) {
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const inventory = Monster.createInventoryVector(builder, this.inventory);
        const test = builder.createObjectOffset(this.test);
        const test4 = builder.createStructOffsetList(this.test4, Monster.startTest4Vector);
        const testarrayofstring = Monster.createTestarrayofstringVector(builder, builder.createObjectOffsetList(this.testarrayofstring));
        const testarrayoftables = Monster.createTestarrayoftablesVector(builder, builder.createObjectOffsetList(this.testarrayoftables));
        const enemy = (this.enemy !== null ? this.enemy.pack(builder) : 0);
        const testnestedflatbuffer = Monster.createTestnestedflatbufferVector(builder, this.testnestedflatbuffer);
        const testempty = (this.testempty !== null ? this.testempty.pack(builder) : 0);
        const testarrayofbools = Monster.createTestarrayofboolsVector(builder, this.testarrayofbools);
        const testarrayofstring2 = Monster.createTestarrayofstring2Vector(builder, builder.createObjectOffsetList(this.testarrayofstring2));
        const testarrayofsortedstruct = builder.createStructOffsetList(this.testarrayofsortedstruct, Monster.startTestarrayofsortedstructVector);
        const flex = Monster.createFlexVector(builder, this.flex);
        const test5 = builder.createStructOffsetList(this.test5, Monster.startTest5Vector);
        const vectorOfLongs = Monster.createVectorOfLongsVector(builder, this.vectorOfLongs);
        const vectorOfDoubles = Monster.createVectorOfDoublesVector(builder, this.vectorOfDoubles);
        const parentNamespaceTest = (this.parentNamespaceTest !== null ? this.parentNamespaceTest.pack(builder) : 0);
        const vectorOfReferrables = Monster.createVectorOfReferrablesVector(builder, builder.createObjectOffsetList(this.vectorOfReferrables));
        const vectorOfWeakReferences = Monster.createVectorOfWeakReferencesVector(builder, this.vectorOfWeakReferences);
        const vectorOfStrongReferrables = Monster.createVectorOfStrongReferrablesVector(builder, builder.createObjectOffsetList(this.vectorOfStrongReferrables));
        const vectorOfCoOwningReferences = Monster.createVectorOfCoOwningReferencesVector(builder, this.vectorOfCoOwningReferences);
        const vectorOfNonOwningReferences = Monster.createVectorOfNonOwningReferencesVector(builder, this.vectorOfNonOwningReferences);
        const anyUnique = builder.createObjectOffset(this.anyUnique);
        const anyAmbiguous = builder.createObjectOffset(this.anyAmbiguous);
        const vectorOfEnums = Monster.createVectorOfEnumsVector(builder, this.vectorOfEnums);
        const testrequirednestedflatbuffer = Monster.createTestrequirednestedflatbufferVector(builder, this.testrequirednestedflatbuffer);
        const scalarKeySortedTables = Monster.createScalarKeySortedTablesVector(builder, builder.createObjectOffsetList(this.scalarKeySortedTables));
        Monster.startMonster(builder);
        Monster.addPos(builder, (this.pos !== null ? this.pos.pack(builder) : 0));
        Monster.addMana(builder, this.mana);
        Monster.addHp(builder, this.hp);
        Monster.addName(builder, name);
        Monster.addInventory(builder, inventory);
        Monster.addColor(builder, this.color);
        Monster.addTestType(builder, this.testType);
        Monster.addTest(builder, test);
        Monster.addTest4(builder, test4);
        Monster.addTestarrayofstring(builder, testarrayofstring);
        Monster.addTestarrayoftables(builder, testarrayoftables);
        Monster.addEnemy(builder, enemy);
        Monster.addTestnestedflatbuffer(builder, testnestedflatbuffer);
        Monster.addTestempty(builder, testempty);
        Monster.addTestbool(builder, this.testbool);
        Monster.addTesthashs32Fnv1(builder, this.testhashs32Fnv1);
        Monster.addTesthashu32Fnv1(builder, this.testhashu32Fnv1);
        Monster.addTesthashs64Fnv1(builder, this.testhashs64Fnv1);
        Monster.addTesthashu64Fnv1(builder, this.testhashu64Fnv1);
        Monster.addTesthashs32Fnv1a(builder, this.testhashs32Fnv1a);
        Monster.addTesthashu32Fnv1a(builder, this.testhashu32Fnv1a);
        Monster.addTesthashs64Fnv1a(builder, this.testhashs64Fnv1a);
        Monster.addTesthashu64Fnv1a(builder, this.testhashu64Fnv1a);
        Monster.addTestarrayofbools(builder, testarrayofbools);
        Monster.addTestf(builder, this.testf);
        Monster.addTestf2(builder, this.testf2);
        Monster.addTestf3(builder, this.testf3);
        Monster.addTestarrayofstring2(builder, testarrayofstring2);
        Monster.addTestarrayofsortedstruct(builder, testarrayofsortedstruct);
        Monster.addFlex(builder, flex);
        Monster.addTest5(builder, test5);
        Monster.addVectorOfLongs(builder, vectorOfLongs);
        Monster.addVectorOfDoubles(builder, vectorOfDoubles);
        Monster.addParentNamespaceTest(builder, parentNamespaceTest);
        Monster.addVectorOfReferrables(builder, vectorOfReferrables);
        Monster.addSingleWeakReference(builder, this.singleWeakReference);
        Monster.addVectorOfWeakReferences(builder, vectorOfWeakReferences);
        Monster.addVectorOfStrongReferrables(builder, vectorOfStrongReferrables);
        Monster.addCoOwningReference(builder, this.coOwningReference);
        Monster.addVectorOfCoOwningReferences(builder, vectorOfCoOwningReferences);
        Monster.addNonOwningReference(builder, this.nonOwningReference);
        Monster.addVectorOfNonOwningReferences(builder, vectorOfNonOwningReferences);
        Monster.addAnyUniqueType(builder, this.anyUniqueType);
        Monster.addAnyUnique(builder, anyUnique);
        Monster.addAnyAmbiguousType(builder, this.anyAmbiguousType);
        Monster.addAnyAmbiguous(builder, anyAmbiguous);
        Monster.addVectorOfEnums(builder, vectorOfEnums);
        Monster.addSignedEnum(builder, this.signedEnum);
        Monster.addTestrequirednestedflatbuffer(builder, testrequirednestedflatbuffer);
        Monster.addScalarKeySortedTables(builder, scalarKeySortedTables);
        Monster.addNativeInline(builder, (this.nativeInline !== null ? this.nativeInline.pack(builder) : 0));
        Monster.addLongEnumNonEnumDefault(builder, this.longEnumNonEnumDefault);
        Monster.addLongEnumNormalDefault(builder, this.longEnumNormalDefault);
        Monster.addNanDefault(builder, this.nanDefault);
        Monster.addInfDefault(builder, this.infDefault);
        Monster.addPositiveInfDefault(builder, this.positiveInfDefault);
        Monster.addInfinityDefault(builder, this.infinityDefault);
        Monster.addPositiveInfinityDefault(builder, this.positiveInfinityDefault);
        Monster.addNegativeInfDefault(builder, this.negativeInfDefault);
        Monster.addNegativeInfinityDefault(builder, this.negativeInfinityDefault);
        Monster.addDoubleInfDefault(builder, this.doubleInfDefault);
        return Monster.endMonster(builder);
    }
}

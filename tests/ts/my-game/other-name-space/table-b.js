// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { TableA } from '../../table-a.js';
export class TableB {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTableB(bb, obj) {
        return (obj || new TableB()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTableB(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TableB()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    a(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new TableA()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static getFullyQualifiedName() {
        return 'MyGame.OtherNameSpace.TableB';
    }
    static startTableB(builder) {
        builder.startObject(1);
    }
    static addA(builder, aOffset) {
        builder.addFieldOffset(0, aOffset, 0);
    }
    static endTableB(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTableB(builder, aOffset) {
        TableB.startTableB(builder);
        TableB.addA(builder, aOffset);
        return TableB.endTableB(builder);
    }
    serialize() {
        return this.bb.bytes();
    }
    static deserialize(buffer) {
        return TableB.getRootAsTableB(new flatbuffers.ByteBuffer(buffer));
    }
    unpack() {
        return new TableBT((this.a() !== null ? this.a().unpack() : null));
    }
    unpackTo(_o) {
        _o.a = (this.a() !== null ? this.a().unpack() : null);
    }
}
export class TableBT {
    constructor(a = null) {
        this.a = a;
    }
    pack(builder) {
        const a = (this.a !== null ? this.a.pack(builder) : 0);
        return TableB.createTableB(builder, a);
    }
}

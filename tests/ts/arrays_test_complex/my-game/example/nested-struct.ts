// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { OuterStruct, OuterStructT } from '../../my-game/example/outer-struct.js';
import { TestEnum } from '../../my-game/example/test-enum.js';


export class NestedStruct implements flatbuffers.IUnpackableObject<NestedStructT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):NestedStruct {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

a(index: number):number|null {
    return this.bb!.readInt32(this.bb_pos + 0 + index * 4);
}

b():TestEnum {
  return this.bb!.readInt8(this.bb_pos + 8);
}

cUnderscore(index: number):TestEnum|null {
    return this.bb!.readInt8(this.bb_pos + 9 + index);
}

dOuter(index: number, obj?:OuterStruct):OuterStruct|null {
    return (obj || new OuterStruct()).__init(this.bb_pos + 16 + index * 208, this.bb!);
}

e(index: number):bigint|null {
    return this.bb!.readInt64(this.bb_pos + 1056 + index * 8);
}

static getFullyQualifiedName():string {
  return 'MyGame.Example.NestedStruct';
}

static sizeOf():number {
  return 1072;
}

static createNestedStruct(builder:flatbuffers.Builder, a: number[]|null, b: TestEnum, c_underscore: number[]|null, d_outer: (any|OuterStructT)[]|null, e: bigint[]|null):flatbuffers.Offset {
  builder.prep(8, 1072);

  for (let i = 1; i >= 0; --i) {
    builder.writeInt64(BigInt(e?.[i] ?? 0));
  }


  for (let i = 4; i >= 0; --i) {
    const item = d_outer?.[i];

    if (item instanceof OuterStructT) {
      item.pack(builder);
      continue;
    }

    OuterStruct.createOuterStruct(builder,
    item?.a,
    item?.b,
    (item?.cUnderscore?.a ?? 0),
    (item?.cUnderscore?.b ?? []),
    (item?.cUnderscore?.c ?? 0),
    (item?.cUnderscore?.dUnderscore ?? BigInt(0)),
    item?.d,
    (item?.e?.a ?? 0),
    (item?.e?.b ?? []),
    (item?.e?.c ?? 0),
    (item?.e?.dUnderscore ?? BigInt(0)),
    item?.f
    );
  }

  builder.pad(5);

  for (let i = 1; i >= 0; --i) {
    builder.writeInt8((c_underscore?.[i] ?? 0));

  }

  builder.writeInt8(b);

  for (let i = 1; i >= 0; --i) {
    builder.writeInt32((a?.[i] ?? 0));

  }

  return builder.offset();
}


unpack(): NestedStructT {
  return new NestedStructT(
    this.bb!.createScalarList<number>(this.a.bind(this), 2),
    this.b(),
    this.bb!.createScalarList<TestEnum>(this.cUnderscore.bind(this), 2),
    this.bb!.createObjList<OuterStruct, OuterStructT>(this.dOuter.bind(this), 5),
    this.bb!.createScalarList<bigint>(this.e.bind(this), 2)
  );
}


unpackTo(_o: NestedStructT): void {
  _o.a = this.bb!.createScalarList<number>(this.a.bind(this), 2);
  _o.b = this.b();
  _o.cUnderscore = this.bb!.createScalarList<TestEnum>(this.cUnderscore.bind(this), 2);
  _o.dOuter = this.bb!.createObjList<OuterStruct, OuterStructT>(this.dOuter.bind(this), 5);
  _o.e = this.bb!.createScalarList<bigint>(this.e.bind(this), 2);
}
}

export class NestedStructT implements flatbuffers.IGeneratedObject {
constructor(
  public a: (number)[] = [],
  public b: TestEnum = TestEnum.A,
  public cUnderscore: (TestEnum)[] = [TestEnum.A, TestEnum.A],
  public dOuter: (OuterStructT)[] = [],
  public e: (bigint)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return NestedStruct.createNestedStruct(builder,
    this.a,
    this.b,
    this.cUnderscore,
    this.dOuter,
    this.e
  );
}
}

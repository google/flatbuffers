// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEFAULTVECTORSSTRINGSTEST_DEFAULTVECTORSSTRINGSTEST_H_
#define FLATBUFFERS_GENERATED_DEFAULTVECTORSSTRINGSTEST_DEFAULTVECTORSSTRINGSTEST_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace DefaultVectorsStringsTest {

struct MyStruct;

struct MyTable;
struct MyTableBuilder;
struct MyTableT;

struct TableWithDefaultVectors;
struct TableWithDefaultVectorsBuilder;
struct TableWithDefaultVectorsT;

bool operator==(const MyStruct &lhs, const MyStruct &rhs);
bool operator!=(const MyStruct &lhs, const MyStruct &rhs);
bool operator==(const MyTableT &lhs, const MyTableT &rhs);
bool operator!=(const MyTableT &lhs, const MyTableT &rhs);
bool operator==(const TableWithDefaultVectorsT &lhs, const TableWithDefaultVectorsT &rhs);
bool operator!=(const TableWithDefaultVectorsT &lhs, const TableWithDefaultVectorsT &rhs);

inline const ::flatbuffers::TypeTable *MyStructTypeTable();

inline const ::flatbuffers::TypeTable *MyTableTypeTable();

inline const ::flatbuffers::TypeTable *TableWithDefaultVectorsTypeTable();

enum MyEnum : int8_t {
  MyEnum_A = 0,
  MyEnum_B = 1,
  MyEnum_MIN = MyEnum_A,
  MyEnum_MAX = MyEnum_B
};

inline const MyEnum (&EnumValuesMyEnum())[2] {
  static const MyEnum values[] = {
    MyEnum_A,
    MyEnum_B
  };
  return values;
}

inline const char * const *EnumNamesMyEnum() {
  static const char * const names[3] = {
    "A",
    "B",
    nullptr
  };
  return names;
}

inline const char *EnumNameMyEnum(MyEnum e) {
  if (::flatbuffers::IsOutRange(e, MyEnum_A, MyEnum_B)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMyEnum()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MyStruct FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t a_;
  int32_t b_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyStructTypeTable();
  }
  MyStruct()
      : a_(0),
        b_(0) {
  }
  MyStruct(int32_t _a, int32_t _b)
      : a_(::flatbuffers::EndianScalar(_a)),
        b_(::flatbuffers::EndianScalar(_b)) {
  }
  int32_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  void mutate_a(int32_t _a) {
    ::flatbuffers::WriteScalar(&a_, _a);
  }
  int32_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
  void mutate_b(int32_t _b) {
    ::flatbuffers::WriteScalar(&b_, _b);
  }
};
FLATBUFFERS_STRUCT_END(MyStruct, 8);

inline bool operator==(const MyStruct &lhs, const MyStruct &rhs) {
  return
      (lhs.a() == rhs.a()) &&
      (lhs.b() == rhs.b());
}

inline bool operator!=(const MyStruct &lhs, const MyStruct &rhs) {
    return !(lhs == rhs);
}

template <typename H>
inline H AbslHashValue(H h, const MyStruct &obj) {
  return H::combine(std::move(h), obj.a(), obj.b());
}

struct MyTableT : public ::flatbuffers::NativeTable {
  typedef MyTable TableType;
  int32_t a = 0;
};

struct MyTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MyTableT NativeTableType;
  typedef MyTableBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyTableTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool mutate_a(int32_t _a = 0) {
    return SetField<int32_t>(VT_A, _a, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           verifier.EndTable();
  }
  MyTableT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MyTableT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MyTable> Pack(::flatbuffers::FlatBufferBuilder64 &_fbb, const MyTableT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MyTableBuilder {
  typedef MyTable Table;
  ::flatbuffers::FlatBufferBuilder64 &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(MyTable::VT_A, a, 0);
  }
  explicit MyTableBuilder(::flatbuffers::FlatBufferBuilder64 &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MyTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MyTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MyTable> CreateMyTable(
    ::flatbuffers::FlatBufferBuilder64 &_fbb,
    int32_t a = 0) {
  MyTableBuilder builder_(_fbb);
  builder_.add_a(a);
  return builder_.Finish();
}

::flatbuffers::Offset<MyTable> CreateMyTable(::flatbuffers::FlatBufferBuilder64 &_fbb, const MyTableT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TableWithDefaultVectorsT : public ::flatbuffers::NativeTable {
  typedef TableWithDefaultVectors TableType;
  std::vector<int32_t> int_vec{};
  std::vector<bool> bool_vec{};
  std::vector<int8_t> char_vec{};
  std::vector<uint8_t> uchar_vec{};
  std::vector<int16_t> short_vec{};
  std::vector<uint16_t> ushort_vec{};
  std::vector<uint32_t> uint_vec{};
  std::vector<int64_t> long_vec{};
  std::vector<uint64_t> ulong_vec{};
  std::vector<float> float_vec{};
  std::vector<double> double_vec{};
  std::vector<std::string> string_vec{};
  std::string empty_string{};
  std::string some_string{};
  std::vector<DefaultVectorsStringsTest::MyStruct> struct_vec{};
  std::vector<std::unique_ptr<DefaultVectorsStringsTest::MyTableT>> table_vec{};
  std::vector<DefaultVectorsStringsTest::MyEnum> enum_vec{};
  std::vector<int32_t> regular_int_vec{};
  int32_t regular_int = 0;
  std::vector<int32_t> int_vec_offset64{};
  std::vector<int32_t> int_vec64{};
  TableWithDefaultVectorsT() = default;
  TableWithDefaultVectorsT(const TableWithDefaultVectorsT &o);
  TableWithDefaultVectorsT(TableWithDefaultVectorsT&&) FLATBUFFERS_NOEXCEPT = default;
  TableWithDefaultVectorsT &operator=(TableWithDefaultVectorsT o) FLATBUFFERS_NOEXCEPT;
};

struct TableWithDefaultVectors FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TableWithDefaultVectorsT NativeTableType;
  typedef TableWithDefaultVectorsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TableWithDefaultVectorsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT_VEC = 4,
    VT_BOOL_VEC = 6,
    VT_CHAR_VEC = 8,
    VT_UCHAR_VEC = 10,
    VT_SHORT_VEC = 12,
    VT_USHORT_VEC = 14,
    VT_UINT_VEC = 16,
    VT_LONG_VEC = 18,
    VT_ULONG_VEC = 20,
    VT_FLOAT_VEC = 22,
    VT_DOUBLE_VEC = 24,
    VT_STRING_VEC = 26,
    VT_EMPTY_STRING = 28,
    VT_SOME_STRING = 30,
    VT_STRUCT_VEC = 32,
    VT_TABLE_VEC = 34,
    VT_ENUM_VEC = 36,
    VT_REGULAR_INT_VEC = 38,
    VT_REGULAR_INT = 40,
    VT_INT_VEC_OFFSET64 = 42,
    VT_INT_VEC64 = 44
  };
  const ::flatbuffers::Vector<int32_t> *int_vec() const {
    return GetVectorPointerOrEmpty<int32_t>(VT_INT_VEC);
  }
  ::flatbuffers::Vector<int32_t> *mutable_int_vec() {
    return GetMutableVectorPointerOrEmpty<int32_t>(VT_INT_VEC);
  }
  const ::flatbuffers::Vector<uint8_t> *bool_vec() const {
    return GetVectorPointerOrEmpty<uint8_t>(VT_BOOL_VEC);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_bool_vec() {
    return GetMutableVectorPointerOrEmpty<uint8_t>(VT_BOOL_VEC);
  }
  const ::flatbuffers::Vector<int8_t> *char_vec() const {
    return GetVectorPointerOrEmpty<int8_t>(VT_CHAR_VEC);
  }
  ::flatbuffers::Vector<int8_t> *mutable_char_vec() {
    return GetMutableVectorPointerOrEmpty<int8_t>(VT_CHAR_VEC);
  }
  const ::flatbuffers::Vector<uint8_t> *uchar_vec() const {
    return GetVectorPointerOrEmpty<uint8_t>(VT_UCHAR_VEC);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_uchar_vec() {
    return GetMutableVectorPointerOrEmpty<uint8_t>(VT_UCHAR_VEC);
  }
  const ::flatbuffers::Vector<int16_t> *short_vec() const {
    return GetVectorPointerOrEmpty<int16_t>(VT_SHORT_VEC);
  }
  ::flatbuffers::Vector<int16_t> *mutable_short_vec() {
    return GetMutableVectorPointerOrEmpty<int16_t>(VT_SHORT_VEC);
  }
  const ::flatbuffers::Vector<uint16_t> *ushort_vec() const {
    return GetVectorPointerOrEmpty<uint16_t>(VT_USHORT_VEC);
  }
  ::flatbuffers::Vector<uint16_t> *mutable_ushort_vec() {
    return GetMutableVectorPointerOrEmpty<uint16_t>(VT_USHORT_VEC);
  }
  const ::flatbuffers::Vector<uint32_t> *uint_vec() const {
    return GetVectorPointerOrEmpty<uint32_t>(VT_UINT_VEC);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_uint_vec() {
    return GetMutableVectorPointerOrEmpty<uint32_t>(VT_UINT_VEC);
  }
  const ::flatbuffers::Vector<int64_t> *long_vec() const {
    return GetVectorPointerOrEmpty<int64_t>(VT_LONG_VEC);
  }
  ::flatbuffers::Vector<int64_t> *mutable_long_vec() {
    return GetMutableVectorPointerOrEmpty<int64_t>(VT_LONG_VEC);
  }
  const ::flatbuffers::Vector<uint64_t> *ulong_vec() const {
    return GetVectorPointerOrEmpty<uint64_t>(VT_ULONG_VEC);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_ulong_vec() {
    return GetMutableVectorPointerOrEmpty<uint64_t>(VT_ULONG_VEC);
  }
  const ::flatbuffers::Vector<float> *float_vec() const {
    return GetVectorPointerOrEmpty<float>(VT_FLOAT_VEC);
  }
  ::flatbuffers::Vector<float> *mutable_float_vec() {
    return GetMutableVectorPointerOrEmpty<float>(VT_FLOAT_VEC);
  }
  const ::flatbuffers::Vector<double> *double_vec() const {
    return GetVectorPointerOrEmpty<double>(VT_DOUBLE_VEC);
  }
  ::flatbuffers::Vector<double> *mutable_double_vec() {
    return GetMutableVectorPointerOrEmpty<double>(VT_DOUBLE_VEC);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_vec() const {
    return GetVectorPointerOrEmpty<::flatbuffers::Offset<::flatbuffers::String>>(VT_STRING_VEC);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_string_vec() {
    return GetMutableVectorPointerOrEmpty<::flatbuffers::Offset<::flatbuffers::String>>(VT_STRING_VEC);
  }
  const ::flatbuffers::String *empty_string() const {
    auto* ptr = GetPointer<const ::flatbuffers::String *>(VT_EMPTY_STRING);
    if (ptr) return ptr;
    static const struct { uint32_t len; const char s[1]; } bfbs_string = { 0, "" };
    return reinterpret_cast<const ::flatbuffers::String  *>(&bfbs_string);
  }
  ::flatbuffers::String *mutable_empty_string() {
    return GetPointer<::flatbuffers::String *>(VT_EMPTY_STRING);
  }
  const ::flatbuffers::String *some_string() const {
    auto* ptr = GetPointer<const ::flatbuffers::String *>(VT_SOME_STRING);
    if (ptr) return ptr;
    static const struct { uint32_t len; const char s[5]; } bfbs_string = { 4, "some" };
    return reinterpret_cast<const ::flatbuffers::String  *>(&bfbs_string);
  }
  ::flatbuffers::String *mutable_some_string() {
    return GetPointer<::flatbuffers::String *>(VT_SOME_STRING);
  }
  const ::flatbuffers::Vector<const DefaultVectorsStringsTest::MyStruct *> *struct_vec() const {
    return GetVectorPointerOrEmpty<const DefaultVectorsStringsTest::MyStruct *>(VT_STRUCT_VEC);
  }
  ::flatbuffers::Vector<const DefaultVectorsStringsTest::MyStruct *> *mutable_struct_vec() {
    return GetMutableVectorPointerOrEmpty<const DefaultVectorsStringsTest::MyStruct *>(VT_STRUCT_VEC);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>> *table_vec() const {
    return GetVectorPointerOrEmpty<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>>(VT_TABLE_VEC);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>> *mutable_table_vec() {
    return GetMutableVectorPointerOrEmpty<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>>(VT_TABLE_VEC);
  }
  const ::flatbuffers::Vector<int8_t> *enum_vec() const {
    return GetVectorPointerOrEmpty<int8_t>(VT_ENUM_VEC);
  }
  ::flatbuffers::Vector<int8_t> *mutable_enum_vec() {
    return GetMutableVectorPointerOrEmpty<int8_t>(VT_ENUM_VEC);
  }
  const ::flatbuffers::Vector<int32_t> *regular_int_vec() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_REGULAR_INT_VEC);
  }
  ::flatbuffers::Vector<int32_t> *mutable_regular_int_vec() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_REGULAR_INT_VEC);
  }
  int32_t regular_int() const {
    return GetField<int32_t>(VT_REGULAR_INT, 0);
  }
  bool mutate_regular_int(int32_t _regular_int = 0) {
    return SetField<int32_t>(VT_REGULAR_INT, _regular_int, 0);
  }
  const ::flatbuffers::Vector<int32_t> *int_vec_offset64() const {
    return GetVectorPointer64OrEmpty<int32_t>(VT_INT_VEC_OFFSET64);
  }
  ::flatbuffers::Vector<int32_t> *mutable_int_vec_offset64() {
    return GetMutableVectorPointer64OrEmpty<int32_t>(VT_INT_VEC_OFFSET64);
  }
  const ::flatbuffers::Vector64<int32_t> *int_vec64() const {
    return GetVectorPointer64OrEmpty<int32_t, ::flatbuffers::uoffset64_t>(VT_INT_VEC64);
  }
  ::flatbuffers::Vector64<int32_t> *mutable_int_vec64() {
    return GetMutableVectorPointer64OrEmpty<int32_t, ::flatbuffers::uoffset64_t>(VT_INT_VEC64);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INT_VEC) &&
           VerifyVectorWithDefault<int32_t>(verifier, VT_INT_VEC) &&
           VerifyOffset(verifier, VT_BOOL_VEC) &&
           VerifyVectorWithDefault<uint8_t>(verifier, VT_BOOL_VEC) &&
           VerifyOffset(verifier, VT_CHAR_VEC) &&
           VerifyVectorWithDefault<int8_t>(verifier, VT_CHAR_VEC) &&
           VerifyOffset(verifier, VT_UCHAR_VEC) &&
           VerifyVectorWithDefault<uint8_t>(verifier, VT_UCHAR_VEC) &&
           VerifyOffset(verifier, VT_SHORT_VEC) &&
           VerifyVectorWithDefault<int16_t>(verifier, VT_SHORT_VEC) &&
           VerifyOffset(verifier, VT_USHORT_VEC) &&
           VerifyVectorWithDefault<uint16_t>(verifier, VT_USHORT_VEC) &&
           VerifyOffset(verifier, VT_UINT_VEC) &&
           VerifyVectorWithDefault<uint32_t>(verifier, VT_UINT_VEC) &&
           VerifyOffset(verifier, VT_LONG_VEC) &&
           VerifyVectorWithDefault<int64_t>(verifier, VT_LONG_VEC) &&
           VerifyOffset(verifier, VT_ULONG_VEC) &&
           VerifyVectorWithDefault<uint64_t>(verifier, VT_ULONG_VEC) &&
           VerifyOffset(verifier, VT_FLOAT_VEC) &&
           VerifyVectorWithDefault<float>(verifier, VT_FLOAT_VEC) &&
           VerifyOffset(verifier, VT_DOUBLE_VEC) &&
           VerifyVectorWithDefault<double>(verifier, VT_DOUBLE_VEC) &&
           VerifyOffset(verifier, VT_STRING_VEC) &&
           VerifyVectorWithDefault<::flatbuffers::Offset<::flatbuffers::String>>(verifier, VT_STRING_VEC) &&
           verifier.VerifyVectorOfStrings(string_vec()) &&
           VerifyOffset(verifier, VT_EMPTY_STRING) &&
           VerifyStringWithDefault(verifier, VT_EMPTY_STRING) &&
           VerifyOffset(verifier, VT_SOME_STRING) &&
           VerifyStringWithDefault(verifier, VT_SOME_STRING) &&
           VerifyOffset(verifier, VT_STRUCT_VEC) &&
           VerifyVectorWithDefault<const DefaultVectorsStringsTest::MyStruct *>(verifier, VT_STRUCT_VEC) &&
           VerifyOffset(verifier, VT_TABLE_VEC) &&
           VerifyVectorWithDefault<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>>(verifier, VT_TABLE_VEC) &&
           verifier.VerifyVectorOfTables(table_vec()) &&
           VerifyOffset(verifier, VT_ENUM_VEC) &&
           VerifyVectorWithDefault<int8_t>(verifier, VT_ENUM_VEC) &&
           VerifyOffset(verifier, VT_REGULAR_INT_VEC) &&
           verifier.VerifyVector(regular_int_vec()) &&
           VerifyField<int32_t>(verifier, VT_REGULAR_INT, 4) &&
           VerifyOffset64(verifier, VT_INT_VEC_OFFSET64) &&
           VerifyVector64WithDefault<int32_t>(verifier, VT_INT_VEC_OFFSET64) &&
           VerifyOffset64(verifier, VT_INT_VEC64) &&
           VerifyVector64WithDefault<int32_t, ::flatbuffers::uoffset64_t>(verifier, VT_INT_VEC64) &&
           verifier.EndTable();
  }
  TableWithDefaultVectorsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TableWithDefaultVectorsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TableWithDefaultVectors> Pack(::flatbuffers::FlatBufferBuilder64 &_fbb, const TableWithDefaultVectorsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TableWithDefaultVectorsBuilder {
  typedef TableWithDefaultVectors Table;
  ::flatbuffers::FlatBufferBuilder64 &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_int_vec(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> int_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_INT_VEC, int_vec);
  }
  void add_bool_vec(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bool_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_BOOL_VEC, bool_vec);
  }
  void add_char_vec(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> char_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_CHAR_VEC, char_vec);
  }
  void add_uchar_vec(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> uchar_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_UCHAR_VEC, uchar_vec);
  }
  void add_short_vec(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> short_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_SHORT_VEC, short_vec);
  }
  void add_ushort_vec(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> ushort_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_USHORT_VEC, ushort_vec);
  }
  void add_uint_vec(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> uint_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_UINT_VEC, uint_vec);
  }
  void add_long_vec(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> long_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_LONG_VEC, long_vec);
  }
  void add_ulong_vec(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> ulong_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_ULONG_VEC, ulong_vec);
  }
  void add_float_vec(::flatbuffers::Offset<::flatbuffers::Vector<float>> float_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_FLOAT_VEC, float_vec);
  }
  void add_double_vec(::flatbuffers::Offset<::flatbuffers::Vector<double>> double_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_DOUBLE_VEC, double_vec);
  }
  void add_string_vec(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_STRING_VEC, string_vec);
  }
  void add_empty_string(::flatbuffers::Offset<::flatbuffers::String> empty_string) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_EMPTY_STRING, empty_string);
  }
  void add_some_string(::flatbuffers::Offset<::flatbuffers::String> some_string) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_SOME_STRING, some_string);
  }
  void add_struct_vec(::flatbuffers::Offset<::flatbuffers::Vector<const DefaultVectorsStringsTest::MyStruct *>> struct_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_STRUCT_VEC, struct_vec);
  }
  void add_table_vec(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>>> table_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_TABLE_VEC, table_vec);
  }
  void add_enum_vec(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> enum_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_ENUM_VEC, enum_vec);
  }
  void add_regular_int_vec(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> regular_int_vec) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_REGULAR_INT_VEC, regular_int_vec);
  }
  void add_regular_int(int32_t regular_int) {
    fbb_.AddElement<int32_t>(TableWithDefaultVectors::VT_REGULAR_INT, regular_int, 0);
  }
  void add_int_vec_offset64(::flatbuffers::Offset64<::flatbuffers::Vector<int32_t>> int_vec_offset64) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_INT_VEC_OFFSET64, int_vec_offset64);
  }
  void add_int_vec64(::flatbuffers::Offset64<::flatbuffers::Vector64<int32_t>> int_vec64) {
    fbb_.AddOffset(TableWithDefaultVectors::VT_INT_VEC64, int_vec64);
  }
  explicit TableWithDefaultVectorsBuilder(::flatbuffers::FlatBufferBuilder64 &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TableWithDefaultVectors> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TableWithDefaultVectors>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TableWithDefaultVectors> CreateTableWithDefaultVectors(
    ::flatbuffers::FlatBufferBuilder64 &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> int_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> bool_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> char_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> uchar_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> short_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> ushort_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> uint_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> long_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> ulong_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> float_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> double_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::String> empty_string = 0,
    ::flatbuffers::Offset<::flatbuffers::String> some_string = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const DefaultVectorsStringsTest::MyStruct *>> struct_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>>> table_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> enum_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> regular_int_vec = 0,
    int32_t regular_int = 0,
    ::flatbuffers::Offset64<::flatbuffers::Vector<int32_t>> int_vec_offset64 = 0,
    ::flatbuffers::Offset64<::flatbuffers::Vector64<int32_t>> int_vec64 = 0) {
  TableWithDefaultVectorsBuilder builder_(_fbb);
  builder_.add_int_vec64(int_vec64);
  builder_.add_int_vec_offset64(int_vec_offset64);
  builder_.add_regular_int(regular_int);
  builder_.add_regular_int_vec(regular_int_vec);
  builder_.add_enum_vec(enum_vec);
  builder_.add_table_vec(table_vec);
  builder_.add_struct_vec(struct_vec);
  builder_.add_some_string(some_string);
  builder_.add_empty_string(empty_string);
  builder_.add_string_vec(string_vec);
  builder_.add_double_vec(double_vec);
  builder_.add_float_vec(float_vec);
  builder_.add_ulong_vec(ulong_vec);
  builder_.add_long_vec(long_vec);
  builder_.add_uint_vec(uint_vec);
  builder_.add_ushort_vec(ushort_vec);
  builder_.add_short_vec(short_vec);
  builder_.add_uchar_vec(uchar_vec);
  builder_.add_char_vec(char_vec);
  builder_.add_bool_vec(bool_vec);
  builder_.add_int_vec(int_vec);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TableWithDefaultVectors> CreateTableWithDefaultVectorsDirect(
    ::flatbuffers::FlatBufferBuilder64 &_fbb,
    const std::vector<int32_t> *int_vec = nullptr,
    const std::vector<uint8_t> *bool_vec = nullptr,
    const std::vector<int8_t> *char_vec = nullptr,
    const std::vector<uint8_t> *uchar_vec = nullptr,
    const std::vector<int16_t> *short_vec = nullptr,
    const std::vector<uint16_t> *ushort_vec = nullptr,
    const std::vector<uint32_t> *uint_vec = nullptr,
    const std::vector<int64_t> *long_vec = nullptr,
    const std::vector<uint64_t> *ulong_vec = nullptr,
    const std::vector<float> *float_vec = nullptr,
    const std::vector<double> *double_vec = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_vec = nullptr,
    const char *empty_string = nullptr,
    const char *some_string = nullptr,
    const std::vector<DefaultVectorsStringsTest::MyStruct> *struct_vec = nullptr,
    const std::vector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>> *table_vec = nullptr,
    const std::vector<int8_t> *enum_vec = nullptr,
    const std::vector<int32_t> *regular_int_vec = nullptr,
    int32_t regular_int = 0,
    const std::vector<int32_t> *int_vec_offset64 = nullptr,
    const std::vector<int32_t> *int_vec64 = nullptr) {
  auto int_vec_offset64__ = int_vec_offset64 ? _fbb.CreateVector64<::flatbuffers::Vector>(*int_vec_offset64) : 0;
  auto int_vec64__ = int_vec64 ? _fbb.CreateVector64(*int_vec64) : 0;
  auto int_vec__ = int_vec ? _fbb.CreateVector<int32_t>(*int_vec) : 0;
  auto bool_vec__ = bool_vec ? _fbb.CreateVector<uint8_t>(*bool_vec) : 0;
  auto char_vec__ = char_vec ? _fbb.CreateVector<int8_t>(*char_vec) : 0;
  auto uchar_vec__ = uchar_vec ? _fbb.CreateVector<uint8_t>(*uchar_vec) : 0;
  auto short_vec__ = short_vec ? _fbb.CreateVector<int16_t>(*short_vec) : 0;
  auto ushort_vec__ = ushort_vec ? _fbb.CreateVector<uint16_t>(*ushort_vec) : 0;
  auto uint_vec__ = uint_vec ? _fbb.CreateVector<uint32_t>(*uint_vec) : 0;
  auto long_vec__ = long_vec ? _fbb.CreateVector<int64_t>(*long_vec) : 0;
  auto ulong_vec__ = ulong_vec ? _fbb.CreateVector<uint64_t>(*ulong_vec) : 0;
  auto float_vec__ = float_vec ? _fbb.CreateVector<float>(*float_vec) : 0;
  auto double_vec__ = double_vec ? _fbb.CreateVector<double>(*double_vec) : 0;
  auto string_vec__ = string_vec ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_vec) : 0;
  auto empty_string__ = empty_string ? _fbb.CreateString(empty_string) : _fbb.CreateString("");
  auto some_string__ = some_string ? _fbb.CreateString(some_string) : _fbb.CreateString("some");
  auto struct_vec__ = struct_vec ? _fbb.CreateVectorOfStructs<DefaultVectorsStringsTest::MyStruct>(*struct_vec) : 0;
  auto table_vec__ = table_vec ? _fbb.CreateVector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>>(*table_vec) : 0;
  auto enum_vec__ = enum_vec ? _fbb.CreateVector<int8_t>(*enum_vec) : 0;
  auto regular_int_vec__ = regular_int_vec ? _fbb.CreateVector<int32_t>(*regular_int_vec) : 0;
  return DefaultVectorsStringsTest::CreateTableWithDefaultVectors(
      _fbb,
      int_vec__,
      bool_vec__,
      char_vec__,
      uchar_vec__,
      short_vec__,
      ushort_vec__,
      uint_vec__,
      long_vec__,
      ulong_vec__,
      float_vec__,
      double_vec__,
      string_vec__,
      empty_string__,
      some_string__,
      struct_vec__,
      table_vec__,
      enum_vec__,
      regular_int_vec__,
      regular_int,
      int_vec_offset64__,
      int_vec64__);
}

::flatbuffers::Offset<TableWithDefaultVectors> CreateTableWithDefaultVectors(::flatbuffers::FlatBufferBuilder64 &_fbb, const TableWithDefaultVectorsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const MyTableT &lhs, const MyTableT &rhs) {
  return
      (lhs.a == rhs.a);
}

inline bool operator!=(const MyTableT &lhs, const MyTableT &rhs) {
    return !(lhs == rhs);
}


inline MyTableT *MyTable::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MyTableT>(new MyTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MyTable::UnPackTo(MyTableT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = a(); _o->a = _e; }
}

inline ::flatbuffers::Offset<MyTable> MyTable::Pack(::flatbuffers::FlatBufferBuilder64 &_fbb, const MyTableT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMyTable(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MyTable> CreateMyTable(::flatbuffers::FlatBufferBuilder64 &_fbb, const MyTableT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder64 *__fbb; const MyTableT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _a = _o->a;
  return DefaultVectorsStringsTest::CreateMyTable(
      _fbb,
      _a);
}


inline bool operator==(const TableWithDefaultVectorsT &lhs, const TableWithDefaultVectorsT &rhs) {
  return
      (lhs.int_vec == rhs.int_vec) &&
      (lhs.bool_vec == rhs.bool_vec) &&
      (lhs.char_vec == rhs.char_vec) &&
      (lhs.uchar_vec == rhs.uchar_vec) &&
      (lhs.short_vec == rhs.short_vec) &&
      (lhs.ushort_vec == rhs.ushort_vec) &&
      (lhs.uint_vec == rhs.uint_vec) &&
      (lhs.long_vec == rhs.long_vec) &&
      (lhs.ulong_vec == rhs.ulong_vec) &&
      (lhs.float_vec == rhs.float_vec) &&
      (lhs.double_vec == rhs.double_vec) &&
      (lhs.string_vec == rhs.string_vec) &&
      (lhs.empty_string == rhs.empty_string) &&
      (lhs.some_string == rhs.some_string) &&
      (lhs.struct_vec == rhs.struct_vec) &&
      (lhs.table_vec.size() == rhs.table_vec.size() && std::equal(lhs.table_vec.cbegin(), lhs.table_vec.cend(), rhs.table_vec.cbegin(), [](std::unique_ptr<DefaultVectorsStringsTest::MyTableT> const &a, std::unique_ptr<DefaultVectorsStringsTest::MyTableT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.enum_vec == rhs.enum_vec) &&
      (lhs.regular_int_vec == rhs.regular_int_vec) &&
      (lhs.regular_int == rhs.regular_int) &&
      (lhs.int_vec_offset64 == rhs.int_vec_offset64) &&
      (lhs.int_vec64 == rhs.int_vec64);
}

inline bool operator!=(const TableWithDefaultVectorsT &lhs, const TableWithDefaultVectorsT &rhs) {
    return !(lhs == rhs);
}


inline TableWithDefaultVectorsT::TableWithDefaultVectorsT(const TableWithDefaultVectorsT &o)
      : int_vec(o.int_vec),
        bool_vec(o.bool_vec),
        char_vec(o.char_vec),
        uchar_vec(o.uchar_vec),
        short_vec(o.short_vec),
        ushort_vec(o.ushort_vec),
        uint_vec(o.uint_vec),
        long_vec(o.long_vec),
        ulong_vec(o.ulong_vec),
        float_vec(o.float_vec),
        double_vec(o.double_vec),
        string_vec(o.string_vec),
        empty_string(o.empty_string),
        some_string(o.some_string),
        struct_vec(o.struct_vec),
        enum_vec(o.enum_vec),
        regular_int_vec(o.regular_int_vec),
        regular_int(o.regular_int),
        int_vec_offset64(o.int_vec_offset64),
        int_vec64(o.int_vec64) {
  table_vec.reserve(o.table_vec.size());
  for (const auto &table_vec_ : o.table_vec) { table_vec.emplace_back((table_vec_) ? new DefaultVectorsStringsTest::MyTableT(*table_vec_) : nullptr); }
}

inline TableWithDefaultVectorsT &TableWithDefaultVectorsT::operator=(TableWithDefaultVectorsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(int_vec, o.int_vec);
  std::swap(bool_vec, o.bool_vec);
  std::swap(char_vec, o.char_vec);
  std::swap(uchar_vec, o.uchar_vec);
  std::swap(short_vec, o.short_vec);
  std::swap(ushort_vec, o.ushort_vec);
  std::swap(uint_vec, o.uint_vec);
  std::swap(long_vec, o.long_vec);
  std::swap(ulong_vec, o.ulong_vec);
  std::swap(float_vec, o.float_vec);
  std::swap(double_vec, o.double_vec);
  std::swap(string_vec, o.string_vec);
  std::swap(empty_string, o.empty_string);
  std::swap(some_string, o.some_string);
  std::swap(struct_vec, o.struct_vec);
  std::swap(table_vec, o.table_vec);
  std::swap(enum_vec, o.enum_vec);
  std::swap(regular_int_vec, o.regular_int_vec);
  std::swap(regular_int, o.regular_int);
  std::swap(int_vec_offset64, o.int_vec_offset64);
  std::swap(int_vec64, o.int_vec64);
  return *this;
}

inline TableWithDefaultVectorsT *TableWithDefaultVectors::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TableWithDefaultVectorsT>(new TableWithDefaultVectorsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TableWithDefaultVectors::UnPackTo(TableWithDefaultVectorsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = int_vec(); if (_e) { _o->int_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->int_vec[_i] = _e->Get(_i); } } else { _o->int_vec.resize(0); } }
  { auto _e = bool_vec(); if (_e) { _o->bool_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bool_vec[_i] = _e->Get(_i) != 0; } } else { _o->bool_vec.resize(0); } }
  { auto _e = char_vec(); if (_e) { _o->char_vec.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->char_vec.begin()); } }
  { auto _e = uchar_vec(); if (_e) { _o->uchar_vec.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->uchar_vec.begin()); } }
  { auto _e = short_vec(); if (_e) { _o->short_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->short_vec[_i] = _e->Get(_i); } } else { _o->short_vec.resize(0); } }
  { auto _e = ushort_vec(); if (_e) { _o->ushort_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ushort_vec[_i] = _e->Get(_i); } } else { _o->ushort_vec.resize(0); } }
  { auto _e = uint_vec(); if (_e) { _o->uint_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uint_vec[_i] = _e->Get(_i); } } else { _o->uint_vec.resize(0); } }
  { auto _e = long_vec(); if (_e) { _o->long_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->long_vec[_i] = _e->Get(_i); } } else { _o->long_vec.resize(0); } }
  { auto _e = ulong_vec(); if (_e) { _o->ulong_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ulong_vec[_i] = _e->Get(_i); } } else { _o->ulong_vec.resize(0); } }
  { auto _e = float_vec(); if (_e) { _o->float_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->float_vec[_i] = _e->Get(_i); } } else { _o->float_vec.resize(0); } }
  { auto _e = double_vec(); if (_e) { _o->double_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->double_vec[_i] = _e->Get(_i); } } else { _o->double_vec.resize(0); } }
  { auto _e = string_vec(); if (_e) { _o->string_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->string_vec[_i] = _e->Get(_i)->str(); } } else { _o->string_vec.resize(0); } }
  { auto _e = empty_string(); if (_e) _o->empty_string = _e->str(); }
  { auto _e = some_string(); if (_e) _o->some_string = _e->str(); }
  { auto _e = struct_vec(); if (_e) { _o->struct_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->struct_vec[_i] = *_e->Get(_i); } } else { _o->struct_vec.resize(0); } }
  { auto _e = table_vec(); if (_e) { _o->table_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->table_vec[_i]) { _e->Get(_i)->UnPackTo(_o->table_vec[_i].get(), _resolver); } else { _o->table_vec[_i] = std::unique_ptr<DefaultVectorsStringsTest::MyTableT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->table_vec.resize(0); } }
  { auto _e = enum_vec(); if (_e) { _o->enum_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->enum_vec[_i] = static_cast<DefaultVectorsStringsTest::MyEnum>(_e->Get(_i)); } } else { _o->enum_vec.resize(0); } }
  { auto _e = regular_int_vec(); if (_e) { _o->regular_int_vec.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regular_int_vec[_i] = _e->Get(_i); } } else { _o->regular_int_vec.resize(0); } }
  { auto _e = regular_int(); _o->regular_int = _e; }
  { auto _e = int_vec_offset64(); if (_e) { _o->int_vec_offset64.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->int_vec_offset64[_i] = _e->Get(_i); } } else { _o->int_vec_offset64.resize(0); } }
  { auto _e = int_vec64(); if (_e) { _o->int_vec64.resize(_e->size()); for (::flatbuffers::uoffset64_t _i = 0; _i < _e->size(); _i++) { _o->int_vec64[_i] = _e->Get(_i); } } else { _o->int_vec64.resize(0); } }
}

inline ::flatbuffers::Offset<TableWithDefaultVectors> TableWithDefaultVectors::Pack(::flatbuffers::FlatBufferBuilder64 &_fbb, const TableWithDefaultVectorsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTableWithDefaultVectors(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TableWithDefaultVectors> CreateTableWithDefaultVectors(::flatbuffers::FlatBufferBuilder64 &_fbb, const TableWithDefaultVectorsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder64 *__fbb; const TableWithDefaultVectorsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _int_vec = _o->int_vec.size() ? _fbb.CreateVector(_o->int_vec) : 0;
  auto _bool_vec = _o->bool_vec.size() ? _fbb.CreateVector(_o->bool_vec) : 0;
  auto _char_vec = _o->char_vec.size() ? _fbb.CreateVector(_o->char_vec) : 0;
  auto _uchar_vec = _o->uchar_vec.size() ? _fbb.CreateVector(_o->uchar_vec) : 0;
  auto _short_vec = _o->short_vec.size() ? _fbb.CreateVector(_o->short_vec) : 0;
  auto _ushort_vec = _o->ushort_vec.size() ? _fbb.CreateVector(_o->ushort_vec) : 0;
  auto _uint_vec = _o->uint_vec.size() ? _fbb.CreateVector(_o->uint_vec) : 0;
  auto _long_vec = _o->long_vec.size() ? _fbb.CreateVector(_o->long_vec) : 0;
  auto _ulong_vec = _o->ulong_vec.size() ? _fbb.CreateVector(_o->ulong_vec) : 0;
  auto _float_vec = _o->float_vec.size() ? _fbb.CreateVector(_o->float_vec) : 0;
  auto _double_vec = _o->double_vec.size() ? _fbb.CreateVector(_o->double_vec) : 0;
  auto _string_vec = _o->string_vec.size() ? _fbb.CreateVectorOfStrings(_o->string_vec) : 0;
  auto _empty_string = _o->empty_string.empty() ? 0 : _fbb.CreateString(_o->empty_string);
  auto _some_string = _o->some_string.empty() ? 0 : _fbb.CreateString(_o->some_string);
  auto _struct_vec = _o->struct_vec.size() ? _fbb.CreateVectorOfStructs(_o->struct_vec) : 0;
  auto _table_vec = _o->table_vec.size() ? _fbb.CreateVector<::flatbuffers::Offset<DefaultVectorsStringsTest::MyTable>> (_o->table_vec.size(), [](size_t i, _VectorArgs *__va) { return CreateMyTable(*__va->__fbb, __va->__o->table_vec[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _enum_vec = _o->enum_vec.size() ? _fbb.CreateVectorScalarCast<int8_t>(::flatbuffers::data(_o->enum_vec), _o->enum_vec.size()) : 0;
  auto _regular_int_vec = _o->regular_int_vec.size() ? _fbb.CreateVector(_o->regular_int_vec) : 0;
  auto _regular_int = _o->regular_int;
  auto _int_vec_offset64 = _o->int_vec_offset64.size() ? _fbb.CreateVector64<::flatbuffers::Vector>(_o->int_vec_offset64) : 0;
  auto _int_vec64 = _o->int_vec64.size() ? _fbb.CreateVector64(_o->int_vec64) : 0;
  return DefaultVectorsStringsTest::CreateTableWithDefaultVectors(
      _fbb,
      _int_vec,
      _bool_vec,
      _char_vec,
      _uchar_vec,
      _short_vec,
      _ushort_vec,
      _uint_vec,
      _long_vec,
      _ulong_vec,
      _float_vec,
      _double_vec,
      _string_vec,
      _empty_string,
      _some_string,
      _struct_vec,
      _table_vec,
      _enum_vec,
      _regular_int_vec,
      _regular_int,
      _int_vec_offset64,
      _int_vec64);
}

inline const ::flatbuffers::TypeTable *MyEnumTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    DefaultVectorsStringsTest::MyEnumTypeTable
  };
  static const char * const names[] = {
    "A",
    "B"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MyStructTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "a",
    "b"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MyTableTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "a"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TableWithDefaultVectorsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_BOOL, 1, -1 },
    { ::flatbuffers::ET_CHAR, 1, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 },
    { ::flatbuffers::ET_SHORT, 1, -1 },
    { ::flatbuffers::ET_USHORT, 1, -1 },
    { ::flatbuffers::ET_UINT, 1, -1 },
    { ::flatbuffers::ET_LONG, 1, -1 },
    { ::flatbuffers::ET_ULONG, 1, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 },
    { ::flatbuffers::ET_DOUBLE, 1, -1 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_CHAR, 1, 2 },
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 1, -1 },
    { ::flatbuffers::ET_INT, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    DefaultVectorsStringsTest::MyStructTypeTable,
    DefaultVectorsStringsTest::MyTableTypeTable,
    DefaultVectorsStringsTest::MyEnumTypeTable
  };
  static const char * const names[] = {
    "int_vec",
    "bool_vec",
    "char_vec",
    "uchar_vec",
    "short_vec",
    "ushort_vec",
    "uint_vec",
    "long_vec",
    "ulong_vec",
    "float_vec",
    "double_vec",
    "string_vec",
    "empty_string",
    "some_string",
    "struct_vec",
    "table_vec",
    "enum_vec",
    "regular_int_vec",
    "regular_int",
    "int_vec_offset64",
    "int_vec64"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 21, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const DefaultVectorsStringsTest::TableWithDefaultVectors *GetTableWithDefaultVectors(const void *buf) {
  return ::flatbuffers::GetRoot<DefaultVectorsStringsTest::TableWithDefaultVectors>(buf);
}

inline const DefaultVectorsStringsTest::TableWithDefaultVectors *GetSizePrefixedTableWithDefaultVectors(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DefaultVectorsStringsTest::TableWithDefaultVectors,::flatbuffers::uoffset64_t>(buf);
}

inline TableWithDefaultVectors *GetMutableTableWithDefaultVectors(void *buf) {
  return ::flatbuffers::GetMutableRoot<TableWithDefaultVectors>(buf);
}

inline DefaultVectorsStringsTest::TableWithDefaultVectors *GetMutableSizePrefixedTableWithDefaultVectors(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<DefaultVectorsStringsTest::TableWithDefaultVectors,::flatbuffers::uoffset64_t>(buf);
}

inline bool VerifyTableWithDefaultVectorsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DefaultVectorsStringsTest::TableWithDefaultVectors>(nullptr);
}

inline bool VerifySizePrefixedTableWithDefaultVectorsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DefaultVectorsStringsTest::TableWithDefaultVectors,::flatbuffers::uoffset64_t>(nullptr);
}

inline void FinishTableWithDefaultVectorsBuffer(
    ::flatbuffers::FlatBufferBuilder64 &fbb,
    ::flatbuffers::Offset<DefaultVectorsStringsTest::TableWithDefaultVectors> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTableWithDefaultVectorsBuffer(
    ::flatbuffers::FlatBufferBuilder64 &fbb,
    ::flatbuffers::Offset<DefaultVectorsStringsTest::TableWithDefaultVectors> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<DefaultVectorsStringsTest::TableWithDefaultVectorsT> UnPackTableWithDefaultVectors(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DefaultVectorsStringsTest::TableWithDefaultVectorsT>(GetTableWithDefaultVectors(buf)->UnPack(res));
}

inline std::unique_ptr<DefaultVectorsStringsTest::TableWithDefaultVectorsT> UnPackSizePrefixedTableWithDefaultVectors(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DefaultVectorsStringsTest::TableWithDefaultVectorsT>(GetSizePrefixedTableWithDefaultVectors(buf)->UnPack(res));
}

}  // namespace DefaultVectorsStringsTest

#endif  // FLATBUFFERS_GENERATED_DEFAULTVECTORSSTRINGSTEST_DEFAULTVECTORSSTRINGSTEST_H_

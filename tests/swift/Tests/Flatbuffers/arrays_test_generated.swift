// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

#if compiler(>=6.2)
public enum MyGame_Example_TestEnum: Int8, FlatbuffersVectorInitializable, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case a = 0
  case b = 1
  case c = 2

  public static var max: MyGame_Example_TestEnum { return .c }
  public static var min: MyGame_Example_TestEnum { return .a }
}

extension MyGame_Example_TestEnum: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .a: try container.encode("A")
    case .b: try container.encode("B")
    case .c: try container.encode("C")
    }
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
public struct MyGame_Example_NestedStruct: NativeStruct, FlatbuffersVectorInitializable, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }

  private var _a: InlineArray<2, Int32>
  private var _b: Int8
  private var _c: InlineArray<2, Int8>
  private var padding0__: UInt8 = 0
  private var padding1__: UInt32 = 0
  private var _d: InlineArray<2, Int64>

  public init(_ bb: ByteBuffer, o: Int32) {
    self = bb.read(def: Self.self, position: Int(o))
  }

  public init(a: InlineArray<2, Int32>, b: MyGame_Example_TestEnum, c: InlineArray<2, Int8>, d: InlineArray<2, Int64>) {
    _a = a
    _b = b.value
    _c = c
    _d = d
  }

  public init() {
    _a = InlineArray(repeating: 0)
    _b = 0
    _c = InlineArray(repeating: 0)
    _d = InlineArray(repeating: 0)
  }

  public init(_ _t: borrowing MyGame_Example_NestedStruct_Mutable) {
    let _va = _t.a
    _a = InlineArray { _va[$0] }
    _b = _t.b.value
    let _vc = _t.c
    _c = InlineArray { _vc[$0].rawValue }
    let _vd = _t.d
    _d = InlineArray { _vd[$0] }
  }

  public var a: InlineArray<2, Int32> { _a }
  public var b: MyGame_Example_TestEnum { MyGame_Example_TestEnum(rawValue: _b)! }
  public var c: InlineArray<2, MyGame_Example_TestEnum> { InlineArray { MyGame_Example_TestEnum(rawValue: _c[$0])! } }
  public var d: InlineArray<2, Int64> { _d }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_NestedStruct.self)
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
extension MyGame_Example_NestedStruct: Encodable {

  enum CodingKeys: String, CodingKey {
    case a = "a"
    case b = "b"
    case c = "c"
    case d = "d"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    var aContainer = container.nestedUnkeyedContainer(forKey: .a)
    for index in a.startIndex..<a.endIndex {
      try aContainer.encode(a[index])
    }
    if b != .a {
      try container.encodeIfPresent(b, forKey: .b)
    }
    var cContainer = container.nestedUnkeyedContainer(forKey: .c)
    for index in c.startIndex..<c.endIndex {
      try cContainer.encode(c[index])
    }
    var dContainer = container.nestedUnkeyedContainer(forKey: .d)
    for index in d.startIndex..<d.endIndex {
      try dContainer.encode(d[index])
    }
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
public struct MyGame_Example_NestedStruct_Mutable: FlatBufferStruct, FlatbuffersVectorInitializable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var a: FlatbufferVector<Int32> { return _accessor.vector(at: 0, count: 2, size: 4) }
  @discardableResult public func mutate(a: Int32, at index: Int32) -> Bool { return _accessor.mutate(a, index: 0 + (index * 4)) }
  public var b: MyGame_Example_TestEnum { return MyGame_Example_TestEnum(rawValue: _accessor.readBuffer(of: Int8.self, at: 8)) ?? .a }
  @discardableResult public func mutate(b: MyGame_Example_TestEnum) -> Bool { return _accessor.mutate(b.rawValue, index: 8) }
  public var c: FlatbufferVector<MyGame_Example_TestEnum> { return _accessor.vector(at: 9, count: 2, size: 1) }
  @discardableResult public func mutate(c: MyGame_Example_TestEnum, at index: Int32) -> Bool { return _accessor.mutate(c.rawValue, index: 9 + (index * 1)) }
  public var d: FlatbufferVector<Int64> { return _accessor.vector(at: 16, count: 2, size: 8) }
  @discardableResult public func mutate(d: Int64, at index: Int32) -> Bool { return _accessor.mutate(d, index: 16 + (index * 8)) }

  public func unpack() -> MyGame_Example_NestedStruct {
    return MyGame_Example_NestedStruct(self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_NestedStruct?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_NestedStruct) -> Offset {
    return builder.create(struct: obj)
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
public struct MyGame_Example_ArrayStruct: NativeStruct, FlatbuffersVectorInitializable, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }

  private var _a: Float32
  private var _b: InlineArray<15, Int32>
  private var _c: Int8
  private var padding0__: UInt8 = 0
  private var padding1__: UInt16 = 0
  private var padding2__: UInt32 = 0
  private var _d: InlineArray<2, MyGame_Example_NestedStruct>
  private var _e: Int32
  private var padding3__: UInt32 = 0
  private var _f: InlineArray<2, Int64>

  public init(_ bb: ByteBuffer, o: Int32) {
    self = bb.read(def: Self.self, position: Int(o))
  }

  public init(a: Float32, b: InlineArray<15, Int32>, c: Int8, d: InlineArray<2, MyGame_Example_NestedStruct>, e: Int32, f: InlineArray<2, Int64>) {
    _a = a
    _b = b
    _c = c
    _d = d
    _e = e
    _f = f
  }

  public init() {
    _a = 0.0
    _b = InlineArray(repeating: 0)
    _c = 0
    _d = InlineArray(repeating: MyGame_Example_NestedStruct())
    _e = 0
    _f = InlineArray(repeating: 0)
  }

  public init(_ _t: borrowing MyGame_Example_ArrayStruct_Mutable) {
    _a = _t.a
    let _vb = _t.b
    _b = InlineArray { _vb[$0] }
    _c = _t.c
    let _vd = _t.d
    _d = InlineArray { _vd[$0].unpack() }
    _e = _t.e
    let _vf = _t.f
    _f = InlineArray { _vf[$0] }
  }

  public var a: Float32 { _a }
  public var b: InlineArray<15, Int32> { _b }
  public var c: Int8 { _c }
  public var d: InlineArray<2, MyGame_Example_NestedStruct> { _d }
  public var e: Int32 { _e }
  public var f: InlineArray<2, Int64> { _f }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_ArrayStruct.self)
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
extension MyGame_Example_ArrayStruct: Encodable {

  enum CodingKeys: String, CodingKey {
    case a = "a"
    case b = "b"
    case c = "c"
    case d = "d"
    case e = "e"
    case f = "f"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if a != 0.0 {
      try container.encodeIfPresent(a, forKey: .a)
    }
    var bContainer = container.nestedUnkeyedContainer(forKey: .b)
    for index in b.startIndex..<b.endIndex {
      try bContainer.encode(b[index])
    }
    if c != 0 {
      try container.encodeIfPresent(c, forKey: .c)
    }
    var dContainer = container.nestedUnkeyedContainer(forKey: .d)
    for index in d.startIndex..<d.endIndex {
      try dContainer.encode(d[index])
    }
    if e != 0 {
      try container.encodeIfPresent(e, forKey: .e)
    }
    var fContainer = container.nestedUnkeyedContainer(forKey: .f)
    for index in f.startIndex..<f.endIndex {
      try fContainer.encode(f[index])
    }
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
public struct MyGame_Example_ArrayStruct_Mutable: FlatBufferStruct, FlatbuffersVectorInitializable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var a: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  @discardableResult public func mutate(a: Float32) -> Bool { return _accessor.mutate(a, index: 0) }
  public var b: FlatbufferVector<Int32> { return _accessor.vector(at: 4, count: 15, size: 4) }
  @discardableResult public func mutate(b: Int32, at index: Int32) -> Bool { return _accessor.mutate(b, index: 4 + (index * 4)) }
  public var c: Int8 { return _accessor.readBuffer(of: Int8.self, at: 64) }
  @discardableResult public func mutate(c: Int8) -> Bool { return _accessor.mutate(c, index: 64) }
  public var d: FlatbufferVector<MyGame_Example_NestedStruct_Mutable> { return _accessor.vector(at: 72, count: 2, size: 32) }
  public var e: Int32 { return _accessor.readBuffer(of: Int32.self, at: 136) }
  @discardableResult public func mutate(e: Int32) -> Bool { return _accessor.mutate(e, index: 136) }
  public var f: FlatbufferVector<Int64> { return _accessor.vector(at: 144, count: 2, size: 8) }
  @discardableResult public func mutate(f: Int64, at index: Int32) -> Bool { return _accessor.mutate(f, index: 144 + (index * 8)) }

  public func unpack() -> MyGame_Example_ArrayStruct {
    return MyGame_Example_ArrayStruct(self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_ArrayStruct?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_ArrayStruct) -> Offset {
    return builder.create(struct: obj)
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
public struct MyGame_Example_ArrayTable: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "ARRT" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example_ArrayTable.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case a = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var a: MyGame_Example_ArrayStruct? { let o = _accessor.offset(VTOFFSET.a.v); return o == 0 ? nil : _accessor.readBuffer(of: MyGame_Example_ArrayStruct.self, at: o) }
  public var mutableA: MyGame_Example_ArrayStruct_Mutable? { let o = _accessor.offset(VTOFFSET.a.v); return o == 0 ? nil : MyGame_Example_ArrayStruct_Mutable(_accessor.bb, o: o + _accessor.position) }
  public static func startArrayTable(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(a: MyGame_Example_ArrayStruct?, _ fbb: inout FlatBufferBuilder) { guard let a = a else { return }; fbb.create(struct: a, position: VTOFFSET.a.p) }
  public static func endArrayTable(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArrayTable(
    _ fbb: inout FlatBufferBuilder,
    a: MyGame_Example_ArrayStruct? = nil
  ) -> Offset {
    let __start = MyGame_Example_ArrayTable.startArrayTable(&fbb)
    MyGame_Example_ArrayTable.add(a: a, &fbb)
    return MyGame_Example_ArrayTable.endArrayTable(&fbb, start: __start)
  }

  public func unpack() -> MyGame_Example_ArrayTableT {
    return MyGame_Example_ArrayTableT(self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_ArrayTableT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_ArrayTableT) -> Offset {
    let __root = MyGame_Example_ArrayTable.startArrayTable(&builder)
    MyGame_Example_ArrayTable.add(a: obj.a, &builder)
    return MyGame_Example_ArrayTable.endArrayTable(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.a.p, fieldName: "a", required: false, type: MyGame_Example_ArrayStruct.self)
    _v.finish()
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
extension MyGame_Example_ArrayTable: Encodable {

  enum CodingKeys: String, CodingKey {
    case a = "a"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(a, forKey: .a)
  }
}

@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, *)
public class MyGame_Example_ArrayTableT: NativeObject {

  public var a: MyGame_Example_ArrayStruct?

  public init(_ _t: borrowing MyGame_Example_ArrayTable) {
    a = _t.a
  }

  public init() {
    a = MyGame_Example_ArrayStruct()
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_Example_ArrayTable.self) }

}
#endif

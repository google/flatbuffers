// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public struct DataModel_A: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private struct VT {
  }

  public static func startA(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func endA(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createA(
    _ fbb: inout FlatBufferBuilder
  ) -> Offset {
    let __start = DataModel_A.startA(&fbb)
    return DataModel_A.endA(&fbb, start: __start)
  }

  public func unpack() -> DataModel_AT {
    return DataModel_AT(self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout DataModel_AT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout DataModel_AT) -> Offset {
    let __root = DataModel_A.startA(&builder)
    return DataModel_A.endA(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

extension DataModel_A: Encodable {
  public func encode(to encoder: Encoder) throws {
  }
}

public class DataModel_AT: NativeObject {


  public init(_ _t: borrowing DataModel_A) {
  }

  public init() {
  }

  public func serialize() -> ByteBuffer { return serialize(type: DataModel_A.self) }

}

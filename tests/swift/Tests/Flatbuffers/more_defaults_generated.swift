// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public enum ABC: Int32, FlatbuffersVectorInitializable, Enum, Verifiable {
  public typealias T = Int32
  public static var byteSize: Int { return MemoryLayout<Int32>.size }
  public var value: Int32 { return self.rawValue }
  case a = 0
  case b = 1
  case c = 2

  public static var max: ABC { return .c }
  public static var min: ABC { return .a }
}

extension ABC: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .a: try container.encode("A")
    case .b: try container.encode("B")
    case .c: try container.encode("C")
    }
  }
}

public struct MoreDefaults: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private struct VT {
    static let ints: VOffset = 4
    static let floats: VOffset = 6
    static let emptyString: VOffset = 8
    static let someString: VOffset = 10
    static let abcs: VOffset = 12
    static let bools: VOffset = 14
  }

  public var ints: FlatbufferVector<Int32> { return _accessor.vector(at: VT.ints, byteSize: 4) }
  public func withUnsafePointerToInts<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VT.ints, body: body) }
  public var floats: FlatbufferVector<Float32> { return _accessor.vector(at: VT.floats, byteSize: 4) }
  public func withUnsafePointerToFloats<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VT.floats, body: body) }
  public var emptyString: String? { let o = _accessor.offset(VT.emptyString); return o == 0 ? "" : _accessor.string(at: o) }
  public var emptyStringSegmentArray: [UInt8]? { return _accessor.getVector(at: VT.emptyString) }
  public var someString: String? { let o = _accessor.offset(VT.someString); return o == 0 ? "some" : _accessor.string(at: o) }
  public var someStringSegmentArray: [UInt8]? { return _accessor.getVector(at: VT.someString) }
  public var abcs: FlatbufferVector<ABC> { return _accessor.vector(at: VT.abcs, byteSize: 4) }
  public var bools: FlatbufferVector<Bool> { return _accessor.vector(at: VT.bools, byteSize: 1) }
  public func withUnsafePointerToBools<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VT.bools, body: body) }
  public static func startMoreDefaults(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func addVectorOf(ints: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ints, at: VT.ints) }
  public static func addVectorOf(floats: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: floats, at: VT.floats) }
  public static func add(emptyString: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: emptyString, at: VT.emptyString) }
  public static func add(someString: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: someString, at: VT.someString) }
  public static func addVectorOf(abcs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: abcs, at: VT.abcs) }
  public static func addVectorOf(bools: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bools, at: VT.bools) }
  public static func endMoreDefaults(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMoreDefaults(
    _ fbb: inout FlatBufferBuilder,
    intsVectorOffset ints: Offset = Offset(),
    floatsVectorOffset floats: Offset = Offset(),
    emptyStringOffset emptyString: Offset = Offset(),
    someStringOffset someString: Offset = Offset(),
    abcsVectorOffset abcs: Offset = Offset(),
    boolsVectorOffset bools: Offset = Offset()
  ) -> Offset {
    let __start = MoreDefaults.startMoreDefaults(&fbb)
    MoreDefaults.addVectorOf(ints: ints, &fbb)
    MoreDefaults.addVectorOf(floats: floats, &fbb)
    MoreDefaults.add(emptyString: emptyString, &fbb)
    MoreDefaults.add(someString: someString, &fbb)
    MoreDefaults.addVectorOf(abcs: abcs, &fbb)
    MoreDefaults.addVectorOf(bools: bools, &fbb)
    return MoreDefaults.endMoreDefaults(&fbb, start: __start)
  }

  public func unpack() -> MoreDefaultsT {
    return MoreDefaultsT(self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MoreDefaultsT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MoreDefaultsT) -> Offset {
    let __ints = builder.createVector(obj.ints)
    let __floats = builder.createVector(obj.floats)
    let __emptyString: Offset
    if let s = obj.emptyString {
      __emptyString = builder.create(string: s)
    } else {
      __emptyString = Offset()
    }

    let __someString: Offset
    if let s = obj.someString {
      __someString = builder.create(string: s)
    } else {
      __someString = Offset()
    }

    let __abcs = builder.createVector(obj.abcs)
    let __bools = builder.createVector(obj.bools)
    let __root = MoreDefaults.startMoreDefaults(&builder)
    MoreDefaults.addVectorOf(ints: __ints, &builder)
    MoreDefaults.addVectorOf(floats: __floats, &builder)
    MoreDefaults.add(emptyString: __emptyString, &builder)
    MoreDefaults.add(someString: __someString, &builder)
    MoreDefaults.addVectorOf(abcs: __abcs, &builder)
    MoreDefaults.addVectorOf(bools: __bools, &builder)
    return MoreDefaults.endMoreDefaults(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VT.ints, fieldName: "ints", required: false, type: ForwardOffset<Vector<Int32, Int32>>.self)
    try _v.visit(field: VT.floats, fieldName: "floats", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VT.emptyString, fieldName: "emptyString", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VT.someString, fieldName: "someString", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VT.abcs, fieldName: "abcs", required: false, type: ForwardOffset<Vector<ABC, ABC>>.self)
    try _v.visit(field: VT.bools, fieldName: "bools", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    _v.finish()
  }
}

extension MoreDefaults: Encodable {
  enum CodingKeys: String, CodingKey {
    case ints = "ints"
    case floats = "floats"
    case emptyString = "empty_string"
    case someString = "some_string"
    case abcs = "abcs"
    case bools = "bools"
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(ints, forKey: .ints)
    try container.encodeIfPresent(floats, forKey: .floats)
    try container.encodeIfPresent(emptyString, forKey: .emptyString)
    try container.encodeIfPresent(someString, forKey: .someString)
    try container.encodeIfPresent(abcs, forKey: .abcs)
    try container.encodeIfPresent(bools, forKey: .bools)
  }
}

public class MoreDefaultsT: NativeObject {

  public var ints: [Int32]
  public var floats: [Float32]
  public var emptyString: String?
  public var someString: String?
  public var abcs: [ABC]
  public var bools: [Bool]

  public init(_ _t: borrowing MoreDefaults) {
    ints = []
    ints.append(contentsOf: _t.ints)
    floats = []
    floats.append(contentsOf: _t.floats)
    emptyString = _t.emptyString
    someString = _t.someString
    abcs = []
    abcs.append(contentsOf: _t.abcs)
    bools = []
    bools.append(contentsOf: _t.bools)
  }

  public init() {
    ints = []
    floats = []
    emptyString = ""
    someString = "some"
    abcs = []
    bools = []
  }

  public func serialize() -> ByteBuffer { return serialize(type: MoreDefaults.self) }

}

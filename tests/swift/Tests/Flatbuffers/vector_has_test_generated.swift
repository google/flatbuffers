// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public struct Swift_Tests_Vectors: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private struct VT {
    static let none_: VOffset = 4
    static let empty: VOffset = 6
    static let array: VOffset = 8
  }

  public var none_: FlatbufferVector<UInt64> { return _accessor.vector(at: VT.none_, byteSize: 8) }
  public func withUnsafePointerToNone<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VT.none_, body: body) }
  public var empty: FlatbufferVector<UInt64> { return _accessor.vector(at: VT.empty, byteSize: 8) }
  public func withUnsafePointerToEmpty<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VT.empty, body: body) }
  public var array: FlatbufferVector<UInt64> { return _accessor.vector(at: VT.array, byteSize: 8) }
  public func withUnsafePointerToArray<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VT.array, body: body) }
  public static func startVectors(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(none_: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: none_, at: VT.none_) }
  public static func addVectorOf(empty: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: empty, at: VT.empty) }
  public static func addVectorOf(array: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: array, at: VT.array) }
  public static func endVectors(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVectors(
    _ fbb: inout FlatBufferBuilder,
    none_VectorOffset none_: Offset = Offset(),
    emptyVectorOffset empty: Offset = Offset(),
    arrayVectorOffset array: Offset = Offset()
  ) -> Offset {
    let __start = Swift_Tests_Vectors.startVectors(&fbb)
    Swift_Tests_Vectors.addVectorOf(none_: none_, &fbb)
    Swift_Tests_Vectors.addVectorOf(empty: empty, &fbb)
    Swift_Tests_Vectors.addVectorOf(array: array, &fbb)
    return Swift_Tests_Vectors.endVectors(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VT.none_, fieldName: "none_", required: false, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    try _v.visit(field: VT.empty, fieldName: "empty", required: false, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    try _v.visit(field: VT.array, fieldName: "array", required: false, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    _v.finish()
  }
}

extension Swift_Tests_Vectors: Encodable {
  enum CodingKeys: String, CodingKey {
    case none_ = "none"
    case empty = "empty"
    case array = "array"
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(none_, forKey: .none_)
    try container.encodeIfPresent(empty, forKey: .empty)
    try container.encodeIfPresent(array, forKey: .array)
  }
}


// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Composite components of Monster color.
public enum MyGame_Example_Color: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case red = 1
  ///  \brief color Green
  ///  Green is bit_flag with value (1u << 1)
  case green = 2
  ///  \brief color Blue (1u << 3)
  case blue = 8

  public static var max: MyGame_Example_Color { return .blue }
  public static var min: MyGame_Example_Color { return .red }
}

extension MyGame_Example_Color: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .red: try container.encode("Red")
    case .green: try container.encode("Green")
    case .blue: try container.encode("Blue")
    }
  }
}

public enum MyGame_Example_Race: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = -1
  case human = 0
  case dwarf = 1
  case elf = 2

  public static var max: MyGame_Example_Race { return .elf }
  public static var min: MyGame_Example_Race { return .none_ }
}

extension MyGame_Example_Race: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .none_: try container.encode("None")
    case .human: try container.encode("Human")
    case .dwarf: try container.encode("Dwarf")
    case .elf: try container.encode("Elf")
    }
  }
}

public enum MyGame_Example_LongEnum: UInt64, Enum, Verifiable {
  public typealias T = UInt64
  public static var byteSize: Int { return MemoryLayout<UInt64>.size }
  public var value: UInt64 { return self.rawValue }
  case longone = 2
  case longtwo = 4
  case longbig = 1099511627776

  public static var max: MyGame_Example_LongEnum { return .longbig }
  public static var min: MyGame_Example_LongEnum { return .longone }
}

extension MyGame_Example_LongEnum: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .longone: try container.encode("LongOne")
    case .longtwo: try container.encode("LongTwo")
    case .longbig: try container.encode("LongBig")
    }
  }
}

public enum MyGame_Example_Any_: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case monster = 1
  case testsimpletablewithenum = 2
  case mygameExample2Monster = 3

  public static var max: MyGame_Example_Any_ { return .mygameExample2Monster }
  public static var min: MyGame_Example_Any_ { return .none_ }
}

extension MyGame_Example_Any_: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .none_: try container.encode("NONE")
    case .monster: try container.encode("Monster")
    case .testsimpletablewithenum: try container.encode("TestSimpleTableWithEnum")
    case .mygameExample2Monster: try container.encode("MyGame_Example2_Monster")
    }
  }
}

public struct MyGame_Example_Any_Union {
  public var type: MyGame_Example_Any_
  public var value: NativeObject?
  public init(_ v: NativeObject?, type: MyGame_Example_Any_) {
    self.type = type
    self.value = v
  }
  public func pack(builder: inout FlatBufferBuilder) -> Offset {
    switch type {
    case .monster:
      var __obj = value as? MyGame_Example_MonsterT
      return MyGame_Example_Monster.pack(&builder, obj: &__obj)
    case .testsimpletablewithenum:
      var __obj = value as? MyGame_Example_TestSimpleTableWithEnumT
      return MyGame_Example_TestSimpleTableWithEnum.pack(&builder, obj: &__obj)
    case .mygameExample2Monster:
      var __obj = value as? MyGame_Example2_MonsterT
      return MyGame_Example2_Monster.pack(&builder, obj: &__obj)
    default: return Offset()
    }
  }
}
public enum MyGame_Example_AnyUniqueAliases: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case m = 1
  case ts = 2
  case m2 = 3

  public static var max: MyGame_Example_AnyUniqueAliases { return .m2 }
  public static var min: MyGame_Example_AnyUniqueAliases { return .none_ }
}

extension MyGame_Example_AnyUniqueAliases: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .none_: try container.encode("NONE")
    case .m: try container.encode("M")
    case .ts: try container.encode("TS")
    case .m2: try container.encode("M2")
    }
  }
}

public struct MyGame_Example_AnyUniqueAliasesUnion {
  public var type: MyGame_Example_AnyUniqueAliases
  public var value: NativeObject?
  public init(_ v: NativeObject?, type: MyGame_Example_AnyUniqueAliases) {
    self.type = type
    self.value = v
  }
  public func pack(builder: inout FlatBufferBuilder) -> Offset {
    switch type {
    case .m:
      var __obj = value as? MyGame_Example_MonsterT
      return MyGame_Example_Monster.pack(&builder, obj: &__obj)
    case .ts:
      var __obj = value as? MyGame_Example_TestSimpleTableWithEnumT
      return MyGame_Example_TestSimpleTableWithEnum.pack(&builder, obj: &__obj)
    case .m2:
      var __obj = value as? MyGame_Example2_MonsterT
      return MyGame_Example2_Monster.pack(&builder, obj: &__obj)
    default: return Offset()
    }
  }
}
public enum MyGame_Example_AnyAmbiguousAliases: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case m1 = 1
  case m2 = 2
  case m3 = 3

  public static var max: MyGame_Example_AnyAmbiguousAliases { return .m3 }
  public static var min: MyGame_Example_AnyAmbiguousAliases { return .none_ }
}

extension MyGame_Example_AnyAmbiguousAliases: Encodable {
  public func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    switch self {
    case .none_: try container.encode("NONE")
    case .m1: try container.encode("M1")
    case .m2: try container.encode("M2")
    case .m3: try container.encode("M3")
    }
  }
}

public struct MyGame_Example_AnyAmbiguousAliasesUnion {
  public var type: MyGame_Example_AnyAmbiguousAliases
  public var value: NativeObject?
  public init(_ v: NativeObject?, type: MyGame_Example_AnyAmbiguousAliases) {
    self.type = type
    self.value = v
  }
  public func pack(builder: inout FlatBufferBuilder) -> Offset {
    switch type {
    case .m1:
      var __obj = value as? MyGame_Example_MonsterT
      return MyGame_Example_Monster.pack(&builder, obj: &__obj)
    case .m2:
      var __obj = value as? MyGame_Example_MonsterT
      return MyGame_Example_Monster.pack(&builder, obj: &__obj)
    case .m3:
      var __obj = value as? MyGame_Example_MonsterT
      return MyGame_Example_Monster.pack(&builder, obj: &__obj)
    default: return Offset()
    }
  }
}
public struct MyGame_Example_Test: NativeStruct, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _a: Int16
  private var _b: Int8
  private let padding0__: UInt8 = 0

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _a = _accessor.readBuffer(of: Int16.self, at: 0)
    _b = _accessor.readBuffer(of: Int8.self, at: 2)
  }

  public init(a: Int16, b: Int8) {
    _a = a
    _b = b
  }

  public init() {
    _a = 0
    _b = 0
  }

  public init(_ _t: inout MyGame_Example_Test_Mutable) {
    _a = _t.a
    _b = _t.b
  }

  public var a: Int16 { _a }
  public var b: Int8 { _b }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_Test.self)
  }
}

extension MyGame_Example_Test: Encodable {

  enum CodingKeys: String, CodingKey {
    case a = "a"
    case b = "b"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if a != 0 {
      try container.encodeIfPresent(a, forKey: .a)
    }
    if b != 0 {
      try container.encodeIfPresent(b, forKey: .b)
    }
  }
}

public struct MyGame_Example_Test_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var a: Int16 { return _accessor.readBuffer(of: Int16.self, at: 0) }
  @discardableResult public func mutate(a: Int16) -> Bool { return _accessor.mutate(a, index: 0) }
  public var b: Int8 { return _accessor.readBuffer(of: Int8.self, at: 2) }
  @discardableResult public func mutate(b: Int8) -> Bool { return _accessor.mutate(b, index: 2) }
  

  public mutating func unpack() -> MyGame_Example_Test {
    return MyGame_Example_Test(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_Test?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_Test) -> Offset {
    return builder.create(struct: obj)
  }
}

public struct MyGame_Example_Vec3: NativeStruct, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _x: Float32
  private var _y: Float32
  private var _z: Float32
  private let padding0__: UInt32 = 0
  private var _test1: Double
  private var _test2: UInt8
  private let padding1__: UInt8 = 0
  private var _test3: MyGame_Example_Test
  private let padding2__: UInt16 = 0

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _z = _accessor.readBuffer(of: Float32.self, at: 8)
    _test1 = _accessor.readBuffer(of: Double.self, at: 16)
    _test2 = _accessor.readBuffer(of: UInt8.self, at: 24)
    _test3 = MyGame_Example_Test(_accessor.bb, o: _accessor.postion + 26)
  }

  public init(x: Float32, y: Float32, z: Float32, test1: Double, test2: MyGame_Example_Color, test3: MyGame_Example_Test) {
    _x = x
    _y = y
    _z = z
    _test1 = test1
    _test2 = test2.value
    _test3 = test3
  }

  public init() {
    _x = 0.0
    _y = 0.0
    _z = 0.0
    _test1 = 0.0
    _test2 = 0
    _test3 = MyGame_Example_Test()
  }

  public init(_ _t: inout MyGame_Example_Vec3_Mutable) {
    _x = _t.x
    _y = _t.y
    _z = _t.z
    _test1 = _t.test1
    _test2 = _t.test2.value
    var _vtest3 = _t.test3
    _test3 = _vtest3.unpack()
  }

  public var x: Float32 { _x }
  public var y: Float32 { _y }
  public var z: Float32 { _z }
  public var test1: Double { _test1 }
  public var test2: MyGame_Example_Color { MyGame_Example_Color(rawValue: _test2)! }
  public var test3: MyGame_Example_Test { _test3 }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_Vec3.self)
  }
}

extension MyGame_Example_Vec3: Encodable {

  enum CodingKeys: String, CodingKey {
    case x = "x"
    case y = "y"
    case z = "z"
    case test1 = "test1"
    case test2 = "test2"
    case test3 = "test3"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if x != 0.0 {
      try container.encodeIfPresent(x, forKey: .x)
    }
    if y != 0.0 {
      try container.encodeIfPresent(y, forKey: .y)
    }
    if z != 0.0 {
      try container.encodeIfPresent(z, forKey: .z)
    }
    if test1 != 0.0 {
      try container.encodeIfPresent(test1, forKey: .test1)
    }
    if test2 != .red {
      try container.encodeIfPresent(test2, forKey: .test2)
    }
    try container.encodeIfPresent(test3, forKey: .test3)
  }
}

public struct MyGame_Example_Vec3_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  @discardableResult public func mutate(x: Float32) -> Bool { return _accessor.mutate(x, index: 0) }
  public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  @discardableResult public func mutate(y: Float32) -> Bool { return _accessor.mutate(y, index: 4) }
  public var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  @discardableResult public func mutate(z: Float32) -> Bool { return _accessor.mutate(z, index: 8) }
  public var test1: Double { return _accessor.readBuffer(of: Double.self, at: 16) }
  @discardableResult public func mutate(test1: Double) -> Bool { return _accessor.mutate(test1, index: 16) }
  public var test2: MyGame_Example_Color { return MyGame_Example_Color(rawValue: _accessor.readBuffer(of: UInt8.self, at: 24)) ?? .red }
  @discardableResult public func mutate(test2: MyGame_Example_Color) -> Bool { return _accessor.mutate(test2.rawValue, index: 24) }
  public var test3: MyGame_Example_Test_Mutable { return MyGame_Example_Test_Mutable(_accessor.bb, o: _accessor.postion + 26) }
  

  public mutating func unpack() -> MyGame_Example_Vec3 {
    return MyGame_Example_Vec3(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_Vec3?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_Vec3) -> Offset {
    return builder.create(struct: obj)
  }
}

public struct MyGame_Example_Ability: NativeStruct, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _id: UInt32
  private var _distance: UInt32

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _id = _accessor.readBuffer(of: UInt32.self, at: 0)
    _distance = _accessor.readBuffer(of: UInt32.self, at: 4)
  }

  public init(id: UInt32, distance: UInt32) {
    _id = id
    _distance = distance
  }

  public init() {
    _id = 0
    _distance = 0
  }

  public init(_ _t: inout MyGame_Example_Ability_Mutable) {
    _id = _t.id
    _distance = _t.distance
  }

  public var id: UInt32 { _id }
  public var distance: UInt32 { _distance }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_Ability.self)
  }
}

extension MyGame_Example_Ability: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
    case distance = "distance"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if id != 0 {
      try container.encodeIfPresent(id, forKey: .id)
    }
    if distance != 0 {
      try container.encodeIfPresent(distance, forKey: .distance)
    }
  }
}

public struct MyGame_Example_Ability_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var id: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 0) }
  @discardableResult public func mutate(id: UInt32) -> Bool { return _accessor.mutate(id, index: 0) }
  public var distance: UInt32 { return _accessor.readBuffer(of: UInt32.self, at: 4) }
  @discardableResult public func mutate(distance: UInt32) -> Bool { return _accessor.mutate(distance, index: 4) }
  

  public mutating func unpack() -> MyGame_Example_Ability {
    return MyGame_Example_Ability(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_Ability?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_Ability) -> Offset {
    return builder.create(struct: obj)
  }
}

public struct MyGame_Example_StructOfStructs: NativeStruct, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _a: MyGame_Example_Ability
  private var _b: MyGame_Example_Test
  private var _c: MyGame_Example_Ability

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _a = MyGame_Example_Ability(_accessor.bb, o: _accessor.postion + 0)
    _b = MyGame_Example_Test(_accessor.bb, o: _accessor.postion + 8)
    _c = MyGame_Example_Ability(_accessor.bb, o: _accessor.postion + 12)
  }

  public init(a: MyGame_Example_Ability, b: MyGame_Example_Test, c: MyGame_Example_Ability) {
    _a = a
    _b = b
    _c = c
  }

  public init() {
    _a = MyGame_Example_Ability()
    _b = MyGame_Example_Test()
    _c = MyGame_Example_Ability()
  }

  public init(_ _t: inout MyGame_Example_StructOfStructs_Mutable) {
    var _va = _t.a
    _a = _va.unpack()
    var _vb = _t.b
    _b = _vb.unpack()
    var _vc = _t.c
    _c = _vc.unpack()
  }

  public var a: MyGame_Example_Ability { _a }
  public var b: MyGame_Example_Test { _b }
  public var c: MyGame_Example_Ability { _c }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_StructOfStructs.self)
  }
}

extension MyGame_Example_StructOfStructs: Encodable {

  enum CodingKeys: String, CodingKey {
    case a = "a"
    case b = "b"
    case c = "c"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(a, forKey: .a)
    try container.encodeIfPresent(b, forKey: .b)
    try container.encodeIfPresent(c, forKey: .c)
  }
}

public struct MyGame_Example_StructOfStructs_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var a: MyGame_Example_Ability_Mutable { return MyGame_Example_Ability_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  public var b: MyGame_Example_Test_Mutable { return MyGame_Example_Test_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  public var c: MyGame_Example_Ability_Mutable { return MyGame_Example_Ability_Mutable(_accessor.bb, o: _accessor.postion + 12) }
  

  public mutating func unpack() -> MyGame_Example_StructOfStructs {
    return MyGame_Example_StructOfStructs(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_StructOfStructs?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_StructOfStructs) -> Offset {
    return builder.create(struct: obj)
  }
}

public struct MyGame_Example_StructOfStructsOfStructs: NativeStruct, Verifiable, FlatbuffersInitializable, NativeObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }

  private var _a: MyGame_Example_StructOfStructs

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _a = MyGame_Example_StructOfStructs(_accessor.bb, o: _accessor.postion + 0)
  }

  public init(a: MyGame_Example_StructOfStructs) {
    _a = a
  }

  public init() {
    _a = MyGame_Example_StructOfStructs()
  }

  public init(_ _t: inout MyGame_Example_StructOfStructsOfStructs_Mutable) {
    var _va = _t.a
    _a = _va.unpack()
  }

  public var a: MyGame_Example_StructOfStructs { _a }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: MyGame_Example_StructOfStructsOfStructs.self)
  }
}

extension MyGame_Example_StructOfStructsOfStructs: Encodable {

  enum CodingKeys: String, CodingKey {
    case a = "a"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(a, forKey: .a)
  }
}

public struct MyGame_Example_StructOfStructsOfStructs_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var a: MyGame_Example_StructOfStructs_Mutable { return MyGame_Example_StructOfStructs_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  

  public mutating func unpack() -> MyGame_Example_StructOfStructsOfStructs {
    return MyGame_Example_StructOfStructsOfStructs(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_StructOfStructsOfStructs?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_StructOfStructsOfStructs) -> Offset {
    return builder.create(struct: obj)
  }
}

public struct MyGame_InParentNamespace: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "MONS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_InParentNamespace.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startInParentNamespace(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endInParentNamespace(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  

  public mutating func unpack() -> MyGame_InParentNamespaceT {
    return MyGame_InParentNamespaceT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_InParentNamespaceT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_InParentNamespaceT) -> Offset {
    let __root = MyGame_InParentNamespace.startInParentNamespace(&builder)
    return MyGame_InParentNamespace.endInParentNamespace(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

extension MyGame_InParentNamespace: Encodable {

  public func encode(to encoder: Encoder) throws {
  }
}

public class MyGame_InParentNamespaceT: NativeObject {


  public init(_ _t: inout MyGame_InParentNamespace) {
  }

  public init() {
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_InParentNamespace.self) }

}
public struct MyGame_Example2_Monster: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "MONS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example2_Monster.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startMonster(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endMonster(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  

  public mutating func unpack() -> MyGame_Example2_MonsterT {
    return MyGame_Example2_MonsterT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example2_MonsterT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example2_MonsterT) -> Offset {
    let __root = MyGame_Example2_Monster.startMonster(&builder)
    return MyGame_Example2_Monster.endMonster(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    _v.finish()
  }
}

extension MyGame_Example2_Monster: Encodable {

  public func encode(to encoder: Encoder) throws {
  }
}

public class MyGame_Example2_MonsterT: NativeObject {


  public init(_ _t: inout MyGame_Example2_Monster) {
  }

  public init() {
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_Example2_Monster.self) }

}
internal struct MyGame_Example_TestSimpleTableWithEnum: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  internal var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  internal static var id: String { "MONS" } 
  internal static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example_TestSimpleTableWithEnum.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  internal init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case color = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  internal var color: MyGame_Example_Color { let o = _accessor.offset(VTOFFSET.color.v); return o == 0 ? .green : MyGame_Example_Color(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .green }
  @discardableResult internal func mutate(color: MyGame_Example_Color) -> Bool {let o = _accessor.offset(VTOFFSET.color.v);  return _accessor.mutate(color.rawValue, index: o) }
  internal static func startTestSimpleTableWithEnum(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  internal static func add(color: MyGame_Example_Color, _ fbb: inout FlatBufferBuilder) { fbb.add(element: color.rawValue, def: 2, at: VTOFFSET.color.p) }
  internal static func endTestSimpleTableWithEnum(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  internal static func createTestSimpleTableWithEnum(
    _ fbb: inout FlatBufferBuilder,
    color: MyGame_Example_Color = .green
  ) -> Offset {
    let __start = MyGame_Example_TestSimpleTableWithEnum.startTestSimpleTableWithEnum(&fbb)
    MyGame_Example_TestSimpleTableWithEnum.add(color: color, &fbb)
    return MyGame_Example_TestSimpleTableWithEnum.endTestSimpleTableWithEnum(&fbb, start: __start)
  }
  

  internal mutating func unpack() -> MyGame_Example_TestSimpleTableWithEnumT {
    return MyGame_Example_TestSimpleTableWithEnumT(&self)
  }
  internal static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_TestSimpleTableWithEnumT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  internal static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_TestSimpleTableWithEnumT) -> Offset {
    let __root = MyGame_Example_TestSimpleTableWithEnum.startTestSimpleTableWithEnum(&builder)
    MyGame_Example_TestSimpleTableWithEnum.add(color: obj.color, &builder)
    return MyGame_Example_TestSimpleTableWithEnum.endTestSimpleTableWithEnum(&builder, start: __root)
  }

  internal static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: false, type: MyGame_Example_Color.self)
    _v.finish()
  }
}

extension MyGame_Example_TestSimpleTableWithEnum: Encodable {

  enum CodingKeys: String, CodingKey {
    case color = "color"
  }
  internal func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if color != .green {
      try container.encodeIfPresent(color, forKey: .color)
    }
  }
}

internal class MyGame_Example_TestSimpleTableWithEnumT: NativeObject {

  internal var color: MyGame_Example_Color

  internal init(_ _t: inout MyGame_Example_TestSimpleTableWithEnum) {
    color = _t.color
  }

  internal init() {
    color = .green
  }

  internal func serialize() -> ByteBuffer { return serialize(type: MyGame_Example_TestSimpleTableWithEnum.self) }

}
public struct MyGame_Example_Stat: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "MONS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example_Stat.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case val = 6
    case count = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var val: Int64 { let o = _accessor.offset(VTOFFSET.val.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  @discardableResult public func mutate(val: Int64) -> Bool {let o = _accessor.offset(VTOFFSET.val.v);  return _accessor.mutate(val, index: o) }
  public var count: UInt16 { let o = _accessor.offset(VTOFFSET.count.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  @discardableResult public func mutate(count: UInt16) -> Bool {let o = _accessor.offset(VTOFFSET.count.v);  return _accessor.mutate(count, index: o) }
  public static func startStat(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(val: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: val, def: 0, at: VTOFFSET.val.p) }
  public static func add(count: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: count, def: 0, at: VTOFFSET.count.p) }
  public static func endStat(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStat(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    val: Int64 = 0,
    count: UInt16 = 0
  ) -> Offset {
    let __start = MyGame_Example_Stat.startStat(&fbb)
    MyGame_Example_Stat.add(id: id, &fbb)
    MyGame_Example_Stat.add(val: val, &fbb)
    MyGame_Example_Stat.add(count: count, &fbb)
    return MyGame_Example_Stat.endStat(&fbb, start: __start)
  }
  public static func sortVectorOfStat(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 8, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 8, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: UInt16, fbb: ByteBuffer) -> MyGame_Example_Stat? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: UInt16.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 8, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return MyGame_Example_Stat(fbb, o: tableOffset)
      }
    }
    return nil
  }
  

  public mutating func unpack() -> MyGame_Example_StatT {
    return MyGame_Example_StatT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_StatT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_StatT) -> Offset {
    let __id: Offset
    if let s = obj.id {
      __id = builder.create(string: s)
    } else {
      __id = Offset()
    }

    let __root = MyGame_Example_Stat.startStat(&builder)
    MyGame_Example_Stat.add(id: __id, &builder)
    MyGame_Example_Stat.add(val: obj.val, &builder)
    MyGame_Example_Stat.add(count: obj.count, &builder)
    return MyGame_Example_Stat.endStat(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.val.p, fieldName: "val", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.count.p, fieldName: "count", required: false, type: UInt16.self)
    _v.finish()
  }
}

extension MyGame_Example_Stat: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
    case val = "val"
    case count = "count"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(id, forKey: .id)
    if val != 0 {
      try container.encodeIfPresent(val, forKey: .val)
    }
    if count != 0 {
      try container.encodeIfPresent(count, forKey: .count)
    }
  }
}

public class MyGame_Example_StatT: NativeObject {

  public var id: String?
  public var val: Int64
  public var count: UInt16

  public init(_ _t: inout MyGame_Example_Stat) {
    id = _t.id
    val = _t.val
    count = _t.count
  }

  public init() {
    val = 0
    count = 0
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_Example_Stat.self) }

}
public struct MyGame_Example_Referrable: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "MONS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example_Referrable.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: UInt64 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(id: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.id.v);  return _accessor.mutate(id, index: o) }
  public static func startReferrable(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(id: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: id, def: 0, at: VTOFFSET.id.p) }
  public static func endReferrable(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createReferrable(
    _ fbb: inout FlatBufferBuilder,
    id: UInt64 = 0
  ) -> Offset {
    let __start = MyGame_Example_Referrable.startReferrable(&fbb)
    MyGame_Example_Referrable.add(id: id, &fbb)
    return MyGame_Example_Referrable.endReferrable(&fbb, start: __start)
  }
  public static func sortVectorOfReferrable(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: UInt64, fbb: ByteBuffer) -> MyGame_Example_Referrable? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: UInt64.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return MyGame_Example_Referrable(fbb, o: tableOffset)
      }
    }
    return nil
  }
  

  public mutating func unpack() -> MyGame_Example_ReferrableT {
    return MyGame_Example_ReferrableT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_ReferrableT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_ReferrableT) -> Offset {
    let __root = MyGame_Example_Referrable.startReferrable(&builder)
    MyGame_Example_Referrable.add(id: obj.id, &builder)
    return MyGame_Example_Referrable.endReferrable(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: UInt64.self)
    _v.finish()
  }
}

extension MyGame_Example_Referrable: Encodable {

  enum CodingKeys: String, CodingKey {
    case id = "id"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if id != 0 {
      try container.encodeIfPresent(id, forKey: .id)
    }
  }
}

public class MyGame_Example_ReferrableT: NativeObject {

  public var id: UInt64

  public init(_ _t: inout MyGame_Example_Referrable) {
    id = _t.id
  }

  public init() {
    id = 0
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_Example_Referrable.self) }

}
///  an example documentation comment: "monster object"
public struct MyGame_Example_Monster: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "MONS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example_Monster.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pos = 4
    case mana = 6
    case hp = 8
    case name = 10
    case inventory = 14
    case color = 16
    case testType = 18
    case test = 20
    case test4 = 22
    case testarrayofstring = 24
    case testarrayoftables = 26
    case enemy = 28
    case testnestedflatbuffer = 30
    case testempty = 32
    case testbool = 34
    case testhashs32Fnv1 = 36
    case testhashu32Fnv1 = 38
    case testhashs64Fnv1 = 40
    case testhashu64Fnv1 = 42
    case testhashs32Fnv1a = 44
    case testhashu32Fnv1a = 46
    case testhashs64Fnv1a = 48
    case testhashu64Fnv1a = 50
    case testarrayofbools = 52
    case testf = 54
    case testf2 = 56
    case testf3 = 58
    case testarrayofstring2 = 60
    case testarrayofsortedstruct = 62
    case flex = 64
    case test5 = 66
    case vectorOfLongs = 68
    case vectorOfDoubles = 70
    case parentNamespaceTest = 72
    case vectorOfReferrables = 74
    case singleWeakReference = 76
    case vectorOfWeakReferences = 78
    case vectorOfStrongReferrables = 80
    case coOwningReference = 82
    case vectorOfCoOwningReferences = 84
    case nonOwningReference = 86
    case vectorOfNonOwningReferences = 88
    case anyUniqueType = 90
    case anyUnique = 92
    case anyAmbiguousType = 94
    case anyAmbiguous = 96
    case vectorOfEnums = 98
    case signedEnum = 100
    case testrequirednestedflatbuffer = 102
    case scalarKeySortedTables = 104
    case nativeInline = 106
    case longEnumNonEnumDefault = 108
    case longEnumNormalDefault = 110
    case nanDefault = 112
    case infDefault = 114
    case positiveInfDefault = 116
    case infinityDefault = 118
    case positiveInfinityDefault = 120
    case negativeInfDefault = 122
    case negativeInfinityDefault = 124
    case doubleInfDefault = 126
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var pos: MyGame_Example_Vec3? { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? nil : _accessor.readBuffer(of: MyGame_Example_Vec3.self, at: o) }
  public var mutablePos: MyGame_Example_Vec3_Mutable? { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? nil : MyGame_Example_Vec3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var mana: Int16 { let o = _accessor.offset(VTOFFSET.mana.v); return o == 0 ? 150 : _accessor.readBuffer(of: Int16.self, at: o) }
  @discardableResult public func mutate(mana: Int16) -> Bool {let o = _accessor.offset(VTOFFSET.mana.v);  return _accessor.mutate(mana, index: o) }
  public var hp: Int16 { let o = _accessor.offset(VTOFFSET.hp.v); return o == 0 ? 100 : _accessor.readBuffer(of: Int16.self, at: o) }
  @discardableResult public func mutate(hp: Int16) -> Bool {let o = _accessor.offset(VTOFFSET.hp.v);  return _accessor.mutate(hp, index: o) }
  public var name: String! { let o = _accessor.offset(VTOFFSET.name.v); return _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var hasInventory: Bool { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? false : true }
  public var inventoryCount: Int32 { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func inventory(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var inventory: [UInt8] { return _accessor.getVector(at: VTOFFSET.inventory.v) ?? [] }
  public func mutate(inventory: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.inventory.v); return _accessor.directMutate(inventory, index: _accessor.vector(at: o) + index * 1) }
  public var color: MyGame_Example_Color { let o = _accessor.offset(VTOFFSET.color.v); return o == 0 ? .blue : MyGame_Example_Color(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .blue }
  @discardableResult public func mutate(color: MyGame_Example_Color) -> Bool {let o = _accessor.offset(VTOFFSET.color.v);  return _accessor.mutate(color.rawValue, index: o) }
  public var testType: MyGame_Example_Any_ { let o = _accessor.offset(VTOFFSET.testType.v); return o == 0 ? .none_ : MyGame_Example_Any_(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func test<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.test.v); return o == 0 ? nil : _accessor.union(o) }
  public var hasTest4: Bool { let o = _accessor.offset(VTOFFSET.test4.v); return o == 0 ? false : true }
  public var test4Count: Int32 { let o = _accessor.offset(VTOFFSET.test4.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func test4(at index: Int32) -> MyGame_Example_Test? { let o = _accessor.offset(VTOFFSET.test4.v); return o == 0 ? nil : _accessor.directRead(of: MyGame_Example_Test.self, offset: _accessor.vector(at: o) + index * 4) }
  public func mutableTest4(at index: Int32) -> MyGame_Example_Test_Mutable? { let o = _accessor.offset(VTOFFSET.test4.v); return o == 0 ? nil : MyGame_Example_Test_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
  public var hasTestarrayofstring: Bool { let o = _accessor.offset(VTOFFSET.testarrayofstring.v); return o == 0 ? false : true }
  public var testarrayofstringCount: Int32 { let o = _accessor.offset(VTOFFSET.testarrayofstring.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testarrayofstring(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.testarrayofstring.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  an example documentation comment: this will end up in the generated code
  ///  multiline too
  public var hasTestarrayoftables: Bool { let o = _accessor.offset(VTOFFSET.testarrayoftables.v); return o == 0 ? false : true }
  public var testarrayoftablesCount: Int32 { let o = _accessor.offset(VTOFFSET.testarrayoftables.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testarrayoftables(at index: Int32) -> MyGame_Example_Monster? { let o = _accessor.offset(VTOFFSET.testarrayoftables.v); return o == 0 ? nil : MyGame_Example_Monster(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func testarrayoftablesBy(key: String) -> MyGame_Example_Monster? { let o = _accessor.offset(VTOFFSET.testarrayoftables.v); return o == 0 ? nil : MyGame_Example_Monster.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var enemy: MyGame_Example_Monster? { let o = _accessor.offset(VTOFFSET.enemy.v); return o == 0 ? nil : MyGame_Example_Monster(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var hasTestnestedflatbuffer: Bool { let o = _accessor.offset(VTOFFSET.testnestedflatbuffer.v); return o == 0 ? false : true }
  public var testnestedflatbufferCount: Int32 { let o = _accessor.offset(VTOFFSET.testnestedflatbuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testnestedflatbuffer(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.testnestedflatbuffer.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var testnestedflatbuffer: [UInt8] { return _accessor.getVector(at: VTOFFSET.testnestedflatbuffer.v) ?? [] }
  public func mutate(testnestedflatbuffer: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.testnestedflatbuffer.v); return _accessor.directMutate(testnestedflatbuffer, index: _accessor.vector(at: o) + index * 1) }
  public var testempty: MyGame_Example_Stat? { let o = _accessor.offset(VTOFFSET.testempty.v); return o == 0 ? nil : MyGame_Example_Stat(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var testbool: Bool { let o = _accessor.offset(VTOFFSET.testbool.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(testbool: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.testbool.v);  return _accessor.mutate(testbool, index: o) }
  public var testhashs32Fnv1: Int32 { let o = _accessor.offset(VTOFFSET.testhashs32Fnv1.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  @discardableResult public func mutate(testhashs32Fnv1: Int32) -> Bool {let o = _accessor.offset(VTOFFSET.testhashs32Fnv1.v);  return _accessor.mutate(testhashs32Fnv1, index: o) }
  public var testhashu32Fnv1: UInt32 { let o = _accessor.offset(VTOFFSET.testhashu32Fnv1.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  @discardableResult public func mutate(testhashu32Fnv1: UInt32) -> Bool {let o = _accessor.offset(VTOFFSET.testhashu32Fnv1.v);  return _accessor.mutate(testhashu32Fnv1, index: o) }
  public var testhashs64Fnv1: Int64 { let o = _accessor.offset(VTOFFSET.testhashs64Fnv1.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  @discardableResult public func mutate(testhashs64Fnv1: Int64) -> Bool {let o = _accessor.offset(VTOFFSET.testhashs64Fnv1.v);  return _accessor.mutate(testhashs64Fnv1, index: o) }
  public var testhashu64Fnv1: UInt64 { let o = _accessor.offset(VTOFFSET.testhashu64Fnv1.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(testhashu64Fnv1: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.testhashu64Fnv1.v);  return _accessor.mutate(testhashu64Fnv1, index: o) }
  public var testhashs32Fnv1a: Int32 { let o = _accessor.offset(VTOFFSET.testhashs32Fnv1a.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  @discardableResult public func mutate(testhashs32Fnv1a: Int32) -> Bool {let o = _accessor.offset(VTOFFSET.testhashs32Fnv1a.v);  return _accessor.mutate(testhashs32Fnv1a, index: o) }
  public var testhashu32Fnv1a: UInt32 { let o = _accessor.offset(VTOFFSET.testhashu32Fnv1a.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  @discardableResult public func mutate(testhashu32Fnv1a: UInt32) -> Bool {let o = _accessor.offset(VTOFFSET.testhashu32Fnv1a.v);  return _accessor.mutate(testhashu32Fnv1a, index: o) }
  public var testhashs64Fnv1a: Int64 { let o = _accessor.offset(VTOFFSET.testhashs64Fnv1a.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  @discardableResult public func mutate(testhashs64Fnv1a: Int64) -> Bool {let o = _accessor.offset(VTOFFSET.testhashs64Fnv1a.v);  return _accessor.mutate(testhashs64Fnv1a, index: o) }
  public var testhashu64Fnv1a: UInt64 { let o = _accessor.offset(VTOFFSET.testhashu64Fnv1a.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(testhashu64Fnv1a: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.testhashu64Fnv1a.v);  return _accessor.mutate(testhashu64Fnv1a, index: o) }
  public var hasTestarrayofbools: Bool { let o = _accessor.offset(VTOFFSET.testarrayofbools.v); return o == 0 ? false : true }
  public var testarrayofboolsCount: Int32 { let o = _accessor.offset(VTOFFSET.testarrayofbools.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testarrayofbools(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.testarrayofbools.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  public var testarrayofbools: [Bool] { return _accessor.getVector(at: VTOFFSET.testarrayofbools.v) ?? [] }
  public func mutate(testarrayofbools: Bool, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.testarrayofbools.v); return _accessor.directMutate(testarrayofbools, index: _accessor.vector(at: o) + index * 1) }
  public var testf: Float32 { let o = _accessor.offset(VTOFFSET.testf.v); return o == 0 ? 3.14159 : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(testf: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.testf.v);  return _accessor.mutate(testf, index: o) }
  public var testf2: Float32 { let o = _accessor.offset(VTOFFSET.testf2.v); return o == 0 ? 3.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(testf2: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.testf2.v);  return _accessor.mutate(testf2, index: o) }
  public var testf3: Float32 { let o = _accessor.offset(VTOFFSET.testf3.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(testf3: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.testf3.v);  return _accessor.mutate(testf3, index: o) }
  public var hasTestarrayofstring2: Bool { let o = _accessor.offset(VTOFFSET.testarrayofstring2.v); return o == 0 ? false : true }
  public var testarrayofstring2Count: Int32 { let o = _accessor.offset(VTOFFSET.testarrayofstring2.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testarrayofstring2(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.testarrayofstring2.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var hasTestarrayofsortedstruct: Bool { let o = _accessor.offset(VTOFFSET.testarrayofsortedstruct.v); return o == 0 ? false : true }
  public var testarrayofsortedstructCount: Int32 { let o = _accessor.offset(VTOFFSET.testarrayofsortedstruct.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testarrayofsortedstruct(at index: Int32) -> MyGame_Example_Ability? { let o = _accessor.offset(VTOFFSET.testarrayofsortedstruct.v); return o == 0 ? nil : _accessor.directRead(of: MyGame_Example_Ability.self, offset: _accessor.vector(at: o) + index * 8) }
  public func mutableTestarrayofsortedstruct(at index: Int32) -> MyGame_Example_Ability_Mutable? { let o = _accessor.offset(VTOFFSET.testarrayofsortedstruct.v); return o == 0 ? nil : MyGame_Example_Ability_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 8) }
  public var hasFlex: Bool { let o = _accessor.offset(VTOFFSET.flex.v); return o == 0 ? false : true }
  public var flexCount: Int32 { let o = _accessor.offset(VTOFFSET.flex.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func flex(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.flex.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var flex: [UInt8] { return _accessor.getVector(at: VTOFFSET.flex.v) ?? [] }
  public func mutate(flex: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.flex.v); return _accessor.directMutate(flex, index: _accessor.vector(at: o) + index * 1) }
  public var hasTest5: Bool { let o = _accessor.offset(VTOFFSET.test5.v); return o == 0 ? false : true }
  public var test5Count: Int32 { let o = _accessor.offset(VTOFFSET.test5.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func test5(at index: Int32) -> MyGame_Example_Test? { let o = _accessor.offset(VTOFFSET.test5.v); return o == 0 ? nil : _accessor.directRead(of: MyGame_Example_Test.self, offset: _accessor.vector(at: o) + index * 4) }
  public func mutableTest5(at index: Int32) -> MyGame_Example_Test_Mutable? { let o = _accessor.offset(VTOFFSET.test5.v); return o == 0 ? nil : MyGame_Example_Test_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 4) }
  public var hasVectorOfLongs: Bool { let o = _accessor.offset(VTOFFSET.vectorOfLongs.v); return o == 0 ? false : true }
  public var vectorOfLongsCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfLongs.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfLongs(at index: Int32) -> Int64 { let o = _accessor.offset(VTOFFSET.vectorOfLongs.v); return o == 0 ? 0 : _accessor.directRead(of: Int64.self, offset: _accessor.vector(at: o) + index * 8) }
  public var vectorOfLongs: [Int64] { return _accessor.getVector(at: VTOFFSET.vectorOfLongs.v) ?? [] }
  public func mutate(vectorOfLongs: Int64, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.vectorOfLongs.v); return _accessor.directMutate(vectorOfLongs, index: _accessor.vector(at: o) + index * 8) }
  public var hasVectorOfDoubles: Bool { let o = _accessor.offset(VTOFFSET.vectorOfDoubles.v); return o == 0 ? false : true }
  public var vectorOfDoublesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfDoubles.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfDoubles(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.vectorOfDoubles.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var vectorOfDoubles: [Double] { return _accessor.getVector(at: VTOFFSET.vectorOfDoubles.v) ?? [] }
  public func mutate(vectorOfDoubles: Double, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.vectorOfDoubles.v); return _accessor.directMutate(vectorOfDoubles, index: _accessor.vector(at: o) + index * 8) }
  public var parentNamespaceTest: MyGame_InParentNamespace? { let o = _accessor.offset(VTOFFSET.parentNamespaceTest.v); return o == 0 ? nil : MyGame_InParentNamespace(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var hasVectorOfReferrables: Bool { let o = _accessor.offset(VTOFFSET.vectorOfReferrables.v); return o == 0 ? false : true }
  public var vectorOfReferrablesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfReferrables.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfReferrables(at index: Int32) -> MyGame_Example_Referrable? { let o = _accessor.offset(VTOFFSET.vectorOfReferrables.v); return o == 0 ? nil : MyGame_Example_Referrable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func vectorOfReferrablesBy(key: UInt64) -> MyGame_Example_Referrable? { let o = _accessor.offset(VTOFFSET.vectorOfReferrables.v); return o == 0 ? nil : MyGame_Example_Referrable.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var singleWeakReference: UInt64 { let o = _accessor.offset(VTOFFSET.singleWeakReference.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(singleWeakReference: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.singleWeakReference.v);  return _accessor.mutate(singleWeakReference, index: o) }
  public var hasVectorOfWeakReferences: Bool { let o = _accessor.offset(VTOFFSET.vectorOfWeakReferences.v); return o == 0 ? false : true }
  public var vectorOfWeakReferencesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfWeakReferences.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfWeakReferences(at index: Int32) -> UInt64 { let o = _accessor.offset(VTOFFSET.vectorOfWeakReferences.v); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
  public var vectorOfWeakReferences: [UInt64] { return _accessor.getVector(at: VTOFFSET.vectorOfWeakReferences.v) ?? [] }
  public func mutate(vectorOfWeakReferences: UInt64, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.vectorOfWeakReferences.v); return _accessor.directMutate(vectorOfWeakReferences, index: _accessor.vector(at: o) + index * 8) }
  public var hasVectorOfStrongReferrables: Bool { let o = _accessor.offset(VTOFFSET.vectorOfStrongReferrables.v); return o == 0 ? false : true }
  public var vectorOfStrongReferrablesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfStrongReferrables.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfStrongReferrables(at index: Int32) -> MyGame_Example_Referrable? { let o = _accessor.offset(VTOFFSET.vectorOfStrongReferrables.v); return o == 0 ? nil : MyGame_Example_Referrable(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func vectorOfStrongReferrablesBy(key: UInt64) -> MyGame_Example_Referrable? { let o = _accessor.offset(VTOFFSET.vectorOfStrongReferrables.v); return o == 0 ? nil : MyGame_Example_Referrable.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var coOwningReference: UInt64 { let o = _accessor.offset(VTOFFSET.coOwningReference.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(coOwningReference: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.coOwningReference.v);  return _accessor.mutate(coOwningReference, index: o) }
  public var hasVectorOfCoOwningReferences: Bool { let o = _accessor.offset(VTOFFSET.vectorOfCoOwningReferences.v); return o == 0 ? false : true }
  public var vectorOfCoOwningReferencesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfCoOwningReferences.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfCoOwningReferences(at index: Int32) -> UInt64 { let o = _accessor.offset(VTOFFSET.vectorOfCoOwningReferences.v); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
  public var vectorOfCoOwningReferences: [UInt64] { return _accessor.getVector(at: VTOFFSET.vectorOfCoOwningReferences.v) ?? [] }
  public func mutate(vectorOfCoOwningReferences: UInt64, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.vectorOfCoOwningReferences.v); return _accessor.directMutate(vectorOfCoOwningReferences, index: _accessor.vector(at: o) + index * 8) }
  public var nonOwningReference: UInt64 { let o = _accessor.offset(VTOFFSET.nonOwningReference.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(nonOwningReference: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.nonOwningReference.v);  return _accessor.mutate(nonOwningReference, index: o) }
  public var hasVectorOfNonOwningReferences: Bool { let o = _accessor.offset(VTOFFSET.vectorOfNonOwningReferences.v); return o == 0 ? false : true }
  public var vectorOfNonOwningReferencesCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfNonOwningReferences.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfNonOwningReferences(at index: Int32) -> UInt64 { let o = _accessor.offset(VTOFFSET.vectorOfNonOwningReferences.v); return o == 0 ? 0 : _accessor.directRead(of: UInt64.self, offset: _accessor.vector(at: o) + index * 8) }
  public var vectorOfNonOwningReferences: [UInt64] { return _accessor.getVector(at: VTOFFSET.vectorOfNonOwningReferences.v) ?? [] }
  public func mutate(vectorOfNonOwningReferences: UInt64, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.vectorOfNonOwningReferences.v); return _accessor.directMutate(vectorOfNonOwningReferences, index: _accessor.vector(at: o) + index * 8) }
  public var anyUniqueType: MyGame_Example_AnyUniqueAliases { let o = _accessor.offset(VTOFFSET.anyUniqueType.v); return o == 0 ? .none_ : MyGame_Example_AnyUniqueAliases(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func anyUnique<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.anyUnique.v); return o == 0 ? nil : _accessor.union(o) }
  public var anyAmbiguousType: MyGame_Example_AnyAmbiguousAliases { let o = _accessor.offset(VTOFFSET.anyAmbiguousType.v); return o == 0 ? .none_ : MyGame_Example_AnyAmbiguousAliases(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func anyAmbiguous<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.anyAmbiguous.v); return o == 0 ? nil : _accessor.union(o) }
  public var hasVectorOfEnums: Bool { let o = _accessor.offset(VTOFFSET.vectorOfEnums.v); return o == 0 ? false : true }
  public var vectorOfEnumsCount: Int32 { let o = _accessor.offset(VTOFFSET.vectorOfEnums.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vectorOfEnums(at index: Int32) -> MyGame_Example_Color? { let o = _accessor.offset(VTOFFSET.vectorOfEnums.v); return o == 0 ? MyGame_Example_Color.red : MyGame_Example_Color(rawValue: _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1)) }
  public var signedEnum: MyGame_Example_Race { let o = _accessor.offset(VTOFFSET.signedEnum.v); return o == 0 ? .none_ : MyGame_Example_Race(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  @discardableResult public func mutate(signedEnum: MyGame_Example_Race) -> Bool {let o = _accessor.offset(VTOFFSET.signedEnum.v);  return _accessor.mutate(signedEnum.rawValue, index: o) }
  public var hasTestrequirednestedflatbuffer: Bool { let o = _accessor.offset(VTOFFSET.testrequirednestedflatbuffer.v); return o == 0 ? false : true }
  public var testrequirednestedflatbufferCount: Int32 { let o = _accessor.offset(VTOFFSET.testrequirednestedflatbuffer.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func testrequirednestedflatbuffer(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.testrequirednestedflatbuffer.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var testrequirednestedflatbuffer: [UInt8] { return _accessor.getVector(at: VTOFFSET.testrequirednestedflatbuffer.v) ?? [] }
  public func mutate(testrequirednestedflatbuffer: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.testrequirednestedflatbuffer.v); return _accessor.directMutate(testrequirednestedflatbuffer, index: _accessor.vector(at: o) + index * 1) }
  public var hasScalarKeySortedTables: Bool { let o = _accessor.offset(VTOFFSET.scalarKeySortedTables.v); return o == 0 ? false : true }
  public var scalarKeySortedTablesCount: Int32 { let o = _accessor.offset(VTOFFSET.scalarKeySortedTables.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func scalarKeySortedTables(at index: Int32) -> MyGame_Example_Stat? { let o = _accessor.offset(VTOFFSET.scalarKeySortedTables.v); return o == 0 ? nil : MyGame_Example_Stat(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func scalarKeySortedTablesBy(key: UInt16) -> MyGame_Example_Stat? { let o = _accessor.offset(VTOFFSET.scalarKeySortedTables.v); return o == 0 ? nil : MyGame_Example_Stat.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var nativeInline: MyGame_Example_Test? { let o = _accessor.offset(VTOFFSET.nativeInline.v); return o == 0 ? nil : _accessor.readBuffer(of: MyGame_Example_Test.self, at: o) }
  public var mutableNativeInline: MyGame_Example_Test_Mutable? { let o = _accessor.offset(VTOFFSET.nativeInline.v); return o == 0 ? nil : MyGame_Example_Test_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var longEnumNonEnumDefault: MyGame_Example_LongEnum { let o = _accessor.offset(VTOFFSET.longEnumNonEnumDefault.v); return o == 0 ? .longone : MyGame_Example_LongEnum(rawValue: _accessor.readBuffer(of: UInt64.self, at: o)) ?? .longone }
  @discardableResult public func mutate(longEnumNonEnumDefault: MyGame_Example_LongEnum) -> Bool {let o = _accessor.offset(VTOFFSET.longEnumNonEnumDefault.v);  return _accessor.mutate(longEnumNonEnumDefault.rawValue, index: o) }
  public var longEnumNormalDefault: MyGame_Example_LongEnum { let o = _accessor.offset(VTOFFSET.longEnumNormalDefault.v); return o == 0 ? .longone : MyGame_Example_LongEnum(rawValue: _accessor.readBuffer(of: UInt64.self, at: o)) ?? .longone }
  @discardableResult public func mutate(longEnumNormalDefault: MyGame_Example_LongEnum) -> Bool {let o = _accessor.offset(VTOFFSET.longEnumNormalDefault.v);  return _accessor.mutate(longEnumNormalDefault.rawValue, index: o) }
  public var nanDefault: Float32 { let o = _accessor.offset(VTOFFSET.nanDefault.v); return o == 0 ? .nan : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(nanDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.nanDefault.v);  return _accessor.mutate(nanDefault, index: o) }
  public var infDefault: Float32 { let o = _accessor.offset(VTOFFSET.infDefault.v); return o == 0 ? .infinity : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(infDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.infDefault.v);  return _accessor.mutate(infDefault, index: o) }
  public var positiveInfDefault: Float32 { let o = _accessor.offset(VTOFFSET.positiveInfDefault.v); return o == 0 ? .infinity : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(positiveInfDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.positiveInfDefault.v);  return _accessor.mutate(positiveInfDefault, index: o) }
  public var infinityDefault: Float32 { let o = _accessor.offset(VTOFFSET.infinityDefault.v); return o == 0 ? .infinity : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(infinityDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.infinityDefault.v);  return _accessor.mutate(infinityDefault, index: o) }
  public var positiveInfinityDefault: Float32 { let o = _accessor.offset(VTOFFSET.positiveInfinityDefault.v); return o == 0 ? .infinity : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(positiveInfinityDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.positiveInfinityDefault.v);  return _accessor.mutate(positiveInfinityDefault, index: o) }
  public var negativeInfDefault: Float32 { let o = _accessor.offset(VTOFFSET.negativeInfDefault.v); return o == 0 ? -.infinity : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(negativeInfDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.negativeInfDefault.v);  return _accessor.mutate(negativeInfDefault, index: o) }
  public var negativeInfinityDefault: Float32 { let o = _accessor.offset(VTOFFSET.negativeInfinityDefault.v); return o == 0 ? -.infinity : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(negativeInfinityDefault: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.negativeInfinityDefault.v);  return _accessor.mutate(negativeInfinityDefault, index: o) }
  public var doubleInfDefault: Double { let o = _accessor.offset(VTOFFSET.doubleInfDefault.v); return o == 0 ? .infinity : _accessor.readBuffer(of: Double.self, at: o) }
  @discardableResult public func mutate(doubleInfDefault: Double) -> Bool {let o = _accessor.offset(VTOFFSET.doubleInfDefault.v);  return _accessor.mutate(doubleInfDefault, index: o) }
  public static func startMonster(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 62) }
  public static func add(pos: MyGame_Example_Vec3?, _ fbb: inout FlatBufferBuilder) { guard let pos = pos else { return }; fbb.create(struct: pos, position: VTOFFSET.pos.p) }
  public static func add(mana: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mana, def: 150, at: VTOFFSET.mana.p) }
  public static func add(hp: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hp, def: 100, at: VTOFFSET.hp.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func addVectorOf(inventory: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inventory, at: VTOFFSET.inventory.p) }
  public static func add(color: MyGame_Example_Color, _ fbb: inout FlatBufferBuilder) { fbb.add(element: color.rawValue, def: 8, at: VTOFFSET.color.p) }
  public static func add(testType: MyGame_Example_Any_, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testType.rawValue, def: 0, at: VTOFFSET.testType.p) }
  public static func add(test: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: test, at: VTOFFSET.test.p) }
  public static func addVectorOf(test4: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: test4, at: VTOFFSET.test4.p) }
  public static func startVectorOfTest4(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<MyGame_Example_Test>.size, elementSize: MemoryLayout<MyGame_Example_Test>.alignment)
  }
  public static func addVectorOf(testarrayofstring: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testarrayofstring, at: VTOFFSET.testarrayofstring.p) }
  public static func addVectorOf(testarrayoftables: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testarrayoftables, at: VTOFFSET.testarrayoftables.p) }
  public static func add(enemy: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: enemy, at: VTOFFSET.enemy.p) }
  public static func addVectorOf(testnestedflatbuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testnestedflatbuffer, at: VTOFFSET.testnestedflatbuffer.p) }
  public static func add(testempty: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testempty, at: VTOFFSET.testempty.p) }
  public static func add(testbool: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testbool, def: false,
   at: VTOFFSET.testbool.p) }
  public static func add(testhashs32Fnv1: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashs32Fnv1, def: 0, at: VTOFFSET.testhashs32Fnv1.p) }
  public static func add(testhashu32Fnv1: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashu32Fnv1, def: 0, at: VTOFFSET.testhashu32Fnv1.p) }
  public static func add(testhashs64Fnv1: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashs64Fnv1, def: 0, at: VTOFFSET.testhashs64Fnv1.p) }
  public static func add(testhashu64Fnv1: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashu64Fnv1, def: 0, at: VTOFFSET.testhashu64Fnv1.p) }
  public static func add(testhashs32Fnv1a: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashs32Fnv1a, def: 0, at: VTOFFSET.testhashs32Fnv1a.p) }
  public static func add(testhashu32Fnv1a: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashu32Fnv1a, def: 0, at: VTOFFSET.testhashu32Fnv1a.p) }
  public static func add(testhashs64Fnv1a: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashs64Fnv1a, def: 0, at: VTOFFSET.testhashs64Fnv1a.p) }
  public static func add(testhashu64Fnv1a: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testhashu64Fnv1a, def: 0, at: VTOFFSET.testhashu64Fnv1a.p) }
  public static func addVectorOf(testarrayofbools: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testarrayofbools, at: VTOFFSET.testarrayofbools.p) }
  public static func add(testf: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testf, def: 3.14159, at: VTOFFSET.testf.p) }
  public static func add(testf2: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testf2, def: 3.0, at: VTOFFSET.testf2.p) }
  public static func add(testf3: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: testf3, def: 0.0, at: VTOFFSET.testf3.p) }
  public static func addVectorOf(testarrayofstring2: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testarrayofstring2, at: VTOFFSET.testarrayofstring2.p) }
  public static func addVectorOf(testarrayofsortedstruct: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testarrayofsortedstruct, at: VTOFFSET.testarrayofsortedstruct.p) }
  public static func startVectorOfTestarrayofsortedstruct(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<MyGame_Example_Ability>.size, elementSize: MemoryLayout<MyGame_Example_Ability>.alignment)
  }
  public static func addVectorOf(flex: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: flex, at: VTOFFSET.flex.p) }
  public static func addVectorOf(test5: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: test5, at: VTOFFSET.test5.p) }
  public static func startVectorOfTest5(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<MyGame_Example_Test>.size, elementSize: MemoryLayout<MyGame_Example_Test>.alignment)
  }
  public static func addVectorOf(vectorOfLongs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfLongs, at: VTOFFSET.vectorOfLongs.p) }
  public static func addVectorOf(vectorOfDoubles: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfDoubles, at: VTOFFSET.vectorOfDoubles.p) }
  public static func add(parentNamespaceTest: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: parentNamespaceTest, at: VTOFFSET.parentNamespaceTest.p) }
  public static func addVectorOf(vectorOfReferrables: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfReferrables, at: VTOFFSET.vectorOfReferrables.p) }
  public static func add(singleWeakReference: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: singleWeakReference, def: 0, at: VTOFFSET.singleWeakReference.p) }
  public static func addVectorOf(vectorOfWeakReferences: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfWeakReferences, at: VTOFFSET.vectorOfWeakReferences.p) }
  public static func addVectorOf(vectorOfStrongReferrables: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfStrongReferrables, at: VTOFFSET.vectorOfStrongReferrables.p) }
  public static func add(coOwningReference: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: coOwningReference, def: 0, at: VTOFFSET.coOwningReference.p) }
  public static func addVectorOf(vectorOfCoOwningReferences: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfCoOwningReferences, at: VTOFFSET.vectorOfCoOwningReferences.p) }
  public static func add(nonOwningReference: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nonOwningReference, def: 0, at: VTOFFSET.nonOwningReference.p) }
  public static func addVectorOf(vectorOfNonOwningReferences: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfNonOwningReferences, at: VTOFFSET.vectorOfNonOwningReferences.p) }
  public static func add(anyUniqueType: MyGame_Example_AnyUniqueAliases, _ fbb: inout FlatBufferBuilder) { fbb.add(element: anyUniqueType.rawValue, def: 0, at: VTOFFSET.anyUniqueType.p) }
  public static func add(anyUnique: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: anyUnique, at: VTOFFSET.anyUnique.p) }
  public static func add(anyAmbiguousType: MyGame_Example_AnyAmbiguousAliases, _ fbb: inout FlatBufferBuilder) { fbb.add(element: anyAmbiguousType.rawValue, def: 0, at: VTOFFSET.anyAmbiguousType.p) }
  public static func add(anyAmbiguous: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: anyAmbiguous, at: VTOFFSET.anyAmbiguous.p) }
  public static func addVectorOf(vectorOfEnums: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vectorOfEnums, at: VTOFFSET.vectorOfEnums.p) }
  public static func add(signedEnum: MyGame_Example_Race, _ fbb: inout FlatBufferBuilder) { fbb.add(element: signedEnum.rawValue, def: -1, at: VTOFFSET.signedEnum.p) }
  public static func addVectorOf(testrequirednestedflatbuffer: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: testrequirednestedflatbuffer, at: VTOFFSET.testrequirednestedflatbuffer.p) }
  public static func addVectorOf(scalarKeySortedTables: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scalarKeySortedTables, at: VTOFFSET.scalarKeySortedTables.p) }
  public static func add(nativeInline: MyGame_Example_Test?, _ fbb: inout FlatBufferBuilder) { guard let nativeInline = nativeInline else { return }; fbb.create(struct: nativeInline, position: VTOFFSET.nativeInline.p) }
  public static func add(longEnumNonEnumDefault: MyGame_Example_LongEnum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longEnumNonEnumDefault.rawValue, def: 0, at: VTOFFSET.longEnumNonEnumDefault.p) }
  public static func add(longEnumNormalDefault: MyGame_Example_LongEnum, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longEnumNormalDefault.rawValue, def: 2, at: VTOFFSET.longEnumNormalDefault.p) }
  public static func add(nanDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: nanDefault, def: .nan, at: VTOFFSET.nanDefault.p) }
  public static func add(infDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: infDefault, def: .infinity, at: VTOFFSET.infDefault.p) }
  public static func add(positiveInfDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: positiveInfDefault, def: .infinity, at: VTOFFSET.positiveInfDefault.p) }
  public static func add(infinityDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: infinityDefault, def: .infinity, at: VTOFFSET.infinityDefault.p) }
  public static func add(positiveInfinityDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: positiveInfinityDefault, def: .infinity, at: VTOFFSET.positiveInfinityDefault.p) }
  public static func add(negativeInfDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativeInfDefault, def: -.infinity, at: VTOFFSET.negativeInfDefault.p) }
  public static func add(negativeInfinityDefault: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: negativeInfinityDefault, def: -.infinity, at: VTOFFSET.negativeInfinityDefault.p) }
  public static func add(doubleInfDefault: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: doubleInfDefault, def: .infinity, at: VTOFFSET.doubleInfDefault.p) }
  public static func endMonster(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [10]); return end }
  public static func createMonster(
    _ fbb: inout FlatBufferBuilder,
    pos: MyGame_Example_Vec3? = nil,
    mana: Int16 = 150,
    hp: Int16 = 100,
    nameOffset name: Offset,
    inventoryVectorOffset inventory: Offset = Offset(),
    color: MyGame_Example_Color = .blue,
    testType: MyGame_Example_Any_ = .none_,
    testOffset test: Offset = Offset(),
    test4VectorOffset test4: Offset = Offset(),
    testarrayofstringVectorOffset testarrayofstring: Offset = Offset(),
    testarrayoftablesVectorOffset testarrayoftables: Offset = Offset(),
    enemyOffset enemy: Offset = Offset(),
    testnestedflatbufferVectorOffset testnestedflatbuffer: Offset = Offset(),
    testemptyOffset testempty: Offset = Offset(),
    testbool: Bool = false,
    testhashs32Fnv1: Int32 = 0,
    testhashu32Fnv1: UInt32 = 0,
    testhashs64Fnv1: Int64 = 0,
    testhashu64Fnv1: UInt64 = 0,
    testhashs32Fnv1a: Int32 = 0,
    testhashu32Fnv1a: UInt32 = 0,
    testhashs64Fnv1a: Int64 = 0,
    testhashu64Fnv1a: UInt64 = 0,
    testarrayofboolsVectorOffset testarrayofbools: Offset = Offset(),
    testf: Float32 = 3.14159,
    testf2: Float32 = 3.0,
    testf3: Float32 = 0.0,
    testarrayofstring2VectorOffset testarrayofstring2: Offset = Offset(),
    testarrayofsortedstructVectorOffset testarrayofsortedstruct: Offset = Offset(),
    flexVectorOffset flex: Offset = Offset(),
    test5VectorOffset test5: Offset = Offset(),
    vectorOfLongsVectorOffset vectorOfLongs: Offset = Offset(),
    vectorOfDoublesVectorOffset vectorOfDoubles: Offset = Offset(),
    parentNamespaceTestOffset parentNamespaceTest: Offset = Offset(),
    vectorOfReferrablesVectorOffset vectorOfReferrables: Offset = Offset(),
    singleWeakReference: UInt64 = 0,
    vectorOfWeakReferencesVectorOffset vectorOfWeakReferences: Offset = Offset(),
    vectorOfStrongReferrablesVectorOffset vectorOfStrongReferrables: Offset = Offset(),
    coOwningReference: UInt64 = 0,
    vectorOfCoOwningReferencesVectorOffset vectorOfCoOwningReferences: Offset = Offset(),
    nonOwningReference: UInt64 = 0,
    vectorOfNonOwningReferencesVectorOffset vectorOfNonOwningReferences: Offset = Offset(),
    anyUniqueType: MyGame_Example_AnyUniqueAliases = .none_,
    anyUniqueOffset anyUnique: Offset = Offset(),
    anyAmbiguousType: MyGame_Example_AnyAmbiguousAliases = .none_,
    anyAmbiguousOffset anyAmbiguous: Offset = Offset(),
    vectorOfEnumsVectorOffset vectorOfEnums: Offset = Offset(),
    signedEnum: MyGame_Example_Race = .none_,
    testrequirednestedflatbufferVectorOffset testrequirednestedflatbuffer: Offset = Offset(),
    scalarKeySortedTablesVectorOffset scalarKeySortedTables: Offset = Offset(),
    nativeInline: MyGame_Example_Test? = nil,
    longEnumNonEnumDefault: MyGame_Example_LongEnum = .longone,
    longEnumNormalDefault: MyGame_Example_LongEnum = .longone,
    nanDefault: Float32 = .nan,
    infDefault: Float32 = .infinity,
    positiveInfDefault: Float32 = .infinity,
    infinityDefault: Float32 = .infinity,
    positiveInfinityDefault: Float32 = .infinity,
    negativeInfDefault: Float32 = -.infinity,
    negativeInfinityDefault: Float32 = -.infinity,
    doubleInfDefault: Double = .infinity
  ) -> Offset {
    let __start = MyGame_Example_Monster.startMonster(&fbb)
    MyGame_Example_Monster.add(pos: pos, &fbb)
    MyGame_Example_Monster.add(mana: mana, &fbb)
    MyGame_Example_Monster.add(hp: hp, &fbb)
    MyGame_Example_Monster.add(name: name, &fbb)
    MyGame_Example_Monster.addVectorOf(inventory: inventory, &fbb)
    MyGame_Example_Monster.add(color: color, &fbb)
    MyGame_Example_Monster.add(testType: testType, &fbb)
    MyGame_Example_Monster.add(test: test, &fbb)
    MyGame_Example_Monster.addVectorOf(test4: test4, &fbb)
    MyGame_Example_Monster.addVectorOf(testarrayofstring: testarrayofstring, &fbb)
    MyGame_Example_Monster.addVectorOf(testarrayoftables: testarrayoftables, &fbb)
    MyGame_Example_Monster.add(enemy: enemy, &fbb)
    MyGame_Example_Monster.addVectorOf(testnestedflatbuffer: testnestedflatbuffer, &fbb)
    MyGame_Example_Monster.add(testempty: testempty, &fbb)
    MyGame_Example_Monster.add(testbool: testbool, &fbb)
    MyGame_Example_Monster.add(testhashs32Fnv1: testhashs32Fnv1, &fbb)
    MyGame_Example_Monster.add(testhashu32Fnv1: testhashu32Fnv1, &fbb)
    MyGame_Example_Monster.add(testhashs64Fnv1: testhashs64Fnv1, &fbb)
    MyGame_Example_Monster.add(testhashu64Fnv1: testhashu64Fnv1, &fbb)
    MyGame_Example_Monster.add(testhashs32Fnv1a: testhashs32Fnv1a, &fbb)
    MyGame_Example_Monster.add(testhashu32Fnv1a: testhashu32Fnv1a, &fbb)
    MyGame_Example_Monster.add(testhashs64Fnv1a: testhashs64Fnv1a, &fbb)
    MyGame_Example_Monster.add(testhashu64Fnv1a: testhashu64Fnv1a, &fbb)
    MyGame_Example_Monster.addVectorOf(testarrayofbools: testarrayofbools, &fbb)
    MyGame_Example_Monster.add(testf: testf, &fbb)
    MyGame_Example_Monster.add(testf2: testf2, &fbb)
    MyGame_Example_Monster.add(testf3: testf3, &fbb)
    MyGame_Example_Monster.addVectorOf(testarrayofstring2: testarrayofstring2, &fbb)
    MyGame_Example_Monster.addVectorOf(testarrayofsortedstruct: testarrayofsortedstruct, &fbb)
    MyGame_Example_Monster.addVectorOf(flex: flex, &fbb)
    MyGame_Example_Monster.addVectorOf(test5: test5, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfLongs: vectorOfLongs, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfDoubles: vectorOfDoubles, &fbb)
    MyGame_Example_Monster.add(parentNamespaceTest: parentNamespaceTest, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfReferrables: vectorOfReferrables, &fbb)
    MyGame_Example_Monster.add(singleWeakReference: singleWeakReference, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfWeakReferences: vectorOfWeakReferences, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfStrongReferrables: vectorOfStrongReferrables, &fbb)
    MyGame_Example_Monster.add(coOwningReference: coOwningReference, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfCoOwningReferences: vectorOfCoOwningReferences, &fbb)
    MyGame_Example_Monster.add(nonOwningReference: nonOwningReference, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfNonOwningReferences: vectorOfNonOwningReferences, &fbb)
    MyGame_Example_Monster.add(anyUniqueType: anyUniqueType, &fbb)
    MyGame_Example_Monster.add(anyUnique: anyUnique, &fbb)
    MyGame_Example_Monster.add(anyAmbiguousType: anyAmbiguousType, &fbb)
    MyGame_Example_Monster.add(anyAmbiguous: anyAmbiguous, &fbb)
    MyGame_Example_Monster.addVectorOf(vectorOfEnums: vectorOfEnums, &fbb)
    MyGame_Example_Monster.add(signedEnum: signedEnum, &fbb)
    MyGame_Example_Monster.addVectorOf(testrequirednestedflatbuffer: testrequirednestedflatbuffer, &fbb)
    MyGame_Example_Monster.addVectorOf(scalarKeySortedTables: scalarKeySortedTables, &fbb)
    MyGame_Example_Monster.add(nativeInline: nativeInline, &fbb)
    MyGame_Example_Monster.add(longEnumNonEnumDefault: longEnumNonEnumDefault, &fbb)
    MyGame_Example_Monster.add(longEnumNormalDefault: longEnumNormalDefault, &fbb)
    MyGame_Example_Monster.add(nanDefault: nanDefault, &fbb)
    MyGame_Example_Monster.add(infDefault: infDefault, &fbb)
    MyGame_Example_Monster.add(positiveInfDefault: positiveInfDefault, &fbb)
    MyGame_Example_Monster.add(infinityDefault: infinityDefault, &fbb)
    MyGame_Example_Monster.add(positiveInfinityDefault: positiveInfinityDefault, &fbb)
    MyGame_Example_Monster.add(negativeInfDefault: negativeInfDefault, &fbb)
    MyGame_Example_Monster.add(negativeInfinityDefault: negativeInfinityDefault, &fbb)
    MyGame_Example_Monster.add(doubleInfDefault: doubleInfDefault, &fbb)
    return MyGame_Example_Monster.endMonster(&fbb, start: __start)
  }
  public static func sortVectorOfMonster(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 10, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 10, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> MyGame_Example_Monster? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 10, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return MyGame_Example_Monster(fbb, o: tableOffset)
      }
    }
    return nil
  }
  

  public mutating func unpack() -> MyGame_Example_MonsterT {
    return MyGame_Example_MonsterT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_MonsterT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_MonsterT) -> Offset {
    let __name = builder.create(string: obj.name)
    let __inventory = builder.createVector(obj.inventory)
    let __test = obj.test?.pack(builder: &builder) ?? Offset()
    MyGame_Example_Monster.startVectorOfTest4(obj.test4.count, in: &builder)
    for i in obj.test4 {
      guard let _o = i else { continue }
      builder.create(struct: _o)
    }
    let __test4 = builder.endVector(len: obj.test4.count)
    let __testarrayofstring = builder.createVector(ofStrings: obj.testarrayofstring.compactMap({ $0 }) )
    var __testarrayoftables__: [Offset] = []
    for var i in obj.testarrayoftables {
      __testarrayoftables__.append(MyGame_Example_Monster.pack(&builder, obj: &i))
    }
    let __testarrayoftables = builder.createVector(ofOffsets: __testarrayoftables__)
    let __enemy = MyGame_Example_Monster.pack(&builder, obj: &obj.enemy)
    let __testnestedflatbuffer = builder.createVector(obj.testnestedflatbuffer)
    let __testempty = MyGame_Example_Stat.pack(&builder, obj: &obj.testempty)
    let __testarrayofbools = builder.createVector(obj.testarrayofbools)
    let __testarrayofstring2 = builder.createVector(ofStrings: obj.testarrayofstring2.compactMap({ $0 }) )
    MyGame_Example_Monster.startVectorOfTestarrayofsortedstruct(obj.testarrayofsortedstruct.count, in: &builder)
    for i in obj.testarrayofsortedstruct {
      guard let _o = i else { continue }
      builder.create(struct: _o)
    }
    let __testarrayofsortedstruct = builder.endVector(len: obj.testarrayofsortedstruct.count)
    let __flex = builder.createVector(obj.flex)
    MyGame_Example_Monster.startVectorOfTest5(obj.test5.count, in: &builder)
    for i in obj.test5 {
      guard let _o = i else { continue }
      builder.create(struct: _o)
    }
    let __test5 = builder.endVector(len: obj.test5.count)
    let __vectorOfLongs = builder.createVector(obj.vectorOfLongs)
    let __vectorOfDoubles = builder.createVector(obj.vectorOfDoubles)
    let __parentNamespaceTest = MyGame_InParentNamespace.pack(&builder, obj: &obj.parentNamespaceTest)
    var __vectorOfReferrables__: [Offset] = []
    for var i in obj.vectorOfReferrables {
      __vectorOfReferrables__.append(MyGame_Example_Referrable.pack(&builder, obj: &i))
    }
    let __vectorOfReferrables = builder.createVector(ofOffsets: __vectorOfReferrables__)
    let __vectorOfWeakReferences = builder.createVector(obj.vectorOfWeakReferences)
    var __vectorOfStrongReferrables__: [Offset] = []
    for var i in obj.vectorOfStrongReferrables {
      __vectorOfStrongReferrables__.append(MyGame_Example_Referrable.pack(&builder, obj: &i))
    }
    let __vectorOfStrongReferrables = builder.createVector(ofOffsets: __vectorOfStrongReferrables__)
    let __vectorOfCoOwningReferences = builder.createVector(obj.vectorOfCoOwningReferences)
    let __vectorOfNonOwningReferences = builder.createVector(obj.vectorOfNonOwningReferences)
    let __anyUnique = obj.anyUnique?.pack(builder: &builder) ?? Offset()
    let __anyAmbiguous = obj.anyAmbiguous?.pack(builder: &builder) ?? Offset()
    let __vectorOfEnums = builder.createVector(obj.vectorOfEnums)
    let __testrequirednestedflatbuffer = builder.createVector(obj.testrequirednestedflatbuffer)
    var __scalarKeySortedTables__: [Offset] = []
    for var i in obj.scalarKeySortedTables {
      __scalarKeySortedTables__.append(MyGame_Example_Stat.pack(&builder, obj: &i))
    }
    let __scalarKeySortedTables = builder.createVector(ofOffsets: __scalarKeySortedTables__)
    let __root = MyGame_Example_Monster.startMonster(&builder)
    MyGame_Example_Monster.add(pos: obj.pos, &builder)
    MyGame_Example_Monster.add(mana: obj.mana, &builder)
    MyGame_Example_Monster.add(hp: obj.hp, &builder)
    MyGame_Example_Monster.add(name: __name, &builder)
    MyGame_Example_Monster.addVectorOf(inventory: __inventory, &builder)
    MyGame_Example_Monster.add(color: obj.color, &builder)
    if let o = obj.test?.type {
      MyGame_Example_Monster.add(testType: o, &builder)
      MyGame_Example_Monster.add(test: __test, &builder)
    }

    MyGame_Example_Monster.addVectorOf(test4: __test4, &builder)
    MyGame_Example_Monster.addVectorOf(testarrayofstring: __testarrayofstring, &builder)
    MyGame_Example_Monster.addVectorOf(testarrayoftables: __testarrayoftables, &builder)
    MyGame_Example_Monster.add(enemy: __enemy, &builder)
    MyGame_Example_Monster.addVectorOf(testnestedflatbuffer: __testnestedflatbuffer, &builder)
    MyGame_Example_Monster.add(testempty: __testempty, &builder)
    MyGame_Example_Monster.add(testbool: obj.testbool, &builder)
    MyGame_Example_Monster.add(testhashs32Fnv1: obj.testhashs32Fnv1, &builder)
    MyGame_Example_Monster.add(testhashu32Fnv1: obj.testhashu32Fnv1, &builder)
    MyGame_Example_Monster.add(testhashs64Fnv1: obj.testhashs64Fnv1, &builder)
    MyGame_Example_Monster.add(testhashu64Fnv1: obj.testhashu64Fnv1, &builder)
    MyGame_Example_Monster.add(testhashs32Fnv1a: obj.testhashs32Fnv1a, &builder)
    MyGame_Example_Monster.add(testhashu32Fnv1a: obj.testhashu32Fnv1a, &builder)
    MyGame_Example_Monster.add(testhashs64Fnv1a: obj.testhashs64Fnv1a, &builder)
    MyGame_Example_Monster.add(testhashu64Fnv1a: obj.testhashu64Fnv1a, &builder)
    MyGame_Example_Monster.addVectorOf(testarrayofbools: __testarrayofbools, &builder)
    MyGame_Example_Monster.add(testf: obj.testf, &builder)
    MyGame_Example_Monster.add(testf2: obj.testf2, &builder)
    MyGame_Example_Monster.add(testf3: obj.testf3, &builder)
    MyGame_Example_Monster.addVectorOf(testarrayofstring2: __testarrayofstring2, &builder)
    MyGame_Example_Monster.addVectorOf(testarrayofsortedstruct: __testarrayofsortedstruct, &builder)
    MyGame_Example_Monster.addVectorOf(flex: __flex, &builder)
    MyGame_Example_Monster.addVectorOf(test5: __test5, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfLongs: __vectorOfLongs, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfDoubles: __vectorOfDoubles, &builder)
    MyGame_Example_Monster.add(parentNamespaceTest: __parentNamespaceTest, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfReferrables: __vectorOfReferrables, &builder)
    MyGame_Example_Monster.add(singleWeakReference: obj.singleWeakReference, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfWeakReferences: __vectorOfWeakReferences, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfStrongReferrables: __vectorOfStrongReferrables, &builder)
    MyGame_Example_Monster.add(coOwningReference: obj.coOwningReference, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfCoOwningReferences: __vectorOfCoOwningReferences, &builder)
    MyGame_Example_Monster.add(nonOwningReference: obj.nonOwningReference, &builder)
    MyGame_Example_Monster.addVectorOf(vectorOfNonOwningReferences: __vectorOfNonOwningReferences, &builder)
    if let o = obj.anyUnique?.type {
      MyGame_Example_Monster.add(anyUniqueType: o, &builder)
      MyGame_Example_Monster.add(anyUnique: __anyUnique, &builder)
    }

    if let o = obj.anyAmbiguous?.type {
      MyGame_Example_Monster.add(anyAmbiguousType: o, &builder)
      MyGame_Example_Monster.add(anyAmbiguous: __anyAmbiguous, &builder)
    }

    MyGame_Example_Monster.addVectorOf(vectorOfEnums: __vectorOfEnums, &builder)
    MyGame_Example_Monster.add(signedEnum: obj.signedEnum, &builder)
    MyGame_Example_Monster.addVectorOf(testrequirednestedflatbuffer: __testrequirednestedflatbuffer, &builder)
    MyGame_Example_Monster.addVectorOf(scalarKeySortedTables: __scalarKeySortedTables, &builder)
    MyGame_Example_Monster.add(nativeInline: obj.nativeInline, &builder)
    MyGame_Example_Monster.add(longEnumNonEnumDefault: obj.longEnumNonEnumDefault, &builder)
    MyGame_Example_Monster.add(longEnumNormalDefault: obj.longEnumNormalDefault, &builder)
    MyGame_Example_Monster.add(nanDefault: obj.nanDefault, &builder)
    MyGame_Example_Monster.add(infDefault: obj.infDefault, &builder)
    MyGame_Example_Monster.add(positiveInfDefault: obj.positiveInfDefault, &builder)
    MyGame_Example_Monster.add(infinityDefault: obj.infinityDefault, &builder)
    MyGame_Example_Monster.add(positiveInfinityDefault: obj.positiveInfinityDefault, &builder)
    MyGame_Example_Monster.add(negativeInfDefault: obj.negativeInfDefault, &builder)
    MyGame_Example_Monster.add(negativeInfinityDefault: obj.negativeInfinityDefault, &builder)
    MyGame_Example_Monster.add(doubleInfDefault: obj.doubleInfDefault, &builder)
    return MyGame_Example_Monster.endMonster(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pos.p, fieldName: "pos", required: false, type: MyGame_Example_Vec3.self)
    try _v.visit(field: VTOFFSET.mana.p, fieldName: "mana", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.hp.p, fieldName: "hp", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.inventory.p, fieldName: "inventory", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: false, type: MyGame_Example_Color.self)
    try _v.visit(unionKey: VTOFFSET.testType.p, unionField: VTOFFSET.test.p, unionKeyName: "testType", fieldName: "test", required: false, completion: { (verifier, key: MyGame_Example_Any_, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .monster:
        try ForwardOffset<MyGame_Example_Monster>.verify(&verifier, at: pos, of: MyGame_Example_Monster.self)
      case .testsimpletablewithenum:
        try ForwardOffset<MyGame_Example_TestSimpleTableWithEnum>.verify(&verifier, at: pos, of: MyGame_Example_TestSimpleTableWithEnum.self)
      case .mygameExample2Monster:
        try ForwardOffset<MyGame_Example2_Monster>.verify(&verifier, at: pos, of: MyGame_Example2_Monster.self)
      }
    })
    try _v.visit(field: VTOFFSET.test4.p, fieldName: "test4", required: false, type: ForwardOffset<Vector<MyGame_Example_Test, MyGame_Example_Test>>.self)
    try _v.visit(field: VTOFFSET.testarrayofstring.p, fieldName: "testarrayofstring", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.testarrayoftables.p, fieldName: "testarrayoftables", required: false, type: ForwardOffset<Vector<ForwardOffset<MyGame_Example_Monster>, MyGame_Example_Monster>>.self)
    try _v.visit(field: VTOFFSET.enemy.p, fieldName: "enemy", required: false, type: ForwardOffset<MyGame_Example_Monster>.self)
    try _v.visit(field: VTOFFSET.testnestedflatbuffer.p, fieldName: "testnestedflatbuffer", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.testempty.p, fieldName: "testempty", required: false, type: ForwardOffset<MyGame_Example_Stat>.self)
    try _v.visit(field: VTOFFSET.testbool.p, fieldName: "testbool", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.testhashs32Fnv1.p, fieldName: "testhashs32Fnv1", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.testhashu32Fnv1.p, fieldName: "testhashu32Fnv1", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.testhashs64Fnv1.p, fieldName: "testhashs64Fnv1", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.testhashu64Fnv1.p, fieldName: "testhashu64Fnv1", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.testhashs32Fnv1a.p, fieldName: "testhashs32Fnv1a", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.testhashu32Fnv1a.p, fieldName: "testhashu32Fnv1a", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.testhashs64Fnv1a.p, fieldName: "testhashs64Fnv1a", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.testhashu64Fnv1a.p, fieldName: "testhashu64Fnv1a", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.testarrayofbools.p, fieldName: "testarrayofbools", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.testf.p, fieldName: "testf", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.testf2.p, fieldName: "testf2", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.testf3.p, fieldName: "testf3", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.testarrayofstring2.p, fieldName: "testarrayofstring2", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.testarrayofsortedstruct.p, fieldName: "testarrayofsortedstruct", required: false, type: ForwardOffset<Vector<MyGame_Example_Ability, MyGame_Example_Ability>>.self)
    try _v.visit(field: VTOFFSET.flex.p, fieldName: "flex", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.test5.p, fieldName: "test5", required: false, type: ForwardOffset<Vector<MyGame_Example_Test, MyGame_Example_Test>>.self)
    try _v.visit(field: VTOFFSET.vectorOfLongs.p, fieldName: "vectorOfLongs", required: false, type: ForwardOffset<Vector<Int64, Int64>>.self)
    try _v.visit(field: VTOFFSET.vectorOfDoubles.p, fieldName: "vectorOfDoubles", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.parentNamespaceTest.p, fieldName: "parentNamespaceTest", required: false, type: ForwardOffset<MyGame_InParentNamespace>.self)
    try _v.visit(field: VTOFFSET.vectorOfReferrables.p, fieldName: "vectorOfReferrables", required: false, type: ForwardOffset<Vector<ForwardOffset<MyGame_Example_Referrable>, MyGame_Example_Referrable>>.self)
    try _v.visit(field: VTOFFSET.singleWeakReference.p, fieldName: "singleWeakReference", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.vectorOfWeakReferences.p, fieldName: "vectorOfWeakReferences", required: false, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    try _v.visit(field: VTOFFSET.vectorOfStrongReferrables.p, fieldName: "vectorOfStrongReferrables", required: false, type: ForwardOffset<Vector<ForwardOffset<MyGame_Example_Referrable>, MyGame_Example_Referrable>>.self)
    try _v.visit(field: VTOFFSET.coOwningReference.p, fieldName: "coOwningReference", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.vectorOfCoOwningReferences.p, fieldName: "vectorOfCoOwningReferences", required: false, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    try _v.visit(field: VTOFFSET.nonOwningReference.p, fieldName: "nonOwningReference", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.vectorOfNonOwningReferences.p, fieldName: "vectorOfNonOwningReferences", required: false, type: ForwardOffset<Vector<UInt64, UInt64>>.self)
    try _v.visit(unionKey: VTOFFSET.anyUniqueType.p, unionField: VTOFFSET.anyUnique.p, unionKeyName: "anyUniqueType", fieldName: "anyUnique", required: false, completion: { (verifier, key: MyGame_Example_AnyUniqueAliases, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .m:
        try ForwardOffset<MyGame_Example_Monster>.verify(&verifier, at: pos, of: MyGame_Example_Monster.self)
      case .ts:
        try ForwardOffset<MyGame_Example_TestSimpleTableWithEnum>.verify(&verifier, at: pos, of: MyGame_Example_TestSimpleTableWithEnum.self)
      case .m2:
        try ForwardOffset<MyGame_Example2_Monster>.verify(&verifier, at: pos, of: MyGame_Example2_Monster.self)
      }
    })
    try _v.visit(unionKey: VTOFFSET.anyAmbiguousType.p, unionField: VTOFFSET.anyAmbiguous.p, unionKeyName: "anyAmbiguousType", fieldName: "anyAmbiguous", required: false, completion: { (verifier, key: MyGame_Example_AnyAmbiguousAliases, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .m1:
        try ForwardOffset<MyGame_Example_Monster>.verify(&verifier, at: pos, of: MyGame_Example_Monster.self)
      case .m2:
        try ForwardOffset<MyGame_Example_Monster>.verify(&verifier, at: pos, of: MyGame_Example_Monster.self)
      case .m3:
        try ForwardOffset<MyGame_Example_Monster>.verify(&verifier, at: pos, of: MyGame_Example_Monster.self)
      }
    })
    try _v.visit(field: VTOFFSET.vectorOfEnums.p, fieldName: "vectorOfEnums", required: false, type: ForwardOffset<Vector<MyGame_Example_Color, MyGame_Example_Color>>.self)
    try _v.visit(field: VTOFFSET.signedEnum.p, fieldName: "signedEnum", required: false, type: MyGame_Example_Race.self)
    try _v.visit(field: VTOFFSET.testrequirednestedflatbuffer.p, fieldName: "testrequirednestedflatbuffer", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.scalarKeySortedTables.p, fieldName: "scalarKeySortedTables", required: false, type: ForwardOffset<Vector<ForwardOffset<MyGame_Example_Stat>, MyGame_Example_Stat>>.self)
    try _v.visit(field: VTOFFSET.nativeInline.p, fieldName: "nativeInline", required: false, type: MyGame_Example_Test.self)
    try _v.visit(field: VTOFFSET.longEnumNonEnumDefault.p, fieldName: "longEnumNonEnumDefault", required: false, type: MyGame_Example_LongEnum.self)
    try _v.visit(field: VTOFFSET.longEnumNormalDefault.p, fieldName: "longEnumNormalDefault", required: false, type: MyGame_Example_LongEnum.self)
    try _v.visit(field: VTOFFSET.nanDefault.p, fieldName: "nanDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.infDefault.p, fieldName: "infDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.positiveInfDefault.p, fieldName: "positiveInfDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.infinityDefault.p, fieldName: "infinityDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.positiveInfinityDefault.p, fieldName: "positiveInfinityDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.negativeInfDefault.p, fieldName: "negativeInfDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.negativeInfinityDefault.p, fieldName: "negativeInfinityDefault", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.doubleInfDefault.p, fieldName: "doubleInfDefault", required: false, type: Double.self)
    _v.finish()
  }
}

extension MyGame_Example_Monster: Encodable {

  enum CodingKeys: String, CodingKey {
    case pos = "pos"
    case mana = "mana"
    case hp = "hp"
    case name = "name"
    case inventory = "inventory"
    case color = "color"
    case testType = "test_type"
    case test = "test"
    case test4 = "test4"
    case testarrayofstring = "testarrayofstring"
    case testarrayoftables = "testarrayoftables"
    case enemy = "enemy"
    case testnestedflatbuffer = "testnestedflatbuffer"
    case testempty = "testempty"
    case testbool = "testbool"
    case testhashs32Fnv1 = "testhashs32_fnv1"
    case testhashu32Fnv1 = "testhashu32_fnv1"
    case testhashs64Fnv1 = "testhashs64_fnv1"
    case testhashu64Fnv1 = "testhashu64_fnv1"
    case testhashs32Fnv1a = "testhashs32_fnv1a"
    case testhashu32Fnv1a = "testhashu32_fnv1a"
    case testhashs64Fnv1a = "testhashs64_fnv1a"
    case testhashu64Fnv1a = "testhashu64_fnv1a"
    case testarrayofbools = "testarrayofbools"
    case testf = "testf"
    case testf2 = "testf2"
    case testf3 = "testf3"
    case testarrayofstring2 = "testarrayofstring2"
    case testarrayofsortedstruct = "testarrayofsortedstruct"
    case flex = "flex"
    case test5 = "test5"
    case vectorOfLongs = "vector_of_longs"
    case vectorOfDoubles = "vector_of_doubles"
    case parentNamespaceTest = "parent_namespace_test"
    case vectorOfReferrables = "vector_of_referrables"
    case singleWeakReference = "single_weak_reference"
    case vectorOfWeakReferences = "vector_of_weak_references"
    case vectorOfStrongReferrables = "vector_of_strong_referrables"
    case coOwningReference = "co_owning_reference"
    case vectorOfCoOwningReferences = "vector_of_co_owning_references"
    case nonOwningReference = "non_owning_reference"
    case vectorOfNonOwningReferences = "vector_of_non_owning_references"
    case anyUniqueType = "any_unique_type"
    case anyUnique = "any_unique"
    case anyAmbiguousType = "any_ambiguous_type"
    case anyAmbiguous = "any_ambiguous"
    case vectorOfEnums = "vector_of_enums"
    case signedEnum = "signed_enum"
    case testrequirednestedflatbuffer = "testrequirednestedflatbuffer"
    case scalarKeySortedTables = "scalar_key_sorted_tables"
    case nativeInline = "native_inline"
    case longEnumNonEnumDefault = "long_enum_non_enum_default"
    case longEnumNormalDefault = "long_enum_normal_default"
    case nanDefault = "nan_default"
    case infDefault = "inf_default"
    case positiveInfDefault = "positive_inf_default"
    case infinityDefault = "infinity_default"
    case positiveInfinityDefault = "positive_infinity_default"
    case negativeInfDefault = "negative_inf_default"
    case negativeInfinityDefault = "negative_infinity_default"
    case doubleInfDefault = "double_inf_default"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encodeIfPresent(pos, forKey: .pos)
    if mana != 150 {
      try container.encodeIfPresent(mana, forKey: .mana)
    }
    if hp != 100 {
      try container.encodeIfPresent(hp, forKey: .hp)
    }
    try container.encodeIfPresent(name, forKey: .name)
    if inventoryCount > 0 {
      try container.encodeIfPresent(inventory, forKey: .inventory)
    }
    if color != .blue {
      try container.encodeIfPresent(color, forKey: .color)
    }
    if testType != .none_ {
      try container.encodeIfPresent(testType, forKey: .testType)
    }
    switch testType {
    case .monster:
      let _v = test(type: MyGame_Example_Monster.self)
      try container.encodeIfPresent(_v, forKey: .test)
    case .testsimpletablewithenum:
      let _v = test(type: MyGame_Example_TestSimpleTableWithEnum.self)
      try container.encodeIfPresent(_v, forKey: .test)
    case .mygameExample2Monster:
      let _v = test(type: MyGame_Example2_Monster.self)
      try container.encodeIfPresent(_v, forKey: .test)
    default: break;
    }
    if test4Count > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .test4)
      for index in 0..<test4Count {
        guard let type = test4(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if testarrayofstringCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .testarrayofstring)
      for index in 0..<testarrayofstringCount {
        guard let type = testarrayofstring(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if testarrayoftablesCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .testarrayoftables)
      for index in 0..<testarrayoftablesCount {
        guard let type = testarrayoftables(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    try container.encodeIfPresent(enemy, forKey: .enemy)
    if testnestedflatbufferCount > 0 {
      try container.encodeIfPresent(testnestedflatbuffer, forKey: .testnestedflatbuffer)
    }
    try container.encodeIfPresent(testempty, forKey: .testempty)
    if testbool != false {
      try container.encodeIfPresent(testbool, forKey: .testbool)
    }
    if testhashs32Fnv1 != 0 {
      try container.encodeIfPresent(testhashs32Fnv1, forKey: .testhashs32Fnv1)
    }
    if testhashu32Fnv1 != 0 {
      try container.encodeIfPresent(testhashu32Fnv1, forKey: .testhashu32Fnv1)
    }
    if testhashs64Fnv1 != 0 {
      try container.encodeIfPresent(testhashs64Fnv1, forKey: .testhashs64Fnv1)
    }
    if testhashu64Fnv1 != 0 {
      try container.encodeIfPresent(testhashu64Fnv1, forKey: .testhashu64Fnv1)
    }
    if testhashs32Fnv1a != 0 {
      try container.encodeIfPresent(testhashs32Fnv1a, forKey: .testhashs32Fnv1a)
    }
    if testhashu32Fnv1a != 0 {
      try container.encodeIfPresent(testhashu32Fnv1a, forKey: .testhashu32Fnv1a)
    }
    if testhashs64Fnv1a != 0 {
      try container.encodeIfPresent(testhashs64Fnv1a, forKey: .testhashs64Fnv1a)
    }
    if testhashu64Fnv1a != 0 {
      try container.encodeIfPresent(testhashu64Fnv1a, forKey: .testhashu64Fnv1a)
    }
    if testarrayofboolsCount > 0 {
      try container.encodeIfPresent(testarrayofbools, forKey: .testarrayofbools)
    }
    if testf != 3.14159 {
      try container.encodeIfPresent(testf, forKey: .testf)
    }
    if testf2 != 3.0 {
      try container.encodeIfPresent(testf2, forKey: .testf2)
    }
    if testf3 != 0.0 {
      try container.encodeIfPresent(testf3, forKey: .testf3)
    }
    if testarrayofstring2Count > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .testarrayofstring2)
      for index in 0..<testarrayofstring2Count {
        guard let type = testarrayofstring2(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if testarrayofsortedstructCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .testarrayofsortedstruct)
      for index in 0..<testarrayofsortedstructCount {
        guard let type = testarrayofsortedstruct(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if flexCount > 0 {
      try container.encodeIfPresent(flex, forKey: .flex)
    }
    if test5Count > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .test5)
      for index in 0..<test5Count {
        guard let type = test5(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if vectorOfLongsCount > 0 {
      try container.encodeIfPresent(vectorOfLongs, forKey: .vectorOfLongs)
    }
    if vectorOfDoublesCount > 0 {
      try container.encodeIfPresent(vectorOfDoubles, forKey: .vectorOfDoubles)
    }
    try container.encodeIfPresent(parentNamespaceTest, forKey: .parentNamespaceTest)
    if vectorOfReferrablesCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .vectorOfReferrables)
      for index in 0..<vectorOfReferrablesCount {
        guard let type = vectorOfReferrables(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if singleWeakReference != 0 {
      try container.encodeIfPresent(singleWeakReference, forKey: .singleWeakReference)
    }
    if vectorOfWeakReferencesCount > 0 {
      try container.encodeIfPresent(vectorOfWeakReferences, forKey: .vectorOfWeakReferences)
    }
    if vectorOfStrongReferrablesCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .vectorOfStrongReferrables)
      for index in 0..<vectorOfStrongReferrablesCount {
        guard let type = vectorOfStrongReferrables(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if coOwningReference != 0 {
      try container.encodeIfPresent(coOwningReference, forKey: .coOwningReference)
    }
    if vectorOfCoOwningReferencesCount > 0 {
      try container.encodeIfPresent(vectorOfCoOwningReferences, forKey: .vectorOfCoOwningReferences)
    }
    if nonOwningReference != 0 {
      try container.encodeIfPresent(nonOwningReference, forKey: .nonOwningReference)
    }
    if vectorOfNonOwningReferencesCount > 0 {
      try container.encodeIfPresent(vectorOfNonOwningReferences, forKey: .vectorOfNonOwningReferences)
    }
    if anyUniqueType != .none_ {
      try container.encodeIfPresent(anyUniqueType, forKey: .anyUniqueType)
    }
    switch anyUniqueType {
    case .m:
      let _v = anyUnique(type: MyGame_Example_Monster.self)
      try container.encodeIfPresent(_v, forKey: .anyUnique)
    case .ts:
      let _v = anyUnique(type: MyGame_Example_TestSimpleTableWithEnum.self)
      try container.encodeIfPresent(_v, forKey: .anyUnique)
    case .m2:
      let _v = anyUnique(type: MyGame_Example2_Monster.self)
      try container.encodeIfPresent(_v, forKey: .anyUnique)
    default: break;
    }
    if anyAmbiguousType != .none_ {
      try container.encodeIfPresent(anyAmbiguousType, forKey: .anyAmbiguousType)
    }
    switch anyAmbiguousType {
    case .m1:
      let _v = anyAmbiguous(type: MyGame_Example_Monster.self)
      try container.encodeIfPresent(_v, forKey: .anyAmbiguous)
    case .m2:
      let _v = anyAmbiguous(type: MyGame_Example_Monster.self)
      try container.encodeIfPresent(_v, forKey: .anyAmbiguous)
    case .m3:
      let _v = anyAmbiguous(type: MyGame_Example_Monster.self)
      try container.encodeIfPresent(_v, forKey: .anyAmbiguous)
    default: break;
    }
    if vectorOfEnumsCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .vectorOfEnums)
      for index in 0..<vectorOfEnumsCount {
        guard let type = vectorOfEnums(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    if signedEnum != .none_ {
      try container.encodeIfPresent(signedEnum, forKey: .signedEnum)
    }
    if testrequirednestedflatbufferCount > 0 {
      try container.encodeIfPresent(testrequirednestedflatbuffer, forKey: .testrequirednestedflatbuffer)
    }
    if scalarKeySortedTablesCount > 0 {
      var contentEncoder = container.nestedUnkeyedContainer(forKey: .scalarKeySortedTables)
      for index in 0..<scalarKeySortedTablesCount {
        guard let type = scalarKeySortedTables(at: index) else { continue }
        try contentEncoder.encode(type)
      }
    }
    try container.encodeIfPresent(nativeInline, forKey: .nativeInline)
    if longEnumNonEnumDefault != .longone {
      try container.encodeIfPresent(longEnumNonEnumDefault, forKey: .longEnumNonEnumDefault)
    }
    if longEnumNormalDefault != .longone {
      try container.encodeIfPresent(longEnumNormalDefault, forKey: .longEnumNormalDefault)
    }
    if !nanDefault.isNaN {
      try container.encodeIfPresent(nanDefault, forKey: .nanDefault)
    }
    if infDefault != .infinity {
      try container.encodeIfPresent(infDefault, forKey: .infDefault)
    }
    if positiveInfDefault != .infinity {
      try container.encodeIfPresent(positiveInfDefault, forKey: .positiveInfDefault)
    }
    if infinityDefault != .infinity {
      try container.encodeIfPresent(infinityDefault, forKey: .infinityDefault)
    }
    if positiveInfinityDefault != .infinity {
      try container.encodeIfPresent(positiveInfinityDefault, forKey: .positiveInfinityDefault)
    }
    if negativeInfDefault != -.infinity {
      try container.encodeIfPresent(negativeInfDefault, forKey: .negativeInfDefault)
    }
    if negativeInfinityDefault != -.infinity {
      try container.encodeIfPresent(negativeInfinityDefault, forKey: .negativeInfinityDefault)
    }
    if doubleInfDefault != .infinity {
      try container.encodeIfPresent(doubleInfDefault, forKey: .doubleInfDefault)
    }
  }
}

public class MyGame_Example_MonsterT: NativeObject {

  public var pos: MyGame_Example_Vec3?
  public var mana: Int16
  public var hp: Int16
  public var name: String
  public var inventory: [UInt8]
  public var color: MyGame_Example_Color
  public var test: MyGame_Example_Any_Union?
  public var test4: [MyGame_Example_Test?]
  public var testarrayofstring: [String?]
  public var testarrayoftables: [MyGame_Example_MonsterT?]
  public var enemy: MyGame_Example_MonsterT?
  public var testnestedflatbuffer: [UInt8]
  public var testempty: MyGame_Example_StatT?
  public var testbool: Bool
  public var testhashs32Fnv1: Int32
  public var testhashu32Fnv1: UInt32
  public var testhashs64Fnv1: Int64
  public var testhashu64Fnv1: UInt64
  public var testhashs32Fnv1a: Int32
  public var testhashu32Fnv1a: UInt32
  public var testhashs64Fnv1a: Int64
  public var testhashu64Fnv1a: UInt64
  public var testarrayofbools: [Bool]
  public var testf: Float32
  public var testf2: Float32
  public var testf3: Float32
  public var testarrayofstring2: [String?]
  public var testarrayofsortedstruct: [MyGame_Example_Ability?]
  public var flex: [UInt8]
  public var test5: [MyGame_Example_Test?]
  public var vectorOfLongs: [Int64]
  public var vectorOfDoubles: [Double]
  public var parentNamespaceTest: MyGame_InParentNamespaceT?
  public var vectorOfReferrables: [MyGame_Example_ReferrableT?]
  public var singleWeakReference: UInt64
  public var vectorOfWeakReferences: [UInt64]
  public var vectorOfStrongReferrables: [MyGame_Example_ReferrableT?]
  public var coOwningReference: UInt64
  public var vectorOfCoOwningReferences: [UInt64]
  public var nonOwningReference: UInt64
  public var vectorOfNonOwningReferences: [UInt64]
  public var anyUnique: MyGame_Example_AnyUniqueAliasesUnion?
  public var anyAmbiguous: MyGame_Example_AnyAmbiguousAliasesUnion?
  public var vectorOfEnums: [MyGame_Example_Color]
  public var signedEnum: MyGame_Example_Race
  public var testrequirednestedflatbuffer: [UInt8]
  public var scalarKeySortedTables: [MyGame_Example_StatT?]
  public var nativeInline: MyGame_Example_Test?
  public var longEnumNonEnumDefault: MyGame_Example_LongEnum
  public var longEnumNormalDefault: MyGame_Example_LongEnum
  public var nanDefault: Float32
  public var infDefault: Float32
  public var positiveInfDefault: Float32
  public var infinityDefault: Float32
  public var positiveInfinityDefault: Float32
  public var negativeInfDefault: Float32
  public var negativeInfinityDefault: Float32
  public var doubleInfDefault: Double

  public init(_ _t: inout MyGame_Example_Monster) {
    pos = _t.pos
    mana = _t.mana
    hp = _t.hp
    name = _t.name
    inventory = []
    for index in 0..<_t.inventoryCount {
        inventory.append(_t.inventory(at: index))
    }
    color = _t.color
    switch _t.testType {
    case .monster:
      var _v = _t.test(type: MyGame_Example_Monster.self)
      test = MyGame_Example_Any_Union(_v?.unpack(), type: .monster)
    case .testsimpletablewithenum:
      var _v = _t.test(type: MyGame_Example_TestSimpleTableWithEnum.self)
      test = MyGame_Example_Any_Union(_v?.unpack(), type: .testsimpletablewithenum)
    case .mygameExample2Monster:
      var _v = _t.test(type: MyGame_Example2_Monster.self)
      test = MyGame_Example_Any_Union(_v?.unpack(), type: .mygameExample2Monster)
    default: break
    }
    test4 = []
    for index in 0..<_t.test4Count {
        test4.append(_t.test4(at: index))
    }
    testarrayofstring = []
    for index in 0..<_t.testarrayofstringCount {
        testarrayofstring.append(_t.testarrayofstring(at: index))
    }
    testarrayoftables = []
    for index in 0..<_t.testarrayoftablesCount {
        var __v_ = _t.testarrayoftables(at: index)
        testarrayoftables.append(__v_?.unpack())
    }
    var __enemy = _t.enemy
    enemy = __enemy?.unpack()
    testnestedflatbuffer = []
    for index in 0..<_t.testnestedflatbufferCount {
        testnestedflatbuffer.append(_t.testnestedflatbuffer(at: index))
    }
    var __testempty = _t.testempty
    testempty = __testempty?.unpack()
    testbool = _t.testbool
    testhashs32Fnv1 = _t.testhashs32Fnv1
    testhashu32Fnv1 = _t.testhashu32Fnv1
    testhashs64Fnv1 = _t.testhashs64Fnv1
    testhashu64Fnv1 = _t.testhashu64Fnv1
    testhashs32Fnv1a = _t.testhashs32Fnv1a
    testhashu32Fnv1a = _t.testhashu32Fnv1a
    testhashs64Fnv1a = _t.testhashs64Fnv1a
    testhashu64Fnv1a = _t.testhashu64Fnv1a
    testarrayofbools = []
    for index in 0..<_t.testarrayofboolsCount {
        testarrayofbools.append(_t.testarrayofbools(at: index))
    }
    testf = _t.testf
    testf2 = _t.testf2
    testf3 = _t.testf3
    testarrayofstring2 = []
    for index in 0..<_t.testarrayofstring2Count {
        testarrayofstring2.append(_t.testarrayofstring2(at: index))
    }
    testarrayofsortedstruct = []
    for index in 0..<_t.testarrayofsortedstructCount {
        testarrayofsortedstruct.append(_t.testarrayofsortedstruct(at: index))
    }
    flex = []
    for index in 0..<_t.flexCount {
        flex.append(_t.flex(at: index))
    }
    test5 = []
    for index in 0..<_t.test5Count {
        test5.append(_t.test5(at: index))
    }
    vectorOfLongs = []
    for index in 0..<_t.vectorOfLongsCount {
        vectorOfLongs.append(_t.vectorOfLongs(at: index))
    }
    vectorOfDoubles = []
    for index in 0..<_t.vectorOfDoublesCount {
        vectorOfDoubles.append(_t.vectorOfDoubles(at: index))
    }
    var __parentNamespaceTest = _t.parentNamespaceTest
    parentNamespaceTest = __parentNamespaceTest?.unpack()
    vectorOfReferrables = []
    for index in 0..<_t.vectorOfReferrablesCount {
        var __v_ = _t.vectorOfReferrables(at: index)
        vectorOfReferrables.append(__v_?.unpack())
    }
    singleWeakReference = _t.singleWeakReference
    vectorOfWeakReferences = []
    for index in 0..<_t.vectorOfWeakReferencesCount {
        vectorOfWeakReferences.append(_t.vectorOfWeakReferences(at: index))
    }
    vectorOfStrongReferrables = []
    for index in 0..<_t.vectorOfStrongReferrablesCount {
        var __v_ = _t.vectorOfStrongReferrables(at: index)
        vectorOfStrongReferrables.append(__v_?.unpack())
    }
    coOwningReference = _t.coOwningReference
    vectorOfCoOwningReferences = []
    for index in 0..<_t.vectorOfCoOwningReferencesCount {
        vectorOfCoOwningReferences.append(_t.vectorOfCoOwningReferences(at: index))
    }
    nonOwningReference = _t.nonOwningReference
    vectorOfNonOwningReferences = []
    for index in 0..<_t.vectorOfNonOwningReferencesCount {
        vectorOfNonOwningReferences.append(_t.vectorOfNonOwningReferences(at: index))
    }
    switch _t.anyUniqueType {
    case .m:
      var _v = _t.anyUnique(type: MyGame_Example_Monster.self)
      anyUnique = MyGame_Example_AnyUniqueAliasesUnion(_v?.unpack(), type: .m)
    case .ts:
      var _v = _t.anyUnique(type: MyGame_Example_TestSimpleTableWithEnum.self)
      anyUnique = MyGame_Example_AnyUniqueAliasesUnion(_v?.unpack(), type: .ts)
    case .m2:
      var _v = _t.anyUnique(type: MyGame_Example2_Monster.self)
      anyUnique = MyGame_Example_AnyUniqueAliasesUnion(_v?.unpack(), type: .m2)
    default: break
    }
    switch _t.anyAmbiguousType {
    case .m1:
      var _v = _t.anyAmbiguous(type: MyGame_Example_Monster.self)
      anyAmbiguous = MyGame_Example_AnyAmbiguousAliasesUnion(_v?.unpack(), type: .m1)
    case .m2:
      var _v = _t.anyAmbiguous(type: MyGame_Example_Monster.self)
      anyAmbiguous = MyGame_Example_AnyAmbiguousAliasesUnion(_v?.unpack(), type: .m2)
    case .m3:
      var _v = _t.anyAmbiguous(type: MyGame_Example_Monster.self)
      anyAmbiguous = MyGame_Example_AnyAmbiguousAliasesUnion(_v?.unpack(), type: .m3)
    default: break
    }
    vectorOfEnums = []
    for index in 0..<_t.vectorOfEnumsCount {
        vectorOfEnums.append(_t.vectorOfEnums(at: index)!)
    }
    signedEnum = _t.signedEnum
    testrequirednestedflatbuffer = []
    for index in 0..<_t.testrequirednestedflatbufferCount {
        testrequirednestedflatbuffer.append(_t.testrequirednestedflatbuffer(at: index))
    }
    scalarKeySortedTables = []
    for index in 0..<_t.scalarKeySortedTablesCount {
        var __v_ = _t.scalarKeySortedTables(at: index)
        scalarKeySortedTables.append(__v_?.unpack())
    }
    nativeInline = _t.nativeInline
    longEnumNonEnumDefault = _t.longEnumNonEnumDefault
    longEnumNormalDefault = _t.longEnumNormalDefault
    nanDefault = _t.nanDefault
    infDefault = _t.infDefault
    positiveInfDefault = _t.positiveInfDefault
    infinityDefault = _t.infinityDefault
    positiveInfinityDefault = _t.positiveInfinityDefault
    negativeInfDefault = _t.negativeInfDefault
    negativeInfinityDefault = _t.negativeInfinityDefault
    doubleInfDefault = _t.doubleInfDefault
  }

  public init() {
    pos = MyGame_Example_Vec3()
    mana = 150
    hp = 100
    name = ""
    inventory = []
    color = .blue
    test4 = []
    testarrayofstring = []
    testarrayoftables = []
    enemy = MyGame_Example_MonsterT()
    testnestedflatbuffer = []
    testempty = MyGame_Example_StatT()
    testbool = false
    testhashs32Fnv1 = 0
    testhashu32Fnv1 = 0
    testhashs64Fnv1 = 0
    testhashu64Fnv1 = 0
    testhashs32Fnv1a = 0
    testhashu32Fnv1a = 0
    testhashs64Fnv1a = 0
    testhashu64Fnv1a = 0
    testarrayofbools = []
    testf = 3.14159
    testf2 = 3.0
    testf3 = 0.0
    testarrayofstring2 = []
    testarrayofsortedstruct = []
    flex = []
    test5 = []
    vectorOfLongs = []
    vectorOfDoubles = []
    parentNamespaceTest = MyGame_InParentNamespaceT()
    vectorOfReferrables = []
    singleWeakReference = 0
    vectorOfWeakReferences = []
    vectorOfStrongReferrables = []
    coOwningReference = 0
    vectorOfCoOwningReferences = []
    nonOwningReference = 0
    vectorOfNonOwningReferences = []
    vectorOfEnums = []
    signedEnum = .none_
    testrequirednestedflatbuffer = []
    scalarKeySortedTables = []
    nativeInline = MyGame_Example_Test()
    longEnumNonEnumDefault = .longone
    longEnumNormalDefault = .longone
    nanDefault = .nan
    infDefault = .infinity
    positiveInfDefault = .infinity
    infinityDefault = .infinity
    positiveInfinityDefault = .infinity
    negativeInfDefault = -.infinity
    negativeInfinityDefault = -.infinity
    doubleInfDefault = .infinity
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_Example_Monster.self) }

}
public struct MyGame_Example_TypeAliases: FlatBufferObject, Verifiable, ObjectAPIPacker {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "MONS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MyGame_Example_TypeAliases.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case i8 = 4
    case u8 = 6
    case i16 = 8
    case u16 = 10
    case i32 = 12
    case u32 = 14
    case i64 = 16
    case u64 = 18
    case f32 = 20
    case f64 = 22
    case v8 = 24
    case vf64 = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var i8: Int8 { let o = _accessor.offset(VTOFFSET.i8.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int8.self, at: o) }
  @discardableResult public func mutate(i8: Int8) -> Bool {let o = _accessor.offset(VTOFFSET.i8.v);  return _accessor.mutate(i8, index: o) }
  public var u8: UInt8 { let o = _accessor.offset(VTOFFSET.u8.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  @discardableResult public func mutate(u8: UInt8) -> Bool {let o = _accessor.offset(VTOFFSET.u8.v);  return _accessor.mutate(u8, index: o) }
  public var i16: Int16 { let o = _accessor.offset(VTOFFSET.i16.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  @discardableResult public func mutate(i16: Int16) -> Bool {let o = _accessor.offset(VTOFFSET.i16.v);  return _accessor.mutate(i16, index: o) }
  public var u16: UInt16 { let o = _accessor.offset(VTOFFSET.u16.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  @discardableResult public func mutate(u16: UInt16) -> Bool {let o = _accessor.offset(VTOFFSET.u16.v);  return _accessor.mutate(u16, index: o) }
  public var i32: Int32 { let o = _accessor.offset(VTOFFSET.i32.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  @discardableResult public func mutate(i32: Int32) -> Bool {let o = _accessor.offset(VTOFFSET.i32.v);  return _accessor.mutate(i32, index: o) }
  public var u32: UInt32 { let o = _accessor.offset(VTOFFSET.u32.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  @discardableResult public func mutate(u32: UInt32) -> Bool {let o = _accessor.offset(VTOFFSET.u32.v);  return _accessor.mutate(u32, index: o) }
  public var i64: Int64 { let o = _accessor.offset(VTOFFSET.i64.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  @discardableResult public func mutate(i64: Int64) -> Bool {let o = _accessor.offset(VTOFFSET.i64.v);  return _accessor.mutate(i64, index: o) }
  public var u64: UInt64 { let o = _accessor.offset(VTOFFSET.u64.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(u64: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.u64.v);  return _accessor.mutate(u64, index: o) }
  public var f32: Float32 { let o = _accessor.offset(VTOFFSET.f32.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  @discardableResult public func mutate(f32: Float32) -> Bool {let o = _accessor.offset(VTOFFSET.f32.v);  return _accessor.mutate(f32, index: o) }
  public var f64: Double { let o = _accessor.offset(VTOFFSET.f64.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  @discardableResult public func mutate(f64: Double) -> Bool {let o = _accessor.offset(VTOFFSET.f64.v);  return _accessor.mutate(f64, index: o) }
  public var hasV8: Bool { let o = _accessor.offset(VTOFFSET.v8.v); return o == 0 ? false : true }
  public var v8Count: Int32 { let o = _accessor.offset(VTOFFSET.v8.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func v8(at index: Int32) -> Int8 { let o = _accessor.offset(VTOFFSET.v8.v); return o == 0 ? 0 : _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var v8: [Int8] { return _accessor.getVector(at: VTOFFSET.v8.v) ?? [] }
  public func mutate(v8: Int8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.v8.v); return _accessor.directMutate(v8, index: _accessor.vector(at: o) + index * 1) }
  public var hasVf64: Bool { let o = _accessor.offset(VTOFFSET.vf64.v); return o == 0 ? false : true }
  public var vf64Count: Int32 { let o = _accessor.offset(VTOFFSET.vf64.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func vf64(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.vf64.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var vf64: [Double] { return _accessor.getVector(at: VTOFFSET.vf64.v) ?? [] }
  public func mutate(vf64: Double, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.vf64.v); return _accessor.directMutate(vf64, index: _accessor.vector(at: o) + index * 8) }
  public static func startTypeAliases(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  public static func add(i8: Int8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: i8, def: 0, at: VTOFFSET.i8.p) }
  public static func add(u8: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: u8, def: 0, at: VTOFFSET.u8.p) }
  public static func add(i16: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: i16, def: 0, at: VTOFFSET.i16.p) }
  public static func add(u16: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: u16, def: 0, at: VTOFFSET.u16.p) }
  public static func add(i32: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: i32, def: 0, at: VTOFFSET.i32.p) }
  public static func add(u32: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: u32, def: 0, at: VTOFFSET.u32.p) }
  public static func add(i64: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: i64, def: 0, at: VTOFFSET.i64.p) }
  public static func add(u64: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: u64, def: 0, at: VTOFFSET.u64.p) }
  public static func add(f32: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: f32, def: 0.0, at: VTOFFSET.f32.p) }
  public static func add(f64: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: f64, def: 0.0, at: VTOFFSET.f64.p) }
  public static func addVectorOf(v8: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: v8, at: VTOFFSET.v8.p) }
  public static func addVectorOf(vf64: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: vf64, at: VTOFFSET.vf64.p) }
  public static func endTypeAliases(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTypeAliases(
    _ fbb: inout FlatBufferBuilder,
    i8: Int8 = 0,
    u8: UInt8 = 0,
    i16: Int16 = 0,
    u16: UInt16 = 0,
    i32: Int32 = 0,
    u32: UInt32 = 0,
    i64: Int64 = 0,
    u64: UInt64 = 0,
    f32: Float32 = 0.0,
    f64: Double = 0.0,
    v8VectorOffset v8: Offset = Offset(),
    vf64VectorOffset vf64: Offset = Offset()
  ) -> Offset {
    let __start = MyGame_Example_TypeAliases.startTypeAliases(&fbb)
    MyGame_Example_TypeAliases.add(i8: i8, &fbb)
    MyGame_Example_TypeAliases.add(u8: u8, &fbb)
    MyGame_Example_TypeAliases.add(i16: i16, &fbb)
    MyGame_Example_TypeAliases.add(u16: u16, &fbb)
    MyGame_Example_TypeAliases.add(i32: i32, &fbb)
    MyGame_Example_TypeAliases.add(u32: u32, &fbb)
    MyGame_Example_TypeAliases.add(i64: i64, &fbb)
    MyGame_Example_TypeAliases.add(u64: u64, &fbb)
    MyGame_Example_TypeAliases.add(f32: f32, &fbb)
    MyGame_Example_TypeAliases.add(f64: f64, &fbb)
    MyGame_Example_TypeAliases.addVectorOf(v8: v8, &fbb)
    MyGame_Example_TypeAliases.addVectorOf(vf64: vf64, &fbb)
    return MyGame_Example_TypeAliases.endTypeAliases(&fbb, start: __start)
  }
  

  public mutating func unpack() -> MyGame_Example_TypeAliasesT {
    return MyGame_Example_TypeAliasesT(&self)
  }
  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_TypeAliasesT?) -> Offset {
    guard var obj = obj else { return Offset() }
    return pack(&builder, obj: &obj)
  }

  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout MyGame_Example_TypeAliasesT) -> Offset {
    let __v8 = builder.createVector(obj.v8)
    let __vf64 = builder.createVector(obj.vf64)
    let __root = MyGame_Example_TypeAliases.startTypeAliases(&builder)
    MyGame_Example_TypeAliases.add(i8: obj.i8, &builder)
    MyGame_Example_TypeAliases.add(u8: obj.u8, &builder)
    MyGame_Example_TypeAliases.add(i16: obj.i16, &builder)
    MyGame_Example_TypeAliases.add(u16: obj.u16, &builder)
    MyGame_Example_TypeAliases.add(i32: obj.i32, &builder)
    MyGame_Example_TypeAliases.add(u32: obj.u32, &builder)
    MyGame_Example_TypeAliases.add(i64: obj.i64, &builder)
    MyGame_Example_TypeAliases.add(u64: obj.u64, &builder)
    MyGame_Example_TypeAliases.add(f32: obj.f32, &builder)
    MyGame_Example_TypeAliases.add(f64: obj.f64, &builder)
    MyGame_Example_TypeAliases.addVectorOf(v8: __v8, &builder)
    MyGame_Example_TypeAliases.addVectorOf(vf64: __vf64, &builder)
    return MyGame_Example_TypeAliases.endTypeAliases(&builder, start: __root)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.i8.p, fieldName: "i8", required: false, type: Int8.self)
    try _v.visit(field: VTOFFSET.u8.p, fieldName: "u8", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.i16.p, fieldName: "i16", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.u16.p, fieldName: "u16", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.i32.p, fieldName: "i32", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.u32.p, fieldName: "u32", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.i64.p, fieldName: "i64", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.u64.p, fieldName: "u64", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.f32.p, fieldName: "f32", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.f64.p, fieldName: "f64", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.v8.p, fieldName: "v8", required: false, type: ForwardOffset<Vector<Int8, Int8>>.self)
    try _v.visit(field: VTOFFSET.vf64.p, fieldName: "vf64", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    _v.finish()
  }
}

extension MyGame_Example_TypeAliases: Encodable {

  enum CodingKeys: String, CodingKey {
    case i8 = "i8"
    case u8 = "u8"
    case i16 = "i16"
    case u16 = "u16"
    case i32 = "i32"
    case u32 = "u32"
    case i64 = "i64"
    case u64 = "u64"
    case f32 = "f32"
    case f64 = "f64"
    case v8 = "v8"
    case vf64 = "vf64"
  }
  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    if i8 != 0 {
      try container.encodeIfPresent(i8, forKey: .i8)
    }
    if u8 != 0 {
      try container.encodeIfPresent(u8, forKey: .u8)
    }
    if i16 != 0 {
      try container.encodeIfPresent(i16, forKey: .i16)
    }
    if u16 != 0 {
      try container.encodeIfPresent(u16, forKey: .u16)
    }
    if i32 != 0 {
      try container.encodeIfPresent(i32, forKey: .i32)
    }
    if u32 != 0 {
      try container.encodeIfPresent(u32, forKey: .u32)
    }
    if i64 != 0 {
      try container.encodeIfPresent(i64, forKey: .i64)
    }
    if u64 != 0 {
      try container.encodeIfPresent(u64, forKey: .u64)
    }
    if f32 != 0.0 {
      try container.encodeIfPresent(f32, forKey: .f32)
    }
    if f64 != 0.0 {
      try container.encodeIfPresent(f64, forKey: .f64)
    }
    if v8Count > 0 {
      try container.encodeIfPresent(v8, forKey: .v8)
    }
    if vf64Count > 0 {
      try container.encodeIfPresent(vf64, forKey: .vf64)
    }
  }
}

public class MyGame_Example_TypeAliasesT: NativeObject {

  public var i8: Int8
  public var u8: UInt8
  public var i16: Int16
  public var u16: UInt16
  public var i32: Int32
  public var u32: UInt32
  public var i64: Int64
  public var u64: UInt64
  public var f32: Float32
  public var f64: Double
  public var v8: [Int8]
  public var vf64: [Double]

  public init(_ _t: inout MyGame_Example_TypeAliases) {
    i8 = _t.i8
    u8 = _t.u8
    i16 = _t.i16
    u16 = _t.u16
    i32 = _t.i32
    u32 = _t.u32
    i64 = _t.i64
    u64 = _t.u64
    f32 = _t.f32
    f64 = _t.f64
    v8 = []
    for index in 0..<_t.v8Count {
        v8.append(_t.v8(at: index))
    }
    vf64 = []
    for index in 0..<_t.vf64Count {
        vf64.append(_t.vf64(at: index))
    }
  }

  public init() {
    i8 = 0
    u8 = 0
    i16 = 0
    u16 = 0
    i32 = 0
    u32 = 0
    i64 = 0
    u64 = 0
    f32 = 0.0
    f64 = 0.0
    v8 = []
    vf64 = []
  }

  public func serialize() -> ByteBuffer { return serialize(type: MyGame_Example_TypeAliases.self) }

}

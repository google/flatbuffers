// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
extern crate serde;
use self::serde::ser::{Serialize, Serializer, SerializeStruct};
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MonsterOffset {}
#[derive(Copy, Clone, PartialEq)]

/// an example documentation comment: "monster object"
pub struct Monster<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Monster<'a> {
  type Inner = Monster<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Monster<'a> {
  pub const VT_POS: flatbuffers::VOffsetT = 4;
  pub const VT_MANA: flatbuffers::VOffsetT = 6;
  pub const VT_HP: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_INVENTORY: flatbuffers::VOffsetT = 14;
  pub const VT_COLOR: flatbuffers::VOffsetT = 16;
  pub const VT_TEST_TYPE: flatbuffers::VOffsetT = 18;
  pub const VT_TEST: flatbuffers::VOffsetT = 20;
  pub const VT_TEST4: flatbuffers::VOffsetT = 22;
  pub const VT_TESTARRAYOFSTRING: flatbuffers::VOffsetT = 24;
  pub const VT_TESTARRAYOFTABLES: flatbuffers::VOffsetT = 26;
  pub const VT_ENEMY: flatbuffers::VOffsetT = 28;
  pub const VT_TESTNESTEDFLATBUFFER: flatbuffers::VOffsetT = 30;
  pub const VT_TESTEMPTY: flatbuffers::VOffsetT = 32;
  pub const VT_TESTBOOL: flatbuffers::VOffsetT = 34;
  pub const VT_TESTHASHS32_FNV1: flatbuffers::VOffsetT = 36;
  pub const VT_TESTHASHU32_FNV1: flatbuffers::VOffsetT = 38;
  pub const VT_TESTHASHS64_FNV1: flatbuffers::VOffsetT = 40;
  pub const VT_TESTHASHU64_FNV1: flatbuffers::VOffsetT = 42;
  pub const VT_TESTHASHS32_FNV1A: flatbuffers::VOffsetT = 44;
  pub const VT_TESTHASHU32_FNV1A: flatbuffers::VOffsetT = 46;
  pub const VT_TESTHASHS64_FNV1A: flatbuffers::VOffsetT = 48;
  pub const VT_TESTHASHU64_FNV1A: flatbuffers::VOffsetT = 50;
  pub const VT_TESTARRAYOFBOOLS: flatbuffers::VOffsetT = 52;
  pub const VT_TESTF: flatbuffers::VOffsetT = 54;
  pub const VT_TESTF2: flatbuffers::VOffsetT = 56;
  pub const VT_TESTF3: flatbuffers::VOffsetT = 58;
  pub const VT_TESTARRAYOFSTRING2: flatbuffers::VOffsetT = 60;
  pub const VT_TESTARRAYOFSORTEDSTRUCT: flatbuffers::VOffsetT = 62;
  pub const VT_FLEX: flatbuffers::VOffsetT = 64;
  pub const VT_TEST5: flatbuffers::VOffsetT = 66;
  pub const VT_VECTOR_OF_LONGS: flatbuffers::VOffsetT = 68;
  pub const VT_VECTOR_OF_DOUBLES: flatbuffers::VOffsetT = 70;
  pub const VT_PARENT_NAMESPACE_TEST: flatbuffers::VOffsetT = 72;
  pub const VT_VECTOR_OF_REFERRABLES: flatbuffers::VOffsetT = 74;
  pub const VT_SINGLE_WEAK_REFERENCE: flatbuffers::VOffsetT = 76;
  pub const VT_VECTOR_OF_WEAK_REFERENCES: flatbuffers::VOffsetT = 78;
  pub const VT_VECTOR_OF_STRONG_REFERRABLES: flatbuffers::VOffsetT = 80;
  pub const VT_CO_OWNING_REFERENCE: flatbuffers::VOffsetT = 82;
  pub const VT_VECTOR_OF_CO_OWNING_REFERENCES: flatbuffers::VOffsetT = 84;
  pub const VT_NON_OWNING_REFERENCE: flatbuffers::VOffsetT = 86;
  pub const VT_VECTOR_OF_NON_OWNING_REFERENCES: flatbuffers::VOffsetT = 88;
  pub const VT_ANY_UNIQUE_TYPE: flatbuffers::VOffsetT = 90;
  pub const VT_ANY_UNIQUE: flatbuffers::VOffsetT = 92;
  pub const VT_ANY_AMBIGUOUS_TYPE: flatbuffers::VOffsetT = 94;
  pub const VT_ANY_AMBIGUOUS: flatbuffers::VOffsetT = 96;
  pub const VT_VECTOR_OF_ENUMS: flatbuffers::VOffsetT = 98;
  pub const VT_SIGNED_ENUM: flatbuffers::VOffsetT = 100;
  pub const VT_TESTREQUIREDNESTEDFLATBUFFER: flatbuffers::VOffsetT = 102;
  pub const VT_SCALAR_KEY_SORTED_TABLES: flatbuffers::VOffsetT = 104;
  pub const VT_NATIVE_INLINE: flatbuffers::VOffsetT = 106;
  pub const VT_LONG_ENUM_NON_ENUM_DEFAULT: flatbuffers::VOffsetT = 108;
  pub const VT_LONG_ENUM_NORMAL_DEFAULT: flatbuffers::VOffsetT = 110;
  pub const VT_NAN_DEFAULT: flatbuffers::VOffsetT = 112;
  pub const VT_INF_DEFAULT: flatbuffers::VOffsetT = 114;
  pub const VT_POSITIVE_INF_DEFAULT: flatbuffers::VOffsetT = 116;
  pub const VT_INFINITY_DEFAULT: flatbuffers::VOffsetT = 118;
  pub const VT_POSITIVE_INFINITY_DEFAULT: flatbuffers::VOffsetT = 120;
  pub const VT_NEGATIVE_INF_DEFAULT: flatbuffers::VOffsetT = 122;
  pub const VT_NEGATIVE_INFINITY_DEFAULT: flatbuffers::VOffsetT = 124;
  pub const VT_DOUBLE_INF_DEFAULT: flatbuffers::VOffsetT = 126;

  pub const fn get_fully_qualified_name() -> &'static str {
    "MyGame.Example.Monster"
  }

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Monster { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MonsterArgs<'args>
  ) -> flatbuffers::WIPOffset<Monster<'bldr>> {
    let mut builder = MonsterBuilder::new(_fbb);
    builder.add_double_inf_default(args.double_inf_default);
    builder.add_long_enum_normal_default(args.long_enum_normal_default);
    builder.add_long_enum_non_enum_default(args.long_enum_non_enum_default);
    builder.add_non_owning_reference(args.non_owning_reference);
    builder.add_co_owning_reference(args.co_owning_reference);
    builder.add_single_weak_reference(args.single_weak_reference);
    builder.add_testhashu64_fnv1a(args.testhashu64_fnv1a);
    builder.add_testhashs64_fnv1a(args.testhashs64_fnv1a);
    builder.add_testhashu64_fnv1(args.testhashu64_fnv1);
    builder.add_testhashs64_fnv1(args.testhashs64_fnv1);
    builder.add_negative_infinity_default(args.negative_infinity_default);
    builder.add_negative_inf_default(args.negative_inf_default);
    builder.add_positive_infinity_default(args.positive_infinity_default);
    builder.add_infinity_default(args.infinity_default);
    builder.add_positive_inf_default(args.positive_inf_default);
    builder.add_inf_default(args.inf_default);
    builder.add_nan_default(args.nan_default);
    if let Some(x) = args.native_inline { builder.add_native_inline(x); }
    if let Some(x) = args.scalar_key_sorted_tables { builder.add_scalar_key_sorted_tables(x); }
    if let Some(x) = args.testrequirednestedflatbuffer { builder.add_testrequirednestedflatbuffer(x); }
    if let Some(x) = args.vector_of_enums { builder.add_vector_of_enums(x); }
    if let Some(x) = args.any_ambiguous { builder.add_any_ambiguous(x); }
    if let Some(x) = args.any_unique { builder.add_any_unique(x); }
    if let Some(x) = args.vector_of_non_owning_references { builder.add_vector_of_non_owning_references(x); }
    if let Some(x) = args.vector_of_co_owning_references { builder.add_vector_of_co_owning_references(x); }
    if let Some(x) = args.vector_of_strong_referrables { builder.add_vector_of_strong_referrables(x); }
    if let Some(x) = args.vector_of_weak_references { builder.add_vector_of_weak_references(x); }
    if let Some(x) = args.vector_of_referrables { builder.add_vector_of_referrables(x); }
    if let Some(x) = args.parent_namespace_test { builder.add_parent_namespace_test(x); }
    if let Some(x) = args.vector_of_doubles { builder.add_vector_of_doubles(x); }
    if let Some(x) = args.vector_of_longs { builder.add_vector_of_longs(x); }
    if let Some(x) = args.test5 { builder.add_test5(x); }
    if let Some(x) = args.flex { builder.add_flex(x); }
    if let Some(x) = args.testarrayofsortedstruct { builder.add_testarrayofsortedstruct(x); }
    if let Some(x) = args.testarrayofstring2 { builder.add_testarrayofstring2(x); }
    builder.add_testf3(args.testf3);
    builder.add_testf2(args.testf2);
    builder.add_testf(args.testf);
    if let Some(x) = args.testarrayofbools { builder.add_testarrayofbools(x); }
    builder.add_testhashu32_fnv1a(args.testhashu32_fnv1a);
    builder.add_testhashs32_fnv1a(args.testhashs32_fnv1a);
    builder.add_testhashu32_fnv1(args.testhashu32_fnv1);
    builder.add_testhashs32_fnv1(args.testhashs32_fnv1);
    if let Some(x) = args.testempty { builder.add_testempty(x); }
    if let Some(x) = args.testnestedflatbuffer { builder.add_testnestedflatbuffer(x); }
    if let Some(x) = args.enemy { builder.add_enemy(x); }
    if let Some(x) = args.testarrayoftables { builder.add_testarrayoftables(x); }
    if let Some(x) = args.testarrayofstring { builder.add_testarrayofstring(x); }
    if let Some(x) = args.test4 { builder.add_test4(x); }
    if let Some(x) = args.test { builder.add_test(x); }
    if let Some(x) = args.inventory { builder.add_inventory(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.pos { builder.add_pos(x); }
    builder.add_hp(args.hp);
    builder.add_mana(args.mana);
    builder.add_signed_enum(args.signed_enum);
    builder.add_any_ambiguous_type(args.any_ambiguous_type);
    builder.add_any_unique_type(args.any_unique_type);
    builder.add_testbool(args.testbool);
    builder.add_test_type(args.test_type);
    builder.add_color(args.color);
    builder.finish()
  }

  pub fn unpack(&self) -> MonsterT {
    let pos = self.pos().map(|x| {
      x.unpack()
    });
    let mana = self.mana();
    let hp = self.hp();
    let name = {
      let x = self.name();
      x.to_string()
    };
    let inventory = self.inventory().map(|x| {
      x.into_iter().collect()
    });
    let color = self.color();
    let test = match self.test_type() {
      Any::NONE => AnyT::NONE,
      Any::Monster => AnyT::Monster(Box::new(
        self.test_as_monster()
            .expect("Invalid union table, expected `Any::Monster`.")
            .unpack()
      )),
      Any::TestSimpleTableWithEnum => AnyT::TestSimpleTableWithEnum(Box::new(
        self.test_as_test_simple_table_with_enum()
            .expect("Invalid union table, expected `Any::TestSimpleTableWithEnum`.")
            .unpack()
      )),
      Any::MyGame_Example2_Monster => AnyT::MyGameExample2Monster(Box::new(
        self.test_as_my_game_example_2_monster()
            .expect("Invalid union table, expected `Any::MyGame_Example2_Monster`.")
            .unpack()
      )),
      _ => AnyT::NONE,
    };
    let test4 = self.test4().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let testarrayofstring = self.testarrayofstring().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let testarrayoftables = self.testarrayoftables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let enemy = self.enemy().map(|x| {
      Box::new(x.unpack())
    });
    let testnestedflatbuffer = self.testnestedflatbuffer().map(|x| {
      x.into_iter().collect()
    });
    let testempty = self.testempty().map(|x| {
      Box::new(x.unpack())
    });
    let testbool = self.testbool();
    let testhashs32_fnv1 = self.testhashs32_fnv1();
    let testhashu32_fnv1 = self.testhashu32_fnv1();
    let testhashs64_fnv1 = self.testhashs64_fnv1();
    let testhashu64_fnv1 = self.testhashu64_fnv1();
    let testhashs32_fnv1a = self.testhashs32_fnv1a();
    let testhashu32_fnv1a = self.testhashu32_fnv1a();
    let testhashs64_fnv1a = self.testhashs64_fnv1a();
    let testhashu64_fnv1a = self.testhashu64_fnv1a();
    let testarrayofbools = self.testarrayofbools().map(|x| {
      x.into_iter().collect()
    });
    let testf = self.testf();
    let testf2 = self.testf2();
    let testf3 = self.testf3();
    let testarrayofstring2 = self.testarrayofstring2().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let testarrayofsortedstruct = self.testarrayofsortedstruct().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let flex = self.flex().map(|x| {
      x.into_iter().collect()
    });
    let test5 = self.test5().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let vector_of_longs = self.vector_of_longs().map(|x| {
      x.into_iter().collect()
    });
    let vector_of_doubles = self.vector_of_doubles().map(|x| {
      x.into_iter().collect()
    });
    let parent_namespace_test = self.parent_namespace_test().map(|x| {
      Box::new(x.unpack())
    });
    let vector_of_referrables = self.vector_of_referrables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let single_weak_reference = self.single_weak_reference();
    let vector_of_weak_references = self.vector_of_weak_references().map(|x| {
      x.into_iter().collect()
    });
    let vector_of_strong_referrables = self.vector_of_strong_referrables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let co_owning_reference = self.co_owning_reference();
    let vector_of_co_owning_references = self.vector_of_co_owning_references().map(|x| {
      x.into_iter().collect()
    });
    let non_owning_reference = self.non_owning_reference();
    let vector_of_non_owning_references = self.vector_of_non_owning_references().map(|x| {
      x.into_iter().collect()
    });
    let any_unique = match self.any_unique_type() {
      AnyUniqueAliases::NONE => AnyUniqueAliasesT::NONE,
      AnyUniqueAliases::M => AnyUniqueAliasesT::M(Box::new(
        self.any_unique_as_m()
            .expect("Invalid union table, expected `AnyUniqueAliases::M`.")
            .unpack()
      )),
      AnyUniqueAliases::TS => AnyUniqueAliasesT::TS(Box::new(
        self.any_unique_as_ts()
            .expect("Invalid union table, expected `AnyUniqueAliases::TS`.")
            .unpack()
      )),
      AnyUniqueAliases::M2 => AnyUniqueAliasesT::M2(Box::new(
        self.any_unique_as_m2()
            .expect("Invalid union table, expected `AnyUniqueAliases::M2`.")
            .unpack()
      )),
      _ => AnyUniqueAliasesT::NONE,
    };
    let any_ambiguous = match self.any_ambiguous_type() {
      AnyAmbiguousAliases::NONE => AnyAmbiguousAliasesT::NONE,
      AnyAmbiguousAliases::M1 => AnyAmbiguousAliasesT::M1(Box::new(
        self.any_ambiguous_as_m1()
            .expect("Invalid union table, expected `AnyAmbiguousAliases::M1`.")
            .unpack()
      )),
      AnyAmbiguousAliases::M2 => AnyAmbiguousAliasesT::M2(Box::new(
        self.any_ambiguous_as_m2()
            .expect("Invalid union table, expected `AnyAmbiguousAliases::M2`.")
            .unpack()
      )),
      AnyAmbiguousAliases::M3 => AnyAmbiguousAliasesT::M3(Box::new(
        self.any_ambiguous_as_m3()
            .expect("Invalid union table, expected `AnyAmbiguousAliases::M3`.")
            .unpack()
      )),
      _ => AnyAmbiguousAliasesT::NONE,
    };
    let vector_of_enums = self.vector_of_enums().map(|x| {
      x.into_iter().collect()
    });
    let signed_enum = self.signed_enum();
    let testrequirednestedflatbuffer = self.testrequirednestedflatbuffer().map(|x| {
      x.into_iter().collect()
    });
    let scalar_key_sorted_tables = self.scalar_key_sorted_tables().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let native_inline = self.native_inline().map(|x| {
      x.unpack()
    });
    let long_enum_non_enum_default = self.long_enum_non_enum_default();
    let long_enum_normal_default = self.long_enum_normal_default();
    let nan_default = self.nan_default();
    let inf_default = self.inf_default();
    let positive_inf_default = self.positive_inf_default();
    let infinity_default = self.infinity_default();
    let positive_infinity_default = self.positive_infinity_default();
    let negative_inf_default = self.negative_inf_default();
    let negative_infinity_default = self.negative_infinity_default();
    let double_inf_default = self.double_inf_default();
    MonsterT {
      pos,
      mana,
      hp,
      name,
      inventory,
      color,
      test,
      test4,
      testarrayofstring,
      testarrayoftables,
      enemy,
      testnestedflatbuffer,
      testempty,
      testbool,
      testhashs32_fnv1,
      testhashu32_fnv1,
      testhashs64_fnv1,
      testhashu64_fnv1,
      testhashs32_fnv1a,
      testhashu32_fnv1a,
      testhashs64_fnv1a,
      testhashu64_fnv1a,
      testarrayofbools,
      testf,
      testf2,
      testf3,
      testarrayofstring2,
      testarrayofsortedstruct,
      flex,
      test5,
      vector_of_longs,
      vector_of_doubles,
      parent_namespace_test,
      vector_of_referrables,
      single_weak_reference,
      vector_of_weak_references,
      vector_of_strong_referrables,
      co_owning_reference,
      vector_of_co_owning_references,
      non_owning_reference,
      vector_of_non_owning_references,
      any_unique,
      any_ambiguous,
      vector_of_enums,
      signed_enum,
      testrequirednestedflatbuffer,
      scalar_key_sorted_tables,
      native_inline,
      long_enum_non_enum_default,
      long_enum_normal_default,
      nan_default,
      inf_default,
      positive_inf_default,
      infinity_default,
      positive_infinity_default,
      negative_inf_default,
      negative_infinity_default,
      double_inf_default,
    }
  }

  #[inline]
  pub fn pos(&self) -> Option<&'a Vec3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vec3>(Monster::VT_POS, None)}
  }
  #[inline]
  pub fn mana(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(Monster::VT_MANA, Some(150)).unwrap()}
  }
  #[inline]
  pub fn hp(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(Monster::VT_HP, Some(100)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Monster) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn inventory(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_INVENTORY, None)}
  }
  #[inline]
  pub fn color(&self) -> Color {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Color>(Monster::VT_COLOR, Some(Color::Blue)).unwrap()}
  }
  #[inline]
  pub fn test_type(&self) -> Any {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Any>(Monster::VT_TEST_TYPE, Some(Any::NONE)).unwrap()}
  }
  #[inline]
  pub fn test(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_TEST, None)}
  }
  #[inline]
  pub fn test4(&self) -> Option<flatbuffers::Vector<'a, Test>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Test>>>(Monster::VT_TEST4, None)}
  }
  #[inline]
  pub fn testarrayofstring(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Monster::VT_TESTARRAYOFSTRING, None)}
  }
  /// an example documentation comment: this will end up in the generated code
  /// multiline too
  #[inline]
  pub fn testarrayoftables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster>>>>(Monster::VT_TESTARRAYOFTABLES, None)}
  }
  #[inline]
  pub fn enemy(&self) -> Option<Monster<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Monster>>(Monster::VT_ENEMY, None)}
  }
  #[inline]
  pub fn testnestedflatbuffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_TESTNESTEDFLATBUFFER, None)}
  }
  pub fn testnestedflatbuffer_nested_flatbuffer(&'a self) -> Option<Monster<'a>> {
    self.testnestedflatbuffer().map(|data| {
      use flatbuffers::Follow;
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid flatbuffer in this slot
      unsafe { <flatbuffers::ForwardsUOffset<Monster<'a>>>::follow(data.bytes(), 0) }
    })
  }
  #[inline]
  pub fn testempty(&self) -> Option<Stat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Stat>>(Monster::VT_TESTEMPTY, None)}
  }
  #[inline]
  pub fn testbool(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Monster::VT_TESTBOOL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn testhashs32_fnv1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Monster::VT_TESTHASHS32_FNV1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashu32_fnv1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Monster::VT_TESTHASHU32_FNV1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashs64_fnv1(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Monster::VT_TESTHASHS64_FNV1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashu64_fnv1(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Monster::VT_TESTHASHU64_FNV1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashs32_fnv1a(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Monster::VT_TESTHASHS32_FNV1A, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashu32_fnv1a(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Monster::VT_TESTHASHU32_FNV1A, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashs64_fnv1a(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Monster::VT_TESTHASHS64_FNV1A, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testhashu64_fnv1a(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Monster::VT_TESTHASHU64_FNV1A, Some(0)).unwrap()}
  }
  #[inline]
  pub fn testarrayofbools(&self) -> Option<flatbuffers::Vector<'a, bool>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(Monster::VT_TESTARRAYOFBOOLS, None)}
  }
  #[inline]
  pub fn testf(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_TESTF, Some(3.14159)).unwrap()}
  }
  #[inline]
  pub fn testf2(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_TESTF2, Some(3.0)).unwrap()}
  }
  #[inline]
  pub fn testf3(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_TESTF3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn testarrayofstring2(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Monster::VT_TESTARRAYOFSTRING2, None)}
  }
  #[inline]
  pub fn testarrayofsortedstruct(&self) -> Option<flatbuffers::Vector<'a, Ability>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Ability>>>(Monster::VT_TESTARRAYOFSORTEDSTRUCT, None)}
  }
  #[inline]
  pub fn flex(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_FLEX, None)}
  }
  #[inline]
  pub fn test5(&self) -> Option<flatbuffers::Vector<'a, Test>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Test>>>(Monster::VT_TEST5, None)}
  }
  #[inline]
  pub fn vector_of_longs(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Monster::VT_VECTOR_OF_LONGS, None)}
  }
  #[inline]
  pub fn vector_of_doubles(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Monster::VT_VECTOR_OF_DOUBLES, None)}
  }
  #[inline]
  pub fn parent_namespace_test(&self) -> Option<super::InParentNamespace<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::InParentNamespace>>(Monster::VT_PARENT_NAMESPACE_TEST, None)}
  }
  #[inline]
  pub fn vector_of_referrables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable>>>>(Monster::VT_VECTOR_OF_REFERRABLES, None)}
  }
  #[inline]
  pub fn single_weak_reference(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Monster::VT_SINGLE_WEAK_REFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vector_of_weak_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_WEAK_REFERENCES, None)}
  }
  #[inline]
  pub fn vector_of_strong_referrables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable>>>>(Monster::VT_VECTOR_OF_STRONG_REFERRABLES, None)}
  }
  #[inline]
  pub fn co_owning_reference(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Monster::VT_CO_OWNING_REFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vector_of_co_owning_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_CO_OWNING_REFERENCES, None)}
  }
  #[inline]
  pub fn non_owning_reference(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Monster::VT_NON_OWNING_REFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vector_of_non_owning_references(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Monster::VT_VECTOR_OF_NON_OWNING_REFERENCES, None)}
  }
  #[inline]
  pub fn any_unique_type(&self) -> AnyUniqueAliases {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AnyUniqueAliases>(Monster::VT_ANY_UNIQUE_TYPE, Some(AnyUniqueAliases::NONE)).unwrap()}
  }
  #[inline]
  pub fn any_unique(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_ANY_UNIQUE, None)}
  }
  #[inline]
  pub fn any_ambiguous_type(&self) -> AnyAmbiguousAliases {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AnyAmbiguousAliases>(Monster::VT_ANY_AMBIGUOUS_TYPE, Some(AnyAmbiguousAliases::NONE)).unwrap()}
  }
  #[inline]
  pub fn any_ambiguous(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_ANY_AMBIGUOUS, None)}
  }
  #[inline]
  pub fn vector_of_enums(&self) -> Option<flatbuffers::Vector<'a, Color>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Color>>>(Monster::VT_VECTOR_OF_ENUMS, None)}
  }
  #[inline]
  pub fn signed_enum(&self) -> Race {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Race>(Monster::VT_SIGNED_ENUM, Some(Race::None)).unwrap()}
  }
  #[inline]
  pub fn testrequirednestedflatbuffer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_TESTREQUIREDNESTEDFLATBUFFER, None)}
  }
  pub fn testrequirednestedflatbuffer_nested_flatbuffer(&'a self) -> Option<Monster<'a>> {
    self.testrequirednestedflatbuffer().map(|data| {
      use flatbuffers::Follow;
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid flatbuffer in this slot
      unsafe { <flatbuffers::ForwardsUOffset<Monster<'a>>>::follow(data.bytes(), 0) }
    })
  }
  #[inline]
  pub fn scalar_key_sorted_tables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat>>>>(Monster::VT_SCALAR_KEY_SORTED_TABLES, None)}
  }
  #[inline]
  pub fn native_inline(&self) -> Option<&'a Test> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Test>(Monster::VT_NATIVE_INLINE, None)}
  }
  #[inline]
  pub fn long_enum_non_enum_default(&self) -> LongEnum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LongEnum>(Monster::VT_LONG_ENUM_NON_ENUM_DEFAULT, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn long_enum_normal_default(&self) -> LongEnum {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LongEnum>(Monster::VT_LONG_ENUM_NORMAL_DEFAULT, Some(LongEnum::LongOne)).unwrap()}
  }
  #[inline]
  pub fn nan_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_NAN_DEFAULT, Some(f32::NAN)).unwrap()}
  }
  #[inline]
  pub fn inf_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_INF_DEFAULT, Some(f32::INFINITY)).unwrap()}
  }
  #[inline]
  pub fn positive_inf_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_POSITIVE_INF_DEFAULT, Some(f32::INFINITY)).unwrap()}
  }
  #[inline]
  pub fn infinity_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_INFINITY_DEFAULT, Some(f32::INFINITY)).unwrap()}
  }
  #[inline]
  pub fn positive_infinity_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_POSITIVE_INFINITY_DEFAULT, Some(f32::INFINITY)).unwrap()}
  }
  #[inline]
  pub fn negative_inf_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_NEGATIVE_INF_DEFAULT, Some(f32::NEG_INFINITY)).unwrap()}
  }
  #[inline]
  pub fn negative_infinity_default(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Monster::VT_NEGATIVE_INFINITY_DEFAULT, Some(f32::NEG_INFINITY)).unwrap()}
  }
  #[inline]
  pub fn double_inf_default(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Monster::VT_DOUBLE_INF_DEFAULT, Some(f64::INFINITY)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_monster(&self) -> Option<Monster<'a>> {
    if self.test_type() == Any::Monster {
      self.test().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_test_simple_table_with_enum(&self) -> Option<TestSimpleTableWithEnum<'a>> {
    if self.test_type() == Any::TestSimpleTableWithEnum {
      self.test().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TestSimpleTableWithEnum::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn test_as_my_game_example_2_monster(&self) -> Option<super::example_2::Monster<'a>> {
    if self.test_type() == Any::MyGame_Example2_Monster {
      self.test().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { super::example_2::Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_m(&self) -> Option<Monster<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::M {
      self.any_unique().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_ts(&self) -> Option<TestSimpleTableWithEnum<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::TS {
      self.any_unique().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TestSimpleTableWithEnum::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_unique_as_m2(&self) -> Option<super::example_2::Monster<'a>> {
    if self.any_unique_type() == AnyUniqueAliases::M2 {
      self.any_unique().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { super::example_2::Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m1(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M1 {
      self.any_ambiguous().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m2(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M2 {
      self.any_ambiguous().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_ambiguous_as_m3(&self) -> Option<Monster<'a>> {
    if self.any_ambiguous_type() == AnyAmbiguousAliases::M3 {
      self.any_ambiguous().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Monster::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Monster<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vec3>("pos", Self::VT_POS, false)?
     .visit_field::<i16>("mana", Self::VT_MANA, false)?
     .visit_field::<i16>("hp", Self::VT_HP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("inventory", Self::VT_INVENTORY, false)?
     .visit_field::<Color>("color", Self::VT_COLOR, false)?
     .visit_union::<Any, _>("test_type", Self::VT_TEST_TYPE, "test", Self::VT_TEST, false, |key, v, pos| {
        match key {
          Any::Monster => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("Any::Monster", pos),
          Any::TestSimpleTableWithEnum => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestSimpleTableWithEnum>>("Any::TestSimpleTableWithEnum", pos),
          Any::MyGame_Example2_Monster => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::example_2::Monster>>("Any::MyGame_Example2_Monster", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Test>>>("test4", Self::VT_TEST4, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("testarrayofstring", Self::VT_TESTARRAYOFSTRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Monster>>>>("testarrayoftables", Self::VT_TESTARRAYOFTABLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Monster>>("enemy", Self::VT_ENEMY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("testnestedflatbuffer", Self::VT_TESTNESTEDFLATBUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Stat>>("testempty", Self::VT_TESTEMPTY, false)?
     .visit_field::<bool>("testbool", Self::VT_TESTBOOL, false)?
     .visit_field::<i32>("testhashs32_fnv1", Self::VT_TESTHASHS32_FNV1, false)?
     .visit_field::<u32>("testhashu32_fnv1", Self::VT_TESTHASHU32_FNV1, false)?
     .visit_field::<i64>("testhashs64_fnv1", Self::VT_TESTHASHS64_FNV1, false)?
     .visit_field::<u64>("testhashu64_fnv1", Self::VT_TESTHASHU64_FNV1, false)?
     .visit_field::<i32>("testhashs32_fnv1a", Self::VT_TESTHASHS32_FNV1A, false)?
     .visit_field::<u32>("testhashu32_fnv1a", Self::VT_TESTHASHU32_FNV1A, false)?
     .visit_field::<i64>("testhashs64_fnv1a", Self::VT_TESTHASHS64_FNV1A, false)?
     .visit_field::<u64>("testhashu64_fnv1a", Self::VT_TESTHASHU64_FNV1A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("testarrayofbools", Self::VT_TESTARRAYOFBOOLS, false)?
     .visit_field::<f32>("testf", Self::VT_TESTF, false)?
     .visit_field::<f32>("testf2", Self::VT_TESTF2, false)?
     .visit_field::<f32>("testf3", Self::VT_TESTF3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("testarrayofstring2", Self::VT_TESTARRAYOFSTRING2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Ability>>>("testarrayofsortedstruct", Self::VT_TESTARRAYOFSORTEDSTRUCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("flex", Self::VT_FLEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Test>>>("test5", Self::VT_TEST5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("vector_of_longs", Self::VT_VECTOR_OF_LONGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("vector_of_doubles", Self::VT_VECTOR_OF_DOUBLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::InParentNamespace>>("parent_namespace_test", Self::VT_PARENT_NAMESPACE_TEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Referrable>>>>("vector_of_referrables", Self::VT_VECTOR_OF_REFERRABLES, false)?
     .visit_field::<u64>("single_weak_reference", Self::VT_SINGLE_WEAK_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("vector_of_weak_references", Self::VT_VECTOR_OF_WEAK_REFERENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Referrable>>>>("vector_of_strong_referrables", Self::VT_VECTOR_OF_STRONG_REFERRABLES, false)?
     .visit_field::<u64>("co_owning_reference", Self::VT_CO_OWNING_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("vector_of_co_owning_references", Self::VT_VECTOR_OF_CO_OWNING_REFERENCES, false)?
     .visit_field::<u64>("non_owning_reference", Self::VT_NON_OWNING_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("vector_of_non_owning_references", Self::VT_VECTOR_OF_NON_OWNING_REFERENCES, false)?
     .visit_union::<AnyUniqueAliases, _>("any_unique_type", Self::VT_ANY_UNIQUE_TYPE, "any_unique", Self::VT_ANY_UNIQUE, false, |key, v, pos| {
        match key {
          AnyUniqueAliases::M => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyUniqueAliases::M", pos),
          AnyUniqueAliases::TS => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TestSimpleTableWithEnum>>("AnyUniqueAliases::TS", pos),
          AnyUniqueAliases::M2 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<super::example_2::Monster>>("AnyUniqueAliases::M2", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<AnyAmbiguousAliases, _>("any_ambiguous_type", Self::VT_ANY_AMBIGUOUS_TYPE, "any_ambiguous", Self::VT_ANY_AMBIGUOUS, false, |key, v, pos| {
        match key {
          AnyAmbiguousAliases::M1 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M1", pos),
          AnyAmbiguousAliases::M2 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M2", pos),
          AnyAmbiguousAliases::M3 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Monster>>("AnyAmbiguousAliases::M3", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Color>>>("vector_of_enums", Self::VT_VECTOR_OF_ENUMS, false)?
     .visit_field::<Race>("signed_enum", Self::VT_SIGNED_ENUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("testrequirednestedflatbuffer", Self::VT_TESTREQUIREDNESTEDFLATBUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Stat>>>>("scalar_key_sorted_tables", Self::VT_SCALAR_KEY_SORTED_TABLES, false)?
     .visit_field::<Test>("native_inline", Self::VT_NATIVE_INLINE, false)?
     .visit_field::<LongEnum>("long_enum_non_enum_default", Self::VT_LONG_ENUM_NON_ENUM_DEFAULT, false)?
     .visit_field::<LongEnum>("long_enum_normal_default", Self::VT_LONG_ENUM_NORMAL_DEFAULT, false)?
     .visit_field::<f32>("nan_default", Self::VT_NAN_DEFAULT, false)?
     .visit_field::<f32>("inf_default", Self::VT_INF_DEFAULT, false)?
     .visit_field::<f32>("positive_inf_default", Self::VT_POSITIVE_INF_DEFAULT, false)?
     .visit_field::<f32>("infinity_default", Self::VT_INFINITY_DEFAULT, false)?
     .visit_field::<f32>("positive_infinity_default", Self::VT_POSITIVE_INFINITY_DEFAULT, false)?
     .visit_field::<f32>("negative_inf_default", Self::VT_NEGATIVE_INF_DEFAULT, false)?
     .visit_field::<f32>("negative_infinity_default", Self::VT_NEGATIVE_INFINITY_DEFAULT, false)?
     .visit_field::<f64>("double_inf_default", Self::VT_DOUBLE_INF_DEFAULT, false)?
     .finish();
    Ok(())
  }
}
pub struct MonsterArgs<'a> {
    pub pos: Option<&'a Vec3>,
    pub mana: i16,
    pub hp: i16,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub color: Color,
    pub test_type: Any,
    pub test: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub test4: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Test>>>,
    pub testarrayofstring: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub testarrayoftables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Monster<'a>>>>>,
    pub enemy: Option<flatbuffers::WIPOffset<Monster<'a>>>,
    pub testnestedflatbuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub testempty: Option<flatbuffers::WIPOffset<Stat<'a>>>,
    pub testbool: bool,
    pub testhashs32_fnv1: i32,
    pub testhashu32_fnv1: u32,
    pub testhashs64_fnv1: i64,
    pub testhashu64_fnv1: u64,
    pub testhashs32_fnv1a: i32,
    pub testhashu32_fnv1a: u32,
    pub testhashs64_fnv1a: i64,
    pub testhashu64_fnv1a: u64,
    pub testarrayofbools: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub testf: f32,
    pub testf2: f32,
    pub testf3: f32,
    pub testarrayofstring2: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub testarrayofsortedstruct: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Ability>>>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub test5: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Test>>>,
    pub vector_of_longs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub vector_of_doubles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub parent_namespace_test: Option<flatbuffers::WIPOffset<super::InParentNamespace<'a>>>,
    pub vector_of_referrables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>>>,
    pub single_weak_reference: u64,
    pub vector_of_weak_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub vector_of_strong_referrables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Referrable<'a>>>>>,
    pub co_owning_reference: u64,
    pub vector_of_co_owning_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub non_owning_reference: u64,
    pub vector_of_non_owning_references: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub any_unique_type: AnyUniqueAliases,
    pub any_unique: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub any_ambiguous_type: AnyAmbiguousAliases,
    pub any_ambiguous: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vector_of_enums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Color>>>,
    pub signed_enum: Race,
    pub testrequirednestedflatbuffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub scalar_key_sorted_tables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Stat<'a>>>>>,
    pub native_inline: Option<&'a Test>,
    pub long_enum_non_enum_default: LongEnum,
    pub long_enum_normal_default: LongEnum,
    pub nan_default: f32,
    pub inf_default: f32,
    pub positive_inf_default: f32,
    pub infinity_default: f32,
    pub positive_infinity_default: f32,
    pub negative_inf_default: f32,
    pub negative_infinity_default: f32,
    pub double_inf_default: f64,
}
impl<'a> Default for MonsterArgs<'a> {
  #[inline]
  fn default() -> Self {
    MonsterArgs {
      pos: None,
      mana: 150,
      hp: 100,
      name: None, // required field
      inventory: None,
      color: Color::Blue,
      test_type: Any::NONE,
      test: None,
      test4: None,
      testarrayofstring: None,
      testarrayoftables: None,
      enemy: None,
      testnestedflatbuffer: None,
      testempty: None,
      testbool: false,
      testhashs32_fnv1: 0,
      testhashu32_fnv1: 0,
      testhashs64_fnv1: 0,
      testhashu64_fnv1: 0,
      testhashs32_fnv1a: 0,
      testhashu32_fnv1a: 0,
      testhashs64_fnv1a: 0,
      testhashu64_fnv1a: 0,
      testarrayofbools: None,
      testf: 3.14159,
      testf2: 3.0,
      testf3: 0.0,
      testarrayofstring2: None,
      testarrayofsortedstruct: None,
      flex: None,
      test5: None,
      vector_of_longs: None,
      vector_of_doubles: None,
      parent_namespace_test: None,
      vector_of_referrables: None,
      single_weak_reference: 0,
      vector_of_weak_references: None,
      vector_of_strong_referrables: None,
      co_owning_reference: 0,
      vector_of_co_owning_references: None,
      non_owning_reference: 0,
      vector_of_non_owning_references: None,
      any_unique_type: AnyUniqueAliases::NONE,
      any_unique: None,
      any_ambiguous_type: AnyAmbiguousAliases::NONE,
      any_ambiguous: None,
      vector_of_enums: None,
      signed_enum: Race::None,
      testrequirednestedflatbuffer: None,
      scalar_key_sorted_tables: None,
      native_inline: None,
      long_enum_non_enum_default: Default::default(),
      long_enum_normal_default: LongEnum::LongOne,
      nan_default: f32::NAN,
      inf_default: f32::INFINITY,
      positive_inf_default: f32::INFINITY,
      infinity_default: f32::INFINITY,
      positive_infinity_default: f32::INFINITY,
      negative_inf_default: f32::NEG_INFINITY,
      negative_infinity_default: f32::NEG_INFINITY,
      double_inf_default: f64::INFINITY,
    }
  }
}

impl Serialize for Monster<'_> {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let mut s = serializer.serialize_struct("Monster", 62)?;
      if let Some(f) = self.pos() {
        s.serialize_field("pos", &f)?;
      } else {
        s.skip_field("pos")?;
      }
      s.serialize_field("mana", &self.mana())?;
      s.serialize_field("hp", &self.hp())?;
      s.serialize_field("name", &self.name())?;
      if let Some(f) = self.inventory() {
        s.serialize_field("inventory", &f)?;
      } else {
        s.skip_field("inventory")?;
      }
      s.serialize_field("color", &self.color())?;
      s.serialize_field("test_type", &self.test_type())?;
      match self.test_type() {
        Any::NONE => (),
          Any::Monster => {
            let f = self.test_as_monster()
              .expect("Invalid union table, expected `Any::Monster`.");
            s.serialize_field("test", &f)?;
          }
          Any::TestSimpleTableWithEnum => {
            let f = self.test_as_test_simple_table_with_enum()
              .expect("Invalid union table, expected `Any::TestSimpleTableWithEnum`.");
            s.serialize_field("test", &f)?;
          }
          Any::MyGame_Example2_Monster => {
            let f = self.test_as_my_game_example_2_monster()
              .expect("Invalid union table, expected `Any::MyGame_Example2_Monster`.");
            s.serialize_field("test", &f)?;
          }
        _ => unimplemented!(),
      }
      if let Some(f) = self.test4() {
        s.serialize_field("test4", &f)?;
      } else {
        s.skip_field("test4")?;
      }
      if let Some(f) = self.testarrayofstring() {
        s.serialize_field("testarrayofstring", &f)?;
      } else {
        s.skip_field("testarrayofstring")?;
      }
      if let Some(f) = self.testarrayoftables() {
        s.serialize_field("testarrayoftables", &f)?;
      } else {
        s.skip_field("testarrayoftables")?;
      }
      if let Some(f) = self.enemy() {
        s.serialize_field("enemy", &f)?;
      } else {
        s.skip_field("enemy")?;
      }
      if let Some(f) = self.testnestedflatbuffer() {
        s.serialize_field("testnestedflatbuffer", &f)?;
      } else {
        s.skip_field("testnestedflatbuffer")?;
      }
      if let Some(f) = self.testempty() {
        s.serialize_field("testempty", &f)?;
      } else {
        s.skip_field("testempty")?;
      }
      s.serialize_field("testbool", &self.testbool())?;
      s.serialize_field("testhashs32_fnv1", &self.testhashs32_fnv1())?;
      s.serialize_field("testhashu32_fnv1", &self.testhashu32_fnv1())?;
      s.serialize_field("testhashs64_fnv1", &self.testhashs64_fnv1())?;
      s.serialize_field("testhashu64_fnv1", &self.testhashu64_fnv1())?;
      s.serialize_field("testhashs32_fnv1a", &self.testhashs32_fnv1a())?;
      s.serialize_field("testhashu32_fnv1a", &self.testhashu32_fnv1a())?;
      s.serialize_field("testhashs64_fnv1a", &self.testhashs64_fnv1a())?;
      s.serialize_field("testhashu64_fnv1a", &self.testhashu64_fnv1a())?;
      if let Some(f) = self.testarrayofbools() {
        s.serialize_field("testarrayofbools", &f)?;
      } else {
        s.skip_field("testarrayofbools")?;
      }
      s.serialize_field("testf", &self.testf())?;
      s.serialize_field("testf2", &self.testf2())?;
      s.serialize_field("testf3", &self.testf3())?;
      if let Some(f) = self.testarrayofstring2() {
        s.serialize_field("testarrayofstring2", &f)?;
      } else {
        s.skip_field("testarrayofstring2")?;
      }
      if let Some(f) = self.testarrayofsortedstruct() {
        s.serialize_field("testarrayofsortedstruct", &f)?;
      } else {
        s.skip_field("testarrayofsortedstruct")?;
      }
      if let Some(f) = self.flex() {
        s.serialize_field("flex", &f)?;
      } else {
        s.skip_field("flex")?;
      }
      if let Some(f) = self.test5() {
        s.serialize_field("test5", &f)?;
      } else {
        s.skip_field("test5")?;
      }
      if let Some(f) = self.vector_of_longs() {
        s.serialize_field("vector_of_longs", &f)?;
      } else {
        s.skip_field("vector_of_longs")?;
      }
      if let Some(f) = self.vector_of_doubles() {
        s.serialize_field("vector_of_doubles", &f)?;
      } else {
        s.skip_field("vector_of_doubles")?;
      }
      if let Some(f) = self.parent_namespace_test() {
        s.serialize_field("parent_namespace_test", &f)?;
      } else {
        s.skip_field("parent_namespace_test")?;
      }
      if let Some(f) = self.vector_of_referrables() {
        s.serialize_field("vector_of_referrables", &f)?;
      } else {
        s.skip_field("vector_of_referrables")?;
      }
      s.serialize_field("single_weak_reference", &self.single_weak_reference())?;
      if let Some(f) = self.vector_of_weak_references() {
        s.serialize_field("vector_of_weak_references", &f)?;
      } else {
        s.skip_field("vector_of_weak_references")?;
      }
      if let Some(f) = self.vector_of_strong_referrables() {
        s.serialize_field("vector_of_strong_referrables", &f)?;
      } else {
        s.skip_field("vector_of_strong_referrables")?;
      }
      s.serialize_field("co_owning_reference", &self.co_owning_reference())?;
      if let Some(f) = self.vector_of_co_owning_references() {
        s.serialize_field("vector_of_co_owning_references", &f)?;
      } else {
        s.skip_field("vector_of_co_owning_references")?;
      }
      s.serialize_field("non_owning_reference", &self.non_owning_reference())?;
      if let Some(f) = self.vector_of_non_owning_references() {
        s.serialize_field("vector_of_non_owning_references", &f)?;
      } else {
        s.skip_field("vector_of_non_owning_references")?;
      }
      s.serialize_field("any_unique_type", &self.any_unique_type())?;
      match self.any_unique_type() {
        AnyUniqueAliases::NONE => (),
          AnyUniqueAliases::M => {
            let f = self.any_unique_as_m()
              .expect("Invalid union table, expected `AnyUniqueAliases::M`.");
            s.serialize_field("any_unique", &f)?;
          }
          AnyUniqueAliases::TS => {
            let f = self.any_unique_as_ts()
              .expect("Invalid union table, expected `AnyUniqueAliases::TS`.");
            s.serialize_field("any_unique", &f)?;
          }
          AnyUniqueAliases::M2 => {
            let f = self.any_unique_as_m2()
              .expect("Invalid union table, expected `AnyUniqueAliases::M2`.");
            s.serialize_field("any_unique", &f)?;
          }
        _ => unimplemented!(),
      }
      s.serialize_field("any_ambiguous_type", &self.any_ambiguous_type())?;
      match self.any_ambiguous_type() {
        AnyAmbiguousAliases::NONE => (),
          AnyAmbiguousAliases::M1 => {
            let f = self.any_ambiguous_as_m1()
              .expect("Invalid union table, expected `AnyAmbiguousAliases::M1`.");
            s.serialize_field("any_ambiguous", &f)?;
          }
          AnyAmbiguousAliases::M2 => {
            let f = self.any_ambiguous_as_m2()
              .expect("Invalid union table, expected `AnyAmbiguousAliases::M2`.");
            s.serialize_field("any_ambiguous", &f)?;
          }
          AnyAmbiguousAliases::M3 => {
            let f = self.any_ambiguous_as_m3()
              .expect("Invalid union table, expected `AnyAmbiguousAliases::M3`.");
            s.serialize_field("any_ambiguous", &f)?;
          }
        _ => unimplemented!(),
      }
      if let Some(f) = self.vector_of_enums() {
        s.serialize_field("vector_of_enums", &f)?;
      } else {
        s.skip_field("vector_of_enums")?;
      }
      s.serialize_field("signed_enum", &self.signed_enum())?;
      if let Some(f) = self.testrequirednestedflatbuffer() {
        s.serialize_field("testrequirednestedflatbuffer", &f)?;
      } else {
        s.skip_field("testrequirednestedflatbuffer")?;
      }
      if let Some(f) = self.scalar_key_sorted_tables() {
        s.serialize_field("scalar_key_sorted_tables", &f)?;
      } else {
        s.skip_field("scalar_key_sorted_tables")?;
      }
      if let Some(f) = self.native_inline() {
        s.serialize_field("native_inline", &f)?;
      } else {
        s.skip_field("native_inline")?;
      }
      s.serialize_field("long_enum_non_enum_default", &self.long_enum_non_enum_default())?;
      s.serialize_field("long_enum_normal_default", &self.long_enum_normal_default())?;
      s.serialize_field("nan_default", &self.nan_default())?;
      s.serialize_field("inf_default", &self.inf_default())?;
      s.serialize_field("positive_inf_default", &self.positive_inf_default())?;
      s.serialize_field("infinity_default", &self.infinity_default())?;
      s.serialize_field("positive_infinity_default", &self.positive_infinity_default())?;
      s.serialize_field("negative_inf_default", &self.negative_inf_default())?;
      s.serialize_field("negative_infinity_default", &self.negative_infinity_default())?;
      s.serialize_field("double_inf_default", &self.double_inf_default())?;
    s.end()
  }
}

pub struct MonsterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MonsterBuilder<'a, 'b> {
  #[inline]
  pub fn add_pos(&mut self, pos: &Vec3) {
    self.fbb_.push_slot_always::<&Vec3>(Monster::VT_POS, pos);
  }
  #[inline]
  pub fn add_mana(&mut self, mana: i16) {
    self.fbb_.push_slot::<i16>(Monster::VT_MANA, mana, 150);
  }
  #[inline]
  pub fn add_hp(&mut self, hp: i16) {
    self.fbb_.push_slot::<i16>(Monster::VT_HP, hp, 100);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_NAME, name);
  }
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn add_color(&mut self, color: Color) {
    self.fbb_.push_slot::<Color>(Monster::VT_COLOR, color, Color::Blue);
  }
  #[inline]
  pub fn add_test_type(&mut self, test_type: Any) {
    self.fbb_.push_slot::<Any>(Monster::VT_TEST_TYPE, test_type, Any::NONE);
  }
  #[inline]
  pub fn add_test(&mut self, test: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST, test);
  }
  #[inline]
  pub fn add_test4(&mut self, test4: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Test>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST4, test4);
  }
  #[inline]
  pub fn add_testarrayofstring(&mut self, testarrayofstring: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSTRING, testarrayofstring);
  }
  #[inline]
  pub fn add_testarrayoftables(&mut self, testarrayoftables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Monster<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFTABLES, testarrayoftables);
  }
  #[inline]
  pub fn add_enemy(&mut self, enemy: flatbuffers::WIPOffset<Monster<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Monster>>(Monster::VT_ENEMY, enemy);
  }
  #[inline]
  pub fn add_testnestedflatbuffer(&mut self, testnestedflatbuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTNESTEDFLATBUFFER, testnestedflatbuffer);
  }
  #[inline]
  pub fn add_testempty(&mut self, testempty: flatbuffers::WIPOffset<Stat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Stat>>(Monster::VT_TESTEMPTY, testempty);
  }
  #[inline]
  pub fn add_testbool(&mut self, testbool: bool) {
    self.fbb_.push_slot::<bool>(Monster::VT_TESTBOOL, testbool, false);
  }
  #[inline]
  pub fn add_testhashs32_fnv1(&mut self, testhashs32_fnv1: i32) {
    self.fbb_.push_slot::<i32>(Monster::VT_TESTHASHS32_FNV1, testhashs32_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashu32_fnv1(&mut self, testhashu32_fnv1: u32) {
    self.fbb_.push_slot::<u32>(Monster::VT_TESTHASHU32_FNV1, testhashu32_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashs64_fnv1(&mut self, testhashs64_fnv1: i64) {
    self.fbb_.push_slot::<i64>(Monster::VT_TESTHASHS64_FNV1, testhashs64_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashu64_fnv1(&mut self, testhashu64_fnv1: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_TESTHASHU64_FNV1, testhashu64_fnv1, 0);
  }
  #[inline]
  pub fn add_testhashs32_fnv1a(&mut self, testhashs32_fnv1a: i32) {
    self.fbb_.push_slot::<i32>(Monster::VT_TESTHASHS32_FNV1A, testhashs32_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashu32_fnv1a(&mut self, testhashu32_fnv1a: u32) {
    self.fbb_.push_slot::<u32>(Monster::VT_TESTHASHU32_FNV1A, testhashu32_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashs64_fnv1a(&mut self, testhashs64_fnv1a: i64) {
    self.fbb_.push_slot::<i64>(Monster::VT_TESTHASHS64_FNV1A, testhashs64_fnv1a, 0);
  }
  #[inline]
  pub fn add_testhashu64_fnv1a(&mut self, testhashu64_fnv1a: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_TESTHASHU64_FNV1A, testhashu64_fnv1a, 0);
  }
  #[inline]
  pub fn add_testarrayofbools(&mut self, testarrayofbools: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFBOOLS, testarrayofbools);
  }
  #[inline]
  pub fn add_testf(&mut self, testf: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF, testf, 3.14159);
  }
  #[inline]
  pub fn add_testf2(&mut self, testf2: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF2, testf2, 3.0);
  }
  #[inline]
  pub fn add_testf3(&mut self, testf3: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_TESTF3, testf3, 0.0);
  }
  #[inline]
  pub fn add_testarrayofstring2(&mut self, testarrayofstring2: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSTRING2, testarrayofstring2);
  }
  #[inline]
  pub fn add_testarrayofsortedstruct(&mut self, testarrayofsortedstruct: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Ability>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTARRAYOFSORTEDSTRUCT, testarrayofsortedstruct);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_FLEX, flex);
  }
  #[inline]
  pub fn add_test5(&mut self, test5: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Test>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TEST5, test5);
  }
  #[inline]
  pub fn add_vector_of_longs(&mut self, vector_of_longs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_LONGS, vector_of_longs);
  }
  #[inline]
  pub fn add_vector_of_doubles(&mut self, vector_of_doubles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_DOUBLES, vector_of_doubles);
  }
  #[inline]
  pub fn add_parent_namespace_test(&mut self, parent_namespace_test: flatbuffers::WIPOffset<super::InParentNamespace<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::InParentNamespace>>(Monster::VT_PARENT_NAMESPACE_TEST, parent_namespace_test);
  }
  #[inline]
  pub fn add_vector_of_referrables(&mut self, vector_of_referrables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Referrable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_REFERRABLES, vector_of_referrables);
  }
  #[inline]
  pub fn add_single_weak_reference(&mut self, single_weak_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_SINGLE_WEAK_REFERENCE, single_weak_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_weak_references(&mut self, vector_of_weak_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_WEAK_REFERENCES, vector_of_weak_references);
  }
  #[inline]
  pub fn add_vector_of_strong_referrables(&mut self, vector_of_strong_referrables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Referrable<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_STRONG_REFERRABLES, vector_of_strong_referrables);
  }
  #[inline]
  pub fn add_co_owning_reference(&mut self, co_owning_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_CO_OWNING_REFERENCE, co_owning_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_co_owning_references(&mut self, vector_of_co_owning_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_CO_OWNING_REFERENCES, vector_of_co_owning_references);
  }
  #[inline]
  pub fn add_non_owning_reference(&mut self, non_owning_reference: u64) {
    self.fbb_.push_slot::<u64>(Monster::VT_NON_OWNING_REFERENCE, non_owning_reference, 0);
  }
  #[inline]
  pub fn add_vector_of_non_owning_references(&mut self, vector_of_non_owning_references: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_NON_OWNING_REFERENCES, vector_of_non_owning_references);
  }
  #[inline]
  pub fn add_any_unique_type(&mut self, any_unique_type: AnyUniqueAliases) {
    self.fbb_.push_slot::<AnyUniqueAliases>(Monster::VT_ANY_UNIQUE_TYPE, any_unique_type, AnyUniqueAliases::NONE);
  }
  #[inline]
  pub fn add_any_unique(&mut self, any_unique: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_ANY_UNIQUE, any_unique);
  }
  #[inline]
  pub fn add_any_ambiguous_type(&mut self, any_ambiguous_type: AnyAmbiguousAliases) {
    self.fbb_.push_slot::<AnyAmbiguousAliases>(Monster::VT_ANY_AMBIGUOUS_TYPE, any_ambiguous_type, AnyAmbiguousAliases::NONE);
  }
  #[inline]
  pub fn add_any_ambiguous(&mut self, any_ambiguous: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_ANY_AMBIGUOUS, any_ambiguous);
  }
  #[inline]
  pub fn add_vector_of_enums(&mut self, vector_of_enums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Color>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_VECTOR_OF_ENUMS, vector_of_enums);
  }
  #[inline]
  pub fn add_signed_enum(&mut self, signed_enum: Race) {
    self.fbb_.push_slot::<Race>(Monster::VT_SIGNED_ENUM, signed_enum, Race::None);
  }
  #[inline]
  pub fn add_testrequirednestedflatbuffer(&mut self, testrequirednestedflatbuffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_TESTREQUIREDNESTEDFLATBUFFER, testrequirednestedflatbuffer);
  }
  #[inline]
  pub fn add_scalar_key_sorted_tables(&mut self, scalar_key_sorted_tables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Stat<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_SCALAR_KEY_SORTED_TABLES, scalar_key_sorted_tables);
  }
  #[inline]
  pub fn add_native_inline(&mut self, native_inline: &Test) {
    self.fbb_.push_slot_always::<&Test>(Monster::VT_NATIVE_INLINE, native_inline);
  }
  #[inline]
  pub fn add_long_enum_non_enum_default(&mut self, long_enum_non_enum_default: LongEnum) {
    self.fbb_.push_slot::<LongEnum>(Monster::VT_LONG_ENUM_NON_ENUM_DEFAULT, long_enum_non_enum_default, Default::default());
  }
  #[inline]
  pub fn add_long_enum_normal_default(&mut self, long_enum_normal_default: LongEnum) {
    self.fbb_.push_slot::<LongEnum>(Monster::VT_LONG_ENUM_NORMAL_DEFAULT, long_enum_normal_default, LongEnum::LongOne);
  }
  #[inline]
  pub fn add_nan_default(&mut self, nan_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_NAN_DEFAULT, nan_default, f32::NAN);
  }
  #[inline]
  pub fn add_inf_default(&mut self, inf_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_INF_DEFAULT, inf_default, f32::INFINITY);
  }
  #[inline]
  pub fn add_positive_inf_default(&mut self, positive_inf_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_POSITIVE_INF_DEFAULT, positive_inf_default, f32::INFINITY);
  }
  #[inline]
  pub fn add_infinity_default(&mut self, infinity_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_INFINITY_DEFAULT, infinity_default, f32::INFINITY);
  }
  #[inline]
  pub fn add_positive_infinity_default(&mut self, positive_infinity_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_POSITIVE_INFINITY_DEFAULT, positive_infinity_default, f32::INFINITY);
  }
  #[inline]
  pub fn add_negative_inf_default(&mut self, negative_inf_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_NEGATIVE_INF_DEFAULT, negative_inf_default, f32::NEG_INFINITY);
  }
  #[inline]
  pub fn add_negative_infinity_default(&mut self, negative_infinity_default: f32) {
    self.fbb_.push_slot::<f32>(Monster::VT_NEGATIVE_INFINITY_DEFAULT, negative_infinity_default, f32::NEG_INFINITY);
  }
  #[inline]
  pub fn add_double_inf_default(&mut self, double_inf_default: f64) {
    self.fbb_.push_slot::<f64>(Monster::VT_DOUBLE_INF_DEFAULT, double_inf_default, f64::INFINITY);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonsterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MonsterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Monster<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Monster::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Monster<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Monster");
      ds.field("pos", &self.pos());
      ds.field("mana", &self.mana());
      ds.field("hp", &self.hp());
      ds.field("name", &self.name());
      ds.field("inventory", &self.inventory());
      ds.field("color", &self.color());
      ds.field("test_type", &self.test_type());
      match self.test_type() {
        Any::Monster => {
          if let Some(x) = self.test_as_monster() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Any::TestSimpleTableWithEnum => {
          if let Some(x) = self.test_as_test_simple_table_with_enum() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Any::MyGame_Example2_Monster => {
          if let Some(x) = self.test_as_my_game_example_2_monster() {
            ds.field("test", &x)
          } else {
            ds.field("test", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("test", &x)
        },
      };
      ds.field("test4", &self.test4());
      ds.field("testarrayofstring", &self.testarrayofstring());
      ds.field("testarrayoftables", &self.testarrayoftables());
      ds.field("enemy", &self.enemy());
      ds.field("testnestedflatbuffer", &self.testnestedflatbuffer());
      ds.field("testempty", &self.testempty());
      ds.field("testbool", &self.testbool());
      ds.field("testhashs32_fnv1", &self.testhashs32_fnv1());
      ds.field("testhashu32_fnv1", &self.testhashu32_fnv1());
      ds.field("testhashs64_fnv1", &self.testhashs64_fnv1());
      ds.field("testhashu64_fnv1", &self.testhashu64_fnv1());
      ds.field("testhashs32_fnv1a", &self.testhashs32_fnv1a());
      ds.field("testhashu32_fnv1a", &self.testhashu32_fnv1a());
      ds.field("testhashs64_fnv1a", &self.testhashs64_fnv1a());
      ds.field("testhashu64_fnv1a", &self.testhashu64_fnv1a());
      ds.field("testarrayofbools", &self.testarrayofbools());
      ds.field("testf", &self.testf());
      ds.field("testf2", &self.testf2());
      ds.field("testf3", &self.testf3());
      ds.field("testarrayofstring2", &self.testarrayofstring2());
      ds.field("testarrayofsortedstruct", &self.testarrayofsortedstruct());
      ds.field("flex", &self.flex());
      ds.field("test5", &self.test5());
      ds.field("vector_of_longs", &self.vector_of_longs());
      ds.field("vector_of_doubles", &self.vector_of_doubles());
      ds.field("parent_namespace_test", &self.parent_namespace_test());
      ds.field("vector_of_referrables", &self.vector_of_referrables());
      ds.field("single_weak_reference", &self.single_weak_reference());
      ds.field("vector_of_weak_references", &self.vector_of_weak_references());
      ds.field("vector_of_strong_referrables", &self.vector_of_strong_referrables());
      ds.field("co_owning_reference", &self.co_owning_reference());
      ds.field("vector_of_co_owning_references", &self.vector_of_co_owning_references());
      ds.field("non_owning_reference", &self.non_owning_reference());
      ds.field("vector_of_non_owning_references", &self.vector_of_non_owning_references());
      ds.field("any_unique_type", &self.any_unique_type());
      match self.any_unique_type() {
        AnyUniqueAliases::M => {
          if let Some(x) = self.any_unique_as_m() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyUniqueAliases::TS => {
          if let Some(x) = self.any_unique_as_ts() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyUniqueAliases::M2 => {
          if let Some(x) = self.any_unique_as_m2() {
            ds.field("any_unique", &x)
          } else {
            ds.field("any_unique", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_unique", &x)
        },
      };
      ds.field("any_ambiguous_type", &self.any_ambiguous_type());
      match self.any_ambiguous_type() {
        AnyAmbiguousAliases::M1 => {
          if let Some(x) = self.any_ambiguous_as_m1() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyAmbiguousAliases::M2 => {
          if let Some(x) = self.any_ambiguous_as_m2() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyAmbiguousAliases::M3 => {
          if let Some(x) = self.any_ambiguous_as_m3() {
            ds.field("any_ambiguous", &x)
          } else {
            ds.field("any_ambiguous", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_ambiguous", &x)
        },
      };
      ds.field("vector_of_enums", &self.vector_of_enums());
      ds.field("signed_enum", &self.signed_enum());
      ds.field("testrequirednestedflatbuffer", &self.testrequirednestedflatbuffer());
      ds.field("scalar_key_sorted_tables", &self.scalar_key_sorted_tables());
      ds.field("native_inline", &self.native_inline());
      ds.field("long_enum_non_enum_default", &self.long_enum_non_enum_default());
      ds.field("long_enum_normal_default", &self.long_enum_normal_default());
      ds.field("nan_default", &self.nan_default());
      ds.field("inf_default", &self.inf_default());
      ds.field("positive_inf_default", &self.positive_inf_default());
      ds.field("infinity_default", &self.infinity_default());
      ds.field("positive_infinity_default", &self.positive_infinity_default());
      ds.field("negative_inf_default", &self.negative_inf_default());
      ds.field("negative_infinity_default", &self.negative_infinity_default());
      ds.field("double_inf_default", &self.double_inf_default());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MonsterT {
  pub pos: Option<Vec3T>,
  pub mana: i16,
  pub hp: i16,
  pub name: String,
  pub inventory: Option<Vec<u8>>,
  pub color: Color,
  pub test: AnyT,
  pub test4: Option<Vec<TestT>>,
  pub testarrayofstring: Option<Vec<String>>,
  pub testarrayoftables: Option<Vec<MonsterT>>,
  pub enemy: Option<Box<MonsterT>>,
  pub testnestedflatbuffer: Option<Vec<u8>>,
  pub testempty: Option<Box<StatT>>,
  pub testbool: bool,
  pub testhashs32_fnv1: i32,
  pub testhashu32_fnv1: u32,
  pub testhashs64_fnv1: i64,
  pub testhashu64_fnv1: u64,
  pub testhashs32_fnv1a: i32,
  pub testhashu32_fnv1a: u32,
  pub testhashs64_fnv1a: i64,
  pub testhashu64_fnv1a: u64,
  pub testarrayofbools: Option<Vec<bool>>,
  pub testf: f32,
  pub testf2: f32,
  pub testf3: f32,
  pub testarrayofstring2: Option<Vec<String>>,
  pub testarrayofsortedstruct: Option<Vec<AbilityT>>,
  pub flex: Option<Vec<u8>>,
  pub test5: Option<Vec<TestT>>,
  pub vector_of_longs: Option<Vec<i64>>,
  pub vector_of_doubles: Option<Vec<f64>>,
  pub parent_namespace_test: Option<Box<super::InParentNamespaceT>>,
  pub vector_of_referrables: Option<Vec<ReferrableT>>,
  pub single_weak_reference: u64,
  pub vector_of_weak_references: Option<Vec<u64>>,
  pub vector_of_strong_referrables: Option<Vec<ReferrableT>>,
  pub co_owning_reference: u64,
  pub vector_of_co_owning_references: Option<Vec<u64>>,
  pub non_owning_reference: u64,
  pub vector_of_non_owning_references: Option<Vec<u64>>,
  pub any_unique: AnyUniqueAliasesT,
  pub any_ambiguous: AnyAmbiguousAliasesT,
  pub vector_of_enums: Option<Vec<Color>>,
  pub signed_enum: Race,
  pub testrequirednestedflatbuffer: Option<Vec<u8>>,
  pub scalar_key_sorted_tables: Option<Vec<StatT>>,
  pub native_inline: Option<TestT>,
  pub long_enum_non_enum_default: LongEnum,
  pub long_enum_normal_default: LongEnum,
  pub nan_default: f32,
  pub inf_default: f32,
  pub positive_inf_default: f32,
  pub infinity_default: f32,
  pub positive_infinity_default: f32,
  pub negative_inf_default: f32,
  pub negative_infinity_default: f32,
  pub double_inf_default: f64,
}
impl Default for MonsterT {
  fn default() -> Self {
    Self {
      pos: None,
      mana: 150,
      hp: 100,
      name: "".to_string(),
      inventory: None,
      color: Color::Blue,
      test: AnyT::NONE,
      test4: None,
      testarrayofstring: None,
      testarrayoftables: None,
      enemy: None,
      testnestedflatbuffer: None,
      testempty: None,
      testbool: false,
      testhashs32_fnv1: 0,
      testhashu32_fnv1: 0,
      testhashs64_fnv1: 0,
      testhashu64_fnv1: 0,
      testhashs32_fnv1a: 0,
      testhashu32_fnv1a: 0,
      testhashs64_fnv1a: 0,
      testhashu64_fnv1a: 0,
      testarrayofbools: None,
      testf: 3.14159,
      testf2: 3.0,
      testf3: 0.0,
      testarrayofstring2: None,
      testarrayofsortedstruct: None,
      flex: None,
      test5: None,
      vector_of_longs: None,
      vector_of_doubles: None,
      parent_namespace_test: None,
      vector_of_referrables: None,
      single_weak_reference: 0,
      vector_of_weak_references: None,
      vector_of_strong_referrables: None,
      co_owning_reference: 0,
      vector_of_co_owning_references: None,
      non_owning_reference: 0,
      vector_of_non_owning_references: None,
      any_unique: AnyUniqueAliasesT::NONE,
      any_ambiguous: AnyAmbiguousAliasesT::NONE,
      vector_of_enums: None,
      signed_enum: Race::None,
      testrequirednestedflatbuffer: None,
      scalar_key_sorted_tables: None,
      native_inline: None,
      long_enum_non_enum_default: Default::default(),
      long_enum_normal_default: LongEnum::LongOne,
      nan_default: f32::NAN,
      inf_default: f32::INFINITY,
      positive_inf_default: f32::INFINITY,
      infinity_default: f32::INFINITY,
      positive_infinity_default: f32::INFINITY,
      negative_inf_default: f32::NEG_INFINITY,
      negative_infinity_default: f32::NEG_INFINITY,
      double_inf_default: f64::INFINITY,
    }
  }
}
impl MonsterT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Monster<'b>> {
    let pos_tmp = self.pos.as_ref().map(|x| x.pack());
    let pos = pos_tmp.as_ref();
    let mana = self.mana;
    let hp = self.hp;
    let name = Some({
      let x = &self.name;
      _fbb.create_string(x)
    });
    let inventory = self.inventory.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let color = self.color;
    let test_type = self.test.any_type();
    let test = self.test.pack(_fbb);
    let test4 = self.test4.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let testarrayofstring = self.testarrayofstring.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let testarrayoftables = self.testarrayoftables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let enemy = self.enemy.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let testnestedflatbuffer = self.testnestedflatbuffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let testempty = self.testempty.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let testbool = self.testbool;
    let testhashs32_fnv1 = self.testhashs32_fnv1;
    let testhashu32_fnv1 = self.testhashu32_fnv1;
    let testhashs64_fnv1 = self.testhashs64_fnv1;
    let testhashu64_fnv1 = self.testhashu64_fnv1;
    let testhashs32_fnv1a = self.testhashs32_fnv1a;
    let testhashu32_fnv1a = self.testhashu32_fnv1a;
    let testhashs64_fnv1a = self.testhashs64_fnv1a;
    let testhashu64_fnv1a = self.testhashu64_fnv1a;
    let testarrayofbools = self.testarrayofbools.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let testf = self.testf;
    let testf2 = self.testf2;
    let testf3 = self.testf3;
    let testarrayofstring2 = self.testarrayofstring2.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let testarrayofsortedstruct = self.testarrayofsortedstruct.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let test5 = self.test5.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
    });
    let vector_of_longs = self.vector_of_longs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vector_of_doubles = self.vector_of_doubles.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let parent_namespace_test = self.parent_namespace_test.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let vector_of_referrables = self.vector_of_referrables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let single_weak_reference = self.single_weak_reference;
    let vector_of_weak_references = self.vector_of_weak_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let vector_of_strong_referrables = self.vector_of_strong_referrables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let co_owning_reference = self.co_owning_reference;
    let vector_of_co_owning_references = self.vector_of_co_owning_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let non_owning_reference = self.non_owning_reference;
    let vector_of_non_owning_references = self.vector_of_non_owning_references.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let any_unique_type = self.any_unique.any_unique_aliases_type();
    let any_unique = self.any_unique.pack(_fbb);
    let any_ambiguous_type = self.any_ambiguous.any_ambiguous_aliases_type();
    let any_ambiguous = self.any_ambiguous.pack(_fbb);
    let vector_of_enums = self.vector_of_enums.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let signed_enum = self.signed_enum;
    let testrequirednestedflatbuffer = self.testrequirednestedflatbuffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let scalar_key_sorted_tables = self.scalar_key_sorted_tables.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let native_inline_tmp = self.native_inline.as_ref().map(|x| x.pack());
    let native_inline = native_inline_tmp.as_ref();
    let long_enum_non_enum_default = self.long_enum_non_enum_default;
    let long_enum_normal_default = self.long_enum_normal_default;
    let nan_default = self.nan_default;
    let inf_default = self.inf_default;
    let positive_inf_default = self.positive_inf_default;
    let infinity_default = self.infinity_default;
    let positive_infinity_default = self.positive_infinity_default;
    let negative_inf_default = self.negative_inf_default;
    let negative_infinity_default = self.negative_infinity_default;
    let double_inf_default = self.double_inf_default;
    Monster::create(_fbb, &MonsterArgs{
      pos,
      mana,
      hp,
      name,
      inventory,
      color,
      test_type,
      test,
      test4,
      testarrayofstring,
      testarrayoftables,
      enemy,
      testnestedflatbuffer,
      testempty,
      testbool,
      testhashs32_fnv1,
      testhashu32_fnv1,
      testhashs64_fnv1,
      testhashu64_fnv1,
      testhashs32_fnv1a,
      testhashu32_fnv1a,
      testhashs64_fnv1a,
      testhashu64_fnv1a,
      testarrayofbools,
      testf,
      testf2,
      testf3,
      testarrayofstring2,
      testarrayofsortedstruct,
      flex,
      test5,
      vector_of_longs,
      vector_of_doubles,
      parent_namespace_test,
      vector_of_referrables,
      single_weak_reference,
      vector_of_weak_references,
      vector_of_strong_referrables,
      co_owning_reference,
      vector_of_co_owning_references,
      non_owning_reference,
      vector_of_non_owning_references,
      any_unique_type,
      any_unique,
      any_ambiguous_type,
      any_ambiguous,
      vector_of_enums,
      signed_enum,
      testrequirednestedflatbuffer,
      scalar_key_sorted_tables,
      native_inline,
      long_enum_non_enum_default,
      long_enum_normal_default,
      nan_default,
      inf_default,
      positive_inf_default,
      infinity_default,
      positive_infinity_default,
      negative_inf_default,
      negative_infinity_default,
      double_inf_default,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Monster`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Monster>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Monster` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_monster_unchecked`.
pub fn size_prefixed_root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Monster>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Monster` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn root_as_monster_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Monster<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Monster` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_monster_unchecked`.
pub fn size_prefixed_root_as_monster_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Monster<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Monster and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Monster`.
pub unsafe fn root_as_monster_unchecked(buf: &[u8]) -> Monster {
  flatbuffers::root_unchecked::<Monster>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Monster and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Monster`.
pub unsafe fn size_prefixed_root_as_monster_unchecked(buf: &[u8]) -> Monster {
  flatbuffers::size_prefixed_root_unchecked::<Monster>(buf)
}
pub const MONSTER_IDENTIFIER: &str = "MONS";

#[inline]
pub fn monster_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MONSTER_IDENTIFIER, false)
}

#[inline]
pub fn monster_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MONSTER_IDENTIFIER, true)
}

pub const MONSTER_EXTENSION: &str = "mon";

#[inline]
pub fn finish_monster_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Monster<'a>>) {
  fbb.finish(root, Some(MONSTER_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_monster_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Monster<'a>>) {
  fbb.finish_size_prefixed(root, Some(MONSTER_IDENTIFIER));
}

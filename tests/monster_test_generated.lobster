// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

namespace MyGame.Example

/// Composite components of Monster color.
enum Color:
    Color_Red = 1
    /// \brief color Green
    /// Green is bit_flag with value (1u << 1)
    Color_Green = 2
    /// \brief color Blue (1u << 3)
    Color_Blue = 8

enum Race:
    Race_None = -1
    Race_Human = 0
    Race_Dwarf = 1
    Race_Elf = 2

enum LongEnum:
    LongEnum_LongOne = 2
    LongEnum_LongTwo = 4
    LongEnum_LongBig = 1099511627776

enum Any:
    Any_NONE = 0
    Any_Monster = 1
    Any_TestSimpleTableWithEnum = 2
    Any_MyGame_Example2_Monster = 3

enum AnyUniqueAliases:
    AnyUniqueAliases_NONE = 0
    AnyUniqueAliases_M = 1
    AnyUniqueAliases_TS = 2
    AnyUniqueAliases_M2 = 3

enum AnyAmbiguousAliases:
    AnyAmbiguousAliases_NONE = 0
    AnyAmbiguousAliases_M1 = 1
    AnyAmbiguousAliases_M2 = 2
    AnyAmbiguousAliases_M3 = 3

namespace MyGame

class InParentNamespace

namespace MyGame.Example2

class Monster

namespace MyGame.Example

class Test

class TestSimpleTableWithEnum

class Vec3

class Ability

class StructOfStructs

class StructOfStructsOfStructs

class Stat

class Referrable

class Monster

class TypeAliases

namespace MyGame

class InParentNamespace : flatbuffers.handle

def GetRootAsInParentNamespace(buf:string): return InParentNamespace { buf, flatbuffers.indirect(buf, 0) }

struct InParentNamespaceBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(0)
        return this
    def end():
        return b_.EndObject()

namespace MyGame.Example2

class Monster : flatbuffers.handle

def GetRootAsMonster(buf:string): return Monster { buf, flatbuffers.indirect(buf, 0) }

struct MonsterBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(0)
        return this
    def end():
        return b_.EndObject()

namespace MyGame.Example

class Test : flatbuffers.handle
    def a() -> int:
        return buf_.read_int16_le(pos_ + 0)
    def b() -> int:
        return buf_.read_int8_le(pos_ + 2)

def CreateTest(b_:flatbuffers.builder, a:int, b:int):
    b_.Prep(2, 4)
    b_.Pad(1)
    b_.PrependInt8(b)
    b_.PrependInt16(a)
    return b_.Offset()

class TestSimpleTableWithEnum : flatbuffers.handle
    def color() -> Color:
        return Color(flatbuffers.field_uint8(buf_, pos_, 4, 2))

def GetRootAsTestSimpleTableWithEnum(buf:string): return TestSimpleTableWithEnum { buf, flatbuffers.indirect(buf, 0) }

struct TestSimpleTableWithEnumBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_color(color:Color):
        b_.PrependUint8Slot(0, color, 2)
        return this
    def end():
        return b_.EndObject()

class Vec3 : flatbuffers.handle
    def x() -> float:
        return buf_.read_float32_le(pos_ + 0)
    def y() -> float:
        return buf_.read_float32_le(pos_ + 4)
    def z() -> float:
        return buf_.read_float32_le(pos_ + 8)
    def test1() -> float:
        return buf_.read_float64_le(pos_ + 16)
    def test2() -> Color:
        return Color(buf_.read_uint8_le(pos_ + 24))
    def test3() -> MyGame.Example.Test:
        return MyGame.Example.Test{ buf_, pos_ + 26 }

def CreateVec3(b_:flatbuffers.builder, x:float, y:float, z:float, test1:float, test2:Color, test3_a:int, test3_b:int):
    b_.Prep(8, 32)
    b_.Pad(2)
    b_.Prep(2, 4)
    b_.Pad(1)
    b_.PrependInt8(test3_b)
    b_.PrependInt16(test3_a)
    b_.Pad(1)
    b_.PrependUint8(test2)
    b_.PrependFloat64(test1)
    b_.Pad(4)
    b_.PrependFloat32(z)
    b_.PrependFloat32(y)
    b_.PrependFloat32(x)
    return b_.Offset()

class Ability : flatbuffers.handle
    def id() -> int:
        return buf_.read_uint32_le(pos_ + 0)
    def distance() -> int:
        return buf_.read_uint32_le(pos_ + 4)

def CreateAbility(b_:flatbuffers.builder, id:int, distance:int):
    b_.Prep(4, 8)
    b_.PrependUint32(distance)
    b_.PrependUint32(id)
    return b_.Offset()

class StructOfStructs : flatbuffers.handle
    def a() -> MyGame.Example.Ability:
        return MyGame.Example.Ability{ buf_, pos_ + 0 }
    def b() -> MyGame.Example.Test:
        return MyGame.Example.Test{ buf_, pos_ + 8 }
    def c() -> MyGame.Example.Ability:
        return MyGame.Example.Ability{ buf_, pos_ + 12 }

def CreateStructOfStructs(b_:flatbuffers.builder, a_id:int, a_distance:int, b_a:int, b_b:int, c_id:int, c_distance:int):
    b_.Prep(4, 20)
    b_.Prep(4, 8)
    b_.PrependUint32(c_distance)
    b_.PrependUint32(c_id)
    b_.Prep(2, 4)
    b_.Pad(1)
    b_.PrependInt8(b_b)
    b_.PrependInt16(b_a)
    b_.Prep(4, 8)
    b_.PrependUint32(a_distance)
    b_.PrependUint32(a_id)
    return b_.Offset()

class StructOfStructsOfStructs : flatbuffers.handle
    def a() -> MyGame.Example.StructOfStructs:
        return MyGame.Example.StructOfStructs{ buf_, pos_ + 0 }

def CreateStructOfStructsOfStructs(b_:flatbuffers.builder, a_a_id:int, a_a_distance:int, a_b_a:int, a_b_b:int, a_c_id:int, a_c_distance:int):
    b_.Prep(4, 20)
    b_.Prep(4, 20)
    b_.Prep(4, 8)
    b_.PrependUint32(a_c_distance)
    b_.PrependUint32(a_c_id)
    b_.Prep(2, 4)
    b_.Pad(1)
    b_.PrependInt8(a_b_b)
    b_.PrependInt16(a_b_a)
    b_.Prep(4, 8)
    b_.PrependUint32(a_a_distance)
    b_.PrependUint32(a_a_id)
    return b_.Offset()

class Stat : flatbuffers.handle
    def id() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def val() -> int:
        return flatbuffers.field_int64(buf_, pos_, 6, 0)
    def count() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 8, 0)

def GetRootAsStat(buf:string): return Stat { buf, flatbuffers.indirect(buf, 0) }

struct StatBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_id(id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, id)
        return this
    def add_val(val:int):
        b_.PrependInt64Slot(1, val, 0)
        return this
    def add_count(count:int):
        b_.PrependUint16Slot(2, count, 0)
        return this
    def end():
        return b_.EndObject()

class Referrable : flatbuffers.handle
    def id() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 4, 0)

def GetRootAsReferrable(buf:string): return Referrable { buf, flatbuffers.indirect(buf, 0) }

struct ReferrableBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_id(id:int):
        b_.PrependUint64Slot(0, id, 0)
        return this
    def end():
        return b_.EndObject()

/// an example documentation comment: "monster object"
class Monster : flatbuffers.handle
    def pos() -> MyGame.Example.Vec3?:
        let o = flatbuffers.field_struct(buf_, pos_, 4)
        return if o: MyGame.Example.Vec3 { buf_, o } else: nil
    def mana() -> int:
        return flatbuffers.field_int16(buf_, pos_, 6, 150)
    def hp() -> int:
        return flatbuffers.field_int16(buf_, pos_, 8, 100)
    def name() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    def inventory(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 1)
    def inventory_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    def color() -> Color:
        return Color(flatbuffers.field_uint8(buf_, pos_, 16, 8))
    def test_type() -> Any:
        return Any(flatbuffers.field_uint8(buf_, pos_, 18, 0))
    def test_as_Monster():
        return MyGame.Example.Monster { buf_, flatbuffers.field_table(buf_, pos_, 20) }
    def test_as_TestSimpleTableWithEnum():
        return MyGame.Example.TestSimpleTableWithEnum { buf_, flatbuffers.field_table(buf_, pos_, 20) }
    def test_as_MyGame_Example2_Monster():
        return MyGame.Example2.Monster { buf_, flatbuffers.field_table(buf_, pos_, 20) }
    def test4(i:int) -> MyGame.Example.Test:
        return MyGame.Example.Test { buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4 }
    def test4_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)
    def testarrayofstring(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 24) + i * 4)
    def testarrayofstring_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// an example documentation comment: this will end up in the generated code
    /// multiline too
    def testarrayoftables(i:int) -> MyGame.Example.Monster:
        return MyGame.Example.Monster { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 26) + i * 4) }
    def testarrayoftables_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)
    def enemy() -> MyGame.Example.Monster?:
        let o = flatbuffers.field_table(buf_, pos_, 28)
        return if o: MyGame.Example.Monster { buf_, o } else: nil
    def testnestedflatbuffer(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 30) + i * 1)
    def testnestedflatbuffer_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 30)
    def testempty() -> MyGame.Example.Stat?:
        let o = flatbuffers.field_table(buf_, pos_, 32)
        return if o: MyGame.Example.Stat { buf_, o } else: nil
    def testbool() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 34, 0))
    def testhashs32_fnv1() -> int:
        return flatbuffers.field_int32(buf_, pos_, 36, 0)
    def testhashu32_fnv1() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 38, 0)
    def testhashs64_fnv1() -> int:
        return flatbuffers.field_int64(buf_, pos_, 40, 0)
    def testhashu64_fnv1() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 42, 0)
    def testhashs32_fnv1a() -> int:
        return flatbuffers.field_int32(buf_, pos_, 44, 0)
    def testhashu32_fnv1a() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 46, 0)
    def testhashs64_fnv1a() -> int:
        return flatbuffers.field_int64(buf_, pos_, 48, 0)
    def testhashu64_fnv1a() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 50, 0)
    def testarrayofbools(i:int) -> bool:
        return read_int8_le(buf_, buf_.flatbuffers.field_vector(pos_, 52) + i * 1)
    def testarrayofbools_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 52)
    def testf() -> float:
        return flatbuffers.field_float32(buf_, pos_, 54, 3.14159)
    def testf2() -> float:
        return flatbuffers.field_float32(buf_, pos_, 56, 3.0)
    def testf3() -> float:
        return flatbuffers.field_float32(buf_, pos_, 58, 0.0)
    def testarrayofstring2(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 60) + i * 4)
    def testarrayofstring2_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 60)
    def testarrayofsortedstruct(i:int) -> MyGame.Example.Ability:
        return MyGame.Example.Ability { buf_, flatbuffers.field_vector(buf_, pos_, 62) + i * 8 }
    def testarrayofsortedstruct_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 62)
    def flex(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 64) + i * 1)
    def flex_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 64)
    def test5(i:int) -> MyGame.Example.Test:
        return MyGame.Example.Test { buf_, flatbuffers.field_vector(buf_, pos_, 66) + i * 4 }
    def test5_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 66)
    def vector_of_longs(i:int) -> int:
        return read_int64_le(buf_, buf_.flatbuffers.field_vector(pos_, 68) + i * 8)
    def vector_of_longs_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 68)
    def vector_of_doubles(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 70) + i * 8)
    def vector_of_doubles_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 70)
    def parent_namespace_test() -> MyGame.InParentNamespace?:
        let o = flatbuffers.field_table(buf_, pos_, 72)
        return if o: MyGame.InParentNamespace { buf_, o } else: nil
    def vector_of_referrables(i:int) -> MyGame.Example.Referrable:
        return MyGame.Example.Referrable { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 74) + i * 4) }
    def vector_of_referrables_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 74)
    def single_weak_reference() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 76, 0)
    def vector_of_weak_references(i:int) -> int:
        return read_uint64_le(buf_, buf_.flatbuffers.field_vector(pos_, 78) + i * 8)
    def vector_of_weak_references_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 78)
    def vector_of_strong_referrables(i:int) -> MyGame.Example.Referrable:
        return MyGame.Example.Referrable { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 80) + i * 4) }
    def vector_of_strong_referrables_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 80)
    def co_owning_reference() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 82, 0)
    def vector_of_co_owning_references(i:int) -> int:
        return read_uint64_le(buf_, buf_.flatbuffers.field_vector(pos_, 84) + i * 8)
    def vector_of_co_owning_references_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 84)
    def non_owning_reference() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 86, 0)
    def vector_of_non_owning_references(i:int) -> int:
        return read_uint64_le(buf_, buf_.flatbuffers.field_vector(pos_, 88) + i * 8)
    def vector_of_non_owning_references_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 88)
    def any_unique_type() -> AnyUniqueAliases:
        return AnyUniqueAliases(flatbuffers.field_uint8(buf_, pos_, 90, 0))
    def any_unique_as_M():
        return MyGame.Example.Monster { buf_, flatbuffers.field_table(buf_, pos_, 92) }
    def any_unique_as_TS():
        return MyGame.Example.TestSimpleTableWithEnum { buf_, flatbuffers.field_table(buf_, pos_, 92) }
    def any_unique_as_M2():
        return MyGame.Example2.Monster { buf_, flatbuffers.field_table(buf_, pos_, 92) }
    def any_ambiguous_type() -> AnyAmbiguousAliases:
        return AnyAmbiguousAliases(flatbuffers.field_uint8(buf_, pos_, 94, 0))
    def any_ambiguous_as_M1():
        return MyGame.Example.Monster { buf_, flatbuffers.field_table(buf_, pos_, 96) }
    def any_ambiguous_as_M2():
        return MyGame.Example.Monster { buf_, flatbuffers.field_table(buf_, pos_, 96) }
    def any_ambiguous_as_M3():
        return MyGame.Example.Monster { buf_, flatbuffers.field_table(buf_, pos_, 96) }
    def vector_of_enums(i:int) -> Color:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 98) + i * 1)
    def vector_of_enums_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 98)
    def signed_enum() -> Race:
        return Race(flatbuffers.field_int8(buf_, pos_, 100, -1))
    def testrequirednestedflatbuffer(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 102) + i * 1)
    def testrequirednestedflatbuffer_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 102)
    def scalar_key_sorted_tables(i:int) -> MyGame.Example.Stat:
        return MyGame.Example.Stat { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 104) + i * 4) }
    def scalar_key_sorted_tables_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 104)
    def native_inline() -> MyGame.Example.Test?:
        let o = flatbuffers.field_struct(buf_, pos_, 106)
        return if o: MyGame.Example.Test { buf_, o } else: nil
    def long_enum_non_enum_default() -> LongEnum:
        return LongEnum(flatbuffers.field_uint64(buf_, pos_, 108, 0))
    def long_enum_normal_default() -> LongEnum:
        return LongEnum(flatbuffers.field_uint64(buf_, pos_, 110, 2))
    def nan_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 112, nan)
    def inf_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 114, inf)
    def positive_inf_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 116, +inf)
    def infinity_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 118, infinity)
    def positive_infinity_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 120, +infinity)
    def negative_inf_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 122, -inf)
    def negative_infinity_default() -> float:
        return flatbuffers.field_float32(buf_, pos_, 124, -infinity)
    def double_inf_default() -> float:
        return flatbuffers.field_float64(buf_, pos_, 126, inf)

def GetRootAsMonster(buf:string): return Monster { buf, flatbuffers.indirect(buf, 0) }

struct MonsterBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(62)
        return this
    def add_pos(pos:flatbuffers.offset):
        b_.PrependStructSlot(0, pos)
        return this
    def add_mana(mana:int):
        b_.PrependInt16Slot(1, mana, 150)
        return this
    def add_hp(hp:int):
        b_.PrependInt16Slot(2, hp, 100)
        return this
    def add_name(name:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, name)
        return this
    def add_inventory(inventory:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, inventory)
        return this
    def add_color(color:Color):
        b_.PrependUint8Slot(6, color, 8)
        return this
    def add_test_type(test_type:Any):
        b_.PrependUint8Slot(7, test_type, 0)
        return this
    def add_test(test:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, test)
        return this
    def add_test4(test4:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, test4)
        return this
    def add_testarrayofstring(testarrayofstring:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, testarrayofstring)
        return this
    def add_testarrayoftables(testarrayoftables:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, testarrayoftables)
        return this
    def add_enemy(enemy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, enemy)
        return this
    def add_testnestedflatbuffer(testnestedflatbuffer:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, testnestedflatbuffer)
        return this
    def add_testempty(testempty:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, testempty)
        return this
    def add_testbool(testbool:bool):
        b_.PrependBoolSlot(15, testbool, 0)
        return this
    def add_testhashs32_fnv1(testhashs32_fnv1:int):
        b_.PrependInt32Slot(16, testhashs32_fnv1, 0)
        return this
    def add_testhashu32_fnv1(testhashu32_fnv1:int):
        b_.PrependUint32Slot(17, testhashu32_fnv1, 0)
        return this
    def add_testhashs64_fnv1(testhashs64_fnv1:int):
        b_.PrependInt64Slot(18, testhashs64_fnv1, 0)
        return this
    def add_testhashu64_fnv1(testhashu64_fnv1:int):
        b_.PrependUint64Slot(19, testhashu64_fnv1, 0)
        return this
    def add_testhashs32_fnv1a(testhashs32_fnv1a:int):
        b_.PrependInt32Slot(20, testhashs32_fnv1a, 0)
        return this
    def add_testhashu32_fnv1a(testhashu32_fnv1a:int):
        b_.PrependUint32Slot(21, testhashu32_fnv1a, 0)
        return this
    def add_testhashs64_fnv1a(testhashs64_fnv1a:int):
        b_.PrependInt64Slot(22, testhashs64_fnv1a, 0)
        return this
    def add_testhashu64_fnv1a(testhashu64_fnv1a:int):
        b_.PrependUint64Slot(23, testhashu64_fnv1a, 0)
        return this
    def add_testarrayofbools(testarrayofbools:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(24, testarrayofbools)
        return this
    def add_testf(testf:float):
        b_.PrependFloat32Slot(25, testf, 3.14159)
        return this
    def add_testf2(testf2:float):
        b_.PrependFloat32Slot(26, testf2, 3.0)
        return this
    def add_testf3(testf3:float):
        b_.PrependFloat32Slot(27, testf3, 0.0)
        return this
    def add_testarrayofstring2(testarrayofstring2:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(28, testarrayofstring2)
        return this
    def add_testarrayofsortedstruct(testarrayofsortedstruct:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(29, testarrayofsortedstruct)
        return this
    def add_flex(flex:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(30, flex)
        return this
    def add_test5(test5:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(31, test5)
        return this
    def add_vector_of_longs(vector_of_longs:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(32, vector_of_longs)
        return this
    def add_vector_of_doubles(vector_of_doubles:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, vector_of_doubles)
        return this
    def add_parent_namespace_test(parent_namespace_test:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(34, parent_namespace_test)
        return this
    def add_vector_of_referrables(vector_of_referrables:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(35, vector_of_referrables)
        return this
    def add_single_weak_reference(single_weak_reference:int):
        b_.PrependUint64Slot(36, single_weak_reference, 0)
        return this
    def add_vector_of_weak_references(vector_of_weak_references:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(37, vector_of_weak_references)
        return this
    def add_vector_of_strong_referrables(vector_of_strong_referrables:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(38, vector_of_strong_referrables)
        return this
    def add_co_owning_reference(co_owning_reference:int):
        b_.PrependUint64Slot(39, co_owning_reference, 0)
        return this
    def add_vector_of_co_owning_references(vector_of_co_owning_references:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(40, vector_of_co_owning_references)
        return this
    def add_non_owning_reference(non_owning_reference:int):
        b_.PrependUint64Slot(41, non_owning_reference, 0)
        return this
    def add_vector_of_non_owning_references(vector_of_non_owning_references:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(42, vector_of_non_owning_references)
        return this
    def add_any_unique_type(any_unique_type:AnyUniqueAliases):
        b_.PrependUint8Slot(43, any_unique_type, 0)
        return this
    def add_any_unique(any_unique:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(44, any_unique)
        return this
    def add_any_ambiguous_type(any_ambiguous_type:AnyAmbiguousAliases):
        b_.PrependUint8Slot(45, any_ambiguous_type, 0)
        return this
    def add_any_ambiguous(any_ambiguous:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(46, any_ambiguous)
        return this
    def add_vector_of_enums(vector_of_enums:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(47, vector_of_enums)
        return this
    def add_signed_enum(signed_enum:Race):
        b_.PrependInt8Slot(48, signed_enum, -1)
        return this
    def add_testrequirednestedflatbuffer(testrequirednestedflatbuffer:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(49, testrequirednestedflatbuffer)
        return this
    def add_scalar_key_sorted_tables(scalar_key_sorted_tables:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(50, scalar_key_sorted_tables)
        return this
    def add_native_inline(native_inline:flatbuffers.offset):
        b_.PrependStructSlot(51, native_inline)
        return this
    def add_long_enum_non_enum_default(long_enum_non_enum_default:LongEnum):
        b_.PrependUint64Slot(52, long_enum_non_enum_default, 0)
        return this
    def add_long_enum_normal_default(long_enum_normal_default:LongEnum):
        b_.PrependUint64Slot(53, long_enum_normal_default, 2)
        return this
    def add_nan_default(nan_default:float):
        b_.PrependFloat32Slot(54, nan_default, nan)
        return this
    def add_inf_default(inf_default:float):
        b_.PrependFloat32Slot(55, inf_default, inf)
        return this
    def add_positive_inf_default(positive_inf_default:float):
        b_.PrependFloat32Slot(56, positive_inf_default, +inf)
        return this
    def add_infinity_default(infinity_default:float):
        b_.PrependFloat32Slot(57, infinity_default, infinity)
        return this
    def add_positive_infinity_default(positive_infinity_default:float):
        b_.PrependFloat32Slot(58, positive_infinity_default, +infinity)
        return this
    def add_negative_inf_default(negative_inf_default:float):
        b_.PrependFloat32Slot(59, negative_inf_default, -inf)
        return this
    def add_negative_infinity_default(negative_infinity_default:float):
        b_.PrependFloat32Slot(60, negative_infinity_default, -infinity)
        return this
    def add_double_inf_default(double_inf_default:float):
        b_.PrependFloat64Slot(61, double_inf_default, inf)
        return this
    def end():
        return b_.EndObject()

def MonsterStartInventoryVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateInventoryVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartTest4Vector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 2)

def MonsterStartTestarrayofstringVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateTestarrayofstringVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartTestarrayoftablesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateTestarrayoftablesVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartTestnestedflatbufferVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateTestnestedflatbufferVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartTestarrayofboolsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateTestarrayofboolsVector(b_:flatbuffers.builder, v_:[bool]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependBool(e_)
    return b_.EndVector(v_.length)

def MonsterStartTestarrayofstring2Vector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateTestarrayofstring2Vector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartTestarrayofsortedstructVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 4)

def MonsterStartFlexVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateFlexVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartTest5Vector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 2)

def MonsterStartVectorOfLongsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def MonsterCreateVectorOfLongsVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependInt64(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfDoublesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def MonsterCreateVectorOfDoublesVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfReferrablesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateVectorOfReferrablesVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfWeakReferencesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def MonsterCreateVectorOfWeakReferencesVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependUint64(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfStrongReferrablesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateVectorOfStrongReferrablesVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfCoOwningReferencesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def MonsterCreateVectorOfCoOwningReferencesVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependUint64(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfNonOwningReferencesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def MonsterCreateVectorOfNonOwningReferencesVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependUint64(e_)
    return b_.EndVector(v_.length)

def MonsterStartVectorOfEnumsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateVectorOfEnumsVector(b_:flatbuffers.builder, v_:[Color]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartTestrequirednestedflatbufferVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateTestrequirednestedflatbufferVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartScalarKeySortedTablesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateScalarKeySortedTablesVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

class TypeAliases : flatbuffers.handle
    def i8() -> int:
        return flatbuffers.field_int8(buf_, pos_, 4, 0)
    def u8() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 6, 0)
    def i16() -> int:
        return flatbuffers.field_int16(buf_, pos_, 8, 0)
    def u16() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 10, 0)
    def i32() -> int:
        return flatbuffers.field_int32(buf_, pos_, 12, 0)
    def u32() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 0)
    def i64() -> int:
        return flatbuffers.field_int64(buf_, pos_, 16, 0)
    def u64() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 18, 0)
    def f32() -> float:
        return flatbuffers.field_float32(buf_, pos_, 20, 0.0)
    def f64() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    def v8(i:int) -> int:
        return read_int8_le(buf_, buf_.flatbuffers.field_vector(pos_, 24) + i * 1)
    def v8_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    def vf64(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 26) + i * 8)
    def vf64_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)

def GetRootAsTypeAliases(buf:string): return TypeAliases { buf, flatbuffers.indirect(buf, 0) }

struct TypeAliasesBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(12)
        return this
    def add_i8(i8:int):
        b_.PrependInt8Slot(0, i8, 0)
        return this
    def add_u8(u8:int):
        b_.PrependUint8Slot(1, u8, 0)
        return this
    def add_i16(i16:int):
        b_.PrependInt16Slot(2, i16, 0)
        return this
    def add_u16(u16:int):
        b_.PrependUint16Slot(3, u16, 0)
        return this
    def add_i32(i32:int):
        b_.PrependInt32Slot(4, i32, 0)
        return this
    def add_u32(u32:int):
        b_.PrependUint32Slot(5, u32, 0)
        return this
    def add_i64(i64:int):
        b_.PrependInt64Slot(6, i64, 0)
        return this
    def add_u64(u64:int):
        b_.PrependUint64Slot(7, u64, 0)
        return this
    def add_f32(f32:float):
        b_.PrependFloat32Slot(8, f32, 0.0)
        return this
    def add_f64(f64:float):
        b_.PrependFloat64Slot(9, f64, 0.0)
        return this
    def add_v8(v8:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, v8)
        return this
    def add_vf64(vf64:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, vf64)
        return this
    def end():
        return b_.EndObject()

def TypeAliasesStartV8Vector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def TypeAliasesCreateV8Vector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependInt8(e_)
    return b_.EndVector(v_.length)

def TypeAliasesStartVf64Vector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def TypeAliasesCreateVf64Vector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)


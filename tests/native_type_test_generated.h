// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NATIVETYPETEST_GEOMETRY_H_
#define FLATBUFFERS_GENERATED_NATIVETYPETEST_GEOMETRY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "native_type_test_impl.h"

namespace Geometry {

struct Vector3D;

struct Vector3DAlt;

struct Matrix;
struct MatrixBuilder;
struct MatrixT;

struct ApplicationData;
struct ApplicationDataBuilder;
struct ApplicationDataT;

bool operator==(const MatrixT &lhs, const MatrixT &rhs);
bool operator!=(const MatrixT &lhs, const MatrixT &rhs);
bool operator==(const ApplicationDataT &lhs, const ApplicationDataT &rhs);
bool operator!=(const ApplicationDataT &lhs, const ApplicationDataT &rhs);

inline const ::flatbuffers::TypeTable *Vector3DTypeTable();

inline const ::flatbuffers::TypeTable *Vector3DAltTypeTable();

inline const ::flatbuffers::TypeTable *MatrixTypeTable();

inline const ::flatbuffers::TypeTable *ApplicationDataTypeTable();

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3D FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector3DTypeTable();
  }
  Vector3D()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3D(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vector3D, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3DAlt FLATBUFFERS_FINAL_CLASS {
 private:
  float a_;
  float b_;
  float c_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector3DAltTypeTable();
  }
  Vector3DAlt()
      : a_(0),
        b_(0),
        c_(0) {
  }
  Vector3DAlt(float _a, float _b, float _c)
      : a_(::flatbuffers::EndianScalar(_a)),
        b_(::flatbuffers::EndianScalar(_b)),
        c_(::flatbuffers::EndianScalar(_c)) {
  }
  float a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  void mutate_a(float _a) {
    ::flatbuffers::WriteScalar(&a_, _a);
  }
  float b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
  void mutate_b(float _b) {
    ::flatbuffers::WriteScalar(&b_, _b);
  }
  float c() const {
    return ::flatbuffers::EndianScalar(c_);
  }
  void mutate_c(float _c) {
    ::flatbuffers::WriteScalar(&c_, _c);
  }
};
FLATBUFFERS_STRUCT_END(Vector3DAlt, 12);

struct MatrixT : public ::flatbuffers::NativeTable {
  typedef Matrix TableType;
  int32_t rows = 0;
  int32_t columns = 0;
  std::vector<float> values{};
};

struct Matrix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatrixT NativeTableType;
  typedef MatrixBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatrixTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLUMNS = 6,
    VT_VALUES = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  bool mutate_rows(int32_t _rows = 0) {
    return SetField<int32_t>(VT_ROWS, _rows, 0);
  }
  int32_t columns() const {
    return GetField<int32_t>(VT_COLUMNS, 0);
  }
  bool mutate_columns(int32_t _columns = 0) {
    return SetField<int32_t>(VT_COLUMNS, _columns, 0);
  }
  const ::flatbuffers::Vector<float> *values() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUES);
  }
  ::flatbuffers::Vector<float> *mutable_values() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLUMNS, 4) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  MatrixT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Matrix> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixBuilder {
  typedef Matrix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(Matrix::VT_ROWS, rows, 0);
  }
  void add_columns(int32_t columns) {
    fbb_.AddElement<int32_t>(Matrix::VT_COLUMNS, columns, 0);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<float>> values) {
    fbb_.AddOffset(Matrix::VT_VALUES, values);
  }
  explicit MatrixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Matrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Matrix>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Matrix> CreateMatrix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t columns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> values = 0) {
  MatrixBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_columns(columns);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Matrix> CreateMatrixDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t columns = 0,
    const std::vector<float> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<float>(*values) : 0;
  return Geometry::CreateMatrix(
      _fbb,
      rows,
      columns,
      values__);
}

::flatbuffers::Offset<Matrix> CreateMatrix(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplicationDataT : public ::flatbuffers::NativeTable {
  typedef ApplicationData TableType;
  std::vector<Native::Vector3D> vectors{};
  std::vector<Native::Vector3D> vectors_alt{};
  std::unique_ptr<Native::Vector3D> position{};
  Native::Vector3D position_inline{};
  std::unique_ptr<Geometry::MatrixT> matrix{};
  std::vector<std::unique_ptr<Geometry::MatrixT>> matrices{};
  ApplicationDataT() = default;
  ApplicationDataT(const ApplicationDataT &o);
  ApplicationDataT(ApplicationDataT&&) FLATBUFFERS_NOEXCEPT = default;
  ApplicationDataT &operator=(ApplicationDataT o) FLATBUFFERS_NOEXCEPT;
};

struct ApplicationData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ApplicationDataT NativeTableType;
  typedef ApplicationDataBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ApplicationDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VECTORS = 4,
    VT_VECTORS_ALT = 6,
    VT_POSITION = 8,
    VT_POSITION_INLINE = 10,
    VT_MATRIX = 12,
    VT_MATRICES = 14
  };
  const ::flatbuffers::Vector<const Geometry::Vector3D *> *vectors() const {
    return GetPointer<const ::flatbuffers::Vector<const Geometry::Vector3D *> *>(VT_VECTORS);
  }
  ::flatbuffers::Vector<const Geometry::Vector3D *> *mutable_vectors() {
    return GetPointer<::flatbuffers::Vector<const Geometry::Vector3D *> *>(VT_VECTORS);
  }
  const ::flatbuffers::Vector<const Geometry::Vector3DAlt *> *vectors_alt() const {
    return GetPointer<const ::flatbuffers::Vector<const Geometry::Vector3DAlt *> *>(VT_VECTORS_ALT);
  }
  ::flatbuffers::Vector<const Geometry::Vector3DAlt *> *mutable_vectors_alt() {
    return GetPointer<::flatbuffers::Vector<const Geometry::Vector3DAlt *> *>(VT_VECTORS_ALT);
  }
  const Geometry::Vector3D *position() const {
    return GetStruct<const Geometry::Vector3D *>(VT_POSITION);
  }
  Geometry::Vector3D *mutable_position() {
    return GetStruct<Geometry::Vector3D *>(VT_POSITION);
  }
  const Geometry::Vector3D *position_inline() const {
    return GetStruct<const Geometry::Vector3D *>(VT_POSITION_INLINE);
  }
  Geometry::Vector3D *mutable_position_inline() {
    return GetStruct<Geometry::Vector3D *>(VT_POSITION_INLINE);
  }
  const Geometry::Matrix *matrix() const {
    return GetPointer<const Geometry::Matrix *>(VT_MATRIX);
  }
  Geometry::Matrix *mutable_matrix() {
    return GetPointer<Geometry::Matrix *>(VT_MATRIX);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Geometry::Matrix>> *matrices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Geometry::Matrix>> *>(VT_MATRICES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Geometry::Matrix>> *mutable_matrices() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Geometry::Matrix>> *>(VT_MATRICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTORS) &&
           verifier.VerifyVector(vectors()) &&
           VerifyOffset(verifier, VT_VECTORS_ALT) &&
           verifier.VerifyVector(vectors_alt()) &&
           VerifyField<Geometry::Vector3D>(verifier, VT_POSITION, 4) &&
           VerifyField<Geometry::Vector3D>(verifier, VT_POSITION_INLINE, 4) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyTable(matrix()) &&
           VerifyOffset(verifier, VT_MATRICES) &&
           verifier.VerifyVector(matrices()) &&
           verifier.VerifyVectorOfTables(matrices()) &&
           verifier.EndTable();
  }
  ApplicationDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ApplicationData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationDataBuilder {
  typedef ApplicationData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vectors(::flatbuffers::Offset<::flatbuffers::Vector<const Geometry::Vector3D *>> vectors) {
    fbb_.AddOffset(ApplicationData::VT_VECTORS, vectors);
  }
  void add_vectors_alt(::flatbuffers::Offset<::flatbuffers::Vector<const Geometry::Vector3DAlt *>> vectors_alt) {
    fbb_.AddOffset(ApplicationData::VT_VECTORS_ALT, vectors_alt);
  }
  void add_position(const Geometry::Vector3D *position) {
    fbb_.AddStruct(ApplicationData::VT_POSITION, position);
  }
  void add_position_inline(const Geometry::Vector3D *position_inline) {
    fbb_.AddStruct(ApplicationData::VT_POSITION_INLINE, position_inline);
  }
  void add_matrix(::flatbuffers::Offset<Geometry::Matrix> matrix) {
    fbb_.AddOffset(ApplicationData::VT_MATRIX, matrix);
  }
  void add_matrices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Geometry::Matrix>>> matrices) {
    fbb_.AddOffset(ApplicationData::VT_MATRICES, matrices);
  }
  explicit ApplicationDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ApplicationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ApplicationData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ApplicationData> CreateApplicationData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Geometry::Vector3D *>> vectors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Geometry::Vector3DAlt *>> vectors_alt = 0,
    const Geometry::Vector3D *position = nullptr,
    const Geometry::Vector3D *position_inline = nullptr,
    ::flatbuffers::Offset<Geometry::Matrix> matrix = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Geometry::Matrix>>> matrices = 0) {
  ApplicationDataBuilder builder_(_fbb);
  builder_.add_matrices(matrices);
  builder_.add_matrix(matrix);
  builder_.add_position_inline(position_inline);
  builder_.add_position(position);
  builder_.add_vectors_alt(vectors_alt);
  builder_.add_vectors(vectors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ApplicationData> CreateApplicationDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Geometry::Vector3D> *vectors = nullptr,
    const std::vector<Geometry::Vector3DAlt> *vectors_alt = nullptr,
    const Geometry::Vector3D *position = nullptr,
    const Geometry::Vector3D *position_inline = nullptr,
    ::flatbuffers::Offset<Geometry::Matrix> matrix = 0,
    const std::vector<::flatbuffers::Offset<Geometry::Matrix>> *matrices = nullptr) {
  auto vectors__ = vectors ? _fbb.CreateVectorOfStructs<Geometry::Vector3D>(*vectors) : 0;
  auto vectors_alt__ = vectors_alt ? _fbb.CreateVectorOfStructs<Geometry::Vector3DAlt>(*vectors_alt) : 0;
  auto matrices__ = matrices ? _fbb.CreateVector<::flatbuffers::Offset<Geometry::Matrix>>(*matrices) : 0;
  return Geometry::CreateApplicationData(
      _fbb,
      vectors__,
      vectors_alt__,
      position,
      position_inline,
      matrix,
      matrices__);
}

::flatbuffers::Offset<ApplicationData> CreateApplicationData(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const MatrixT &lhs, const MatrixT &rhs) {
  return
      (lhs.rows == rhs.rows) &&
      (lhs.columns == rhs.columns) &&
      (lhs.values == rhs.values);
}

inline bool operator!=(const MatrixT &lhs, const MatrixT &rhs) {
    return !(lhs == rhs);
}


inline MatrixT *Matrix::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatrixT>(new MatrixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Matrix::UnPackTo(MatrixT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rows(); _o->rows = _e; }
  { auto _e = columns(); _o->columns = _e; }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<Matrix> CreateMatrix(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Matrix::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Matrix> Matrix::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MatrixT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MatrixT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rows = _o->rows;
  auto _columns = _o->columns;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return Geometry::CreateMatrix(
      _fbb,
      _rows,
      _columns,
      _values);
}


inline bool operator==(const ApplicationDataT &lhs, const ApplicationDataT &rhs) {
  return
      (lhs.vectors == rhs.vectors) &&
      (lhs.vectors_alt == rhs.vectors_alt) &&
      ((lhs.position == rhs.position) || (lhs.position && rhs.position && *lhs.position == *rhs.position)) &&
      (lhs.position_inline == rhs.position_inline) &&
      ((lhs.matrix == rhs.matrix) || (lhs.matrix && rhs.matrix && *lhs.matrix == *rhs.matrix)) &&
      (lhs.matrices.size() == rhs.matrices.size() && std::equal(lhs.matrices.cbegin(), lhs.matrices.cend(), rhs.matrices.cbegin(), [](std::unique_ptr<Geometry::MatrixT> const &a, std::unique_ptr<Geometry::MatrixT> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const ApplicationDataT &lhs, const ApplicationDataT &rhs) {
    return !(lhs == rhs);
}


inline ApplicationDataT::ApplicationDataT(const ApplicationDataT &o)
      : vectors(o.vectors),
        vectors_alt(o.vectors_alt),
        position((o.position) ? new Native::Vector3D(*o.position) : nullptr),
        position_inline(o.position_inline),
        matrix((o.matrix) ? new Geometry::MatrixT(*o.matrix) : nullptr) {
  matrices.reserve(o.matrices.size());
  for (const auto &matrices_ : o.matrices) { matrices.emplace_back((matrices_) ? new Geometry::MatrixT(*matrices_) : nullptr); }
}

inline ApplicationDataT &ApplicationDataT::operator=(ApplicationDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(vectors, o.vectors);
  std::swap(vectors_alt, o.vectors_alt);
  std::swap(position, o.position);
  std::swap(position_inline, o.position_inline);
  std::swap(matrix, o.matrix);
  std::swap(matrices, o.matrices);
  return *this;
}

inline ApplicationDataT *ApplicationData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplicationDataT>(new ApplicationDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplicationData::UnPackTo(ApplicationDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vectors(); if (_e) { _o->vectors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vectors[_i] = ::flatbuffers::UnPack(*_e->Get(_i)); } } else { _o->vectors.resize(0); } }
  { auto _e = vectors_alt(); if (_e) { _o->vectors_alt.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vectors_alt[_i] = ::flatbuffers::UnPackVector3DAlt(*_e->Get(_i)); } } else { _o->vectors_alt.resize(0); } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<Native::Vector3D>(new Native::Vector3D(::flatbuffers::UnPack(*_e))); }
  { auto _e = position_inline(); if (_e) _o->position_inline = ::flatbuffers::UnPack(*_e); }
  { auto _e = matrix(); if (_e) { if(_o->matrix) { _e->UnPackTo(_o->matrix.get(), _resolver); } else { _o->matrix = std::unique_ptr<Geometry::MatrixT>(_e->UnPack(_resolver)); } } else if (_o->matrix) { _o->matrix.reset(); } }
  { auto _e = matrices(); if (_e) { _o->matrices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->matrices[_i]) { _e->Get(_i)->UnPackTo(_o->matrices[_i].get(), _resolver); } else { _o->matrices[_i] = std::unique_ptr<Geometry::MatrixT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->matrices.resize(0); } }
}

inline ::flatbuffers::Offset<ApplicationData> CreateApplicationData(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return ApplicationData::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ApplicationData> ApplicationData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ApplicationDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vectors = _o->vectors.size() ? _fbb.CreateVectorOfNativeStructs<Geometry::Vector3D, Native::Vector3D>(_o->vectors) : 0;
  auto _vectors_alt = _o->vectors_alt.size() ? _fbb.CreateVectorOfNativeStructs<Geometry::Vector3DAlt, Native::Vector3D>(_o->vectors_alt, ::flatbuffers::PackVector3DAlt) : 0;
  auto _position = Geometry::Vector3D{}; if (_o->position) _position = ::flatbuffers::Pack(*_o->position);
  auto _position_inline = ::flatbuffers::Pack(_o->position_inline);
  auto _matrix = _o->matrix ? CreateMatrix(_fbb, _o->matrix.get(), _rehasher) : 0;
  auto _matrices = _o->matrices.size() ? _fbb.CreateVector<::flatbuffers::Offset<Geometry::Matrix>> (_o->matrices.size(), [](size_t i, _VectorArgs *__va) { return CreateMatrix(*__va->__fbb, __va->__o->matrices[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Geometry::CreateApplicationData(
      _fbb,
      _vectors,
      _vectors_alt,
      _o->position ? &_position : nullptr,
      &_position_inline,
      _matrix,
      _matrices);
}

inline const ::flatbuffers::TypeTable *Vector3DTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Vector3DAltTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "a",
    "b",
    "c"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MatrixTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "rows",
    "columns",
    "values"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ApplicationDataTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    Geometry::Vector3DTypeTable,
    Geometry::Vector3DAltTypeTable,
    Geometry::MatrixTypeTable
  };
  static const char * const names[] = {
    "vectors",
    "vectors_alt",
    "position",
    "position_inline",
    "matrix",
    "matrices"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const Geometry::ApplicationData *GetApplicationData(const void *buf) {
  return ::flatbuffers::GetRoot<Geometry::ApplicationData>(buf);
}

inline const Geometry::ApplicationData *GetSizePrefixedApplicationData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Geometry::ApplicationData>(buf);
}

inline ApplicationData *GetMutableApplicationData(void *buf) {
  return ::flatbuffers::GetMutableRoot<ApplicationData>(buf);
}

inline Geometry::ApplicationData *GetMutableSizePrefixedApplicationData(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Geometry::ApplicationData>(buf);
}

inline bool VerifyApplicationDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Geometry::ApplicationData>(nullptr);
}

inline bool VerifySizePrefixedApplicationDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Geometry::ApplicationData>(nullptr);
}

inline void FinishApplicationDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Geometry::ApplicationData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedApplicationDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Geometry::ApplicationData> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Geometry::ApplicationDataT> UnPackApplicationData(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Geometry::ApplicationDataT>(GetApplicationData(buf)->UnPack(res));
}

inline std::unique_ptr<Geometry::ApplicationDataT> UnPackSizePrefixedApplicationData(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Geometry::ApplicationDataT>(GetSizePrefixedApplicationData(buf)->UnPack(res));
}

}  // namespace Geometry

#endif  // FLATBUFFERS_GENERATED_NATIVETYPETEST_GEOMETRY_H_

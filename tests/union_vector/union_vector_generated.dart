// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable, constant_identifier_names

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


enum CharacterTypeId {
  NONE(0),
  MuLan(1),
  Rapunzel(2),
  Belle(3),
  BookFan(4),
  Other(5),
  Unused(6);

  final int value;
  const CharacterTypeId(this.value);

  factory CharacterTypeId.fromValue(int value) {
    switch (value) {
      case 0: return CharacterTypeId.NONE;
      case 1: return CharacterTypeId.MuLan;
      case 2: return CharacterTypeId.Rapunzel;
      case 3: return CharacterTypeId.Belle;
      case 4: return CharacterTypeId.BookFan;
      case 5: return CharacterTypeId.Other;
      case 6: return CharacterTypeId.Unused;
      default: throw StateError('Invalid value $value for bit flag enum');
    }
  }

  static CharacterTypeId? _createOrNull(int? value) =>
      value == null ? null : CharacterTypeId.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 6;
  static const fb.Reader<CharacterTypeId> reader = _CharacterTypeIdReader();
}

class _CharacterTypeIdReader extends fb.Reader<CharacterTypeId> {
  const _CharacterTypeIdReader();

  @override
  int get size => 1;

  @override
  CharacterTypeId read(fb.BufferContext bc, int offset) =>
      CharacterTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
}

class _CharacterReader extends fb.UnionReader {
  _CharacterReader(CharacterTypeId? type) : super(_get(type));

  static fb.Reader? _get(CharacterTypeId? type) {
    switch (type?.value) {
      case 1: return Attacker.reader;
      case 2: return Rapunzel.reader;
      case 3: return BookReader.reader;
      case 4: return BookReader.reader;
      case 5: return fb.StringReader();
      case 6: return fb.StringReader();
      default: return null;
    }
  }
}

enum GadgetTypeId {
  NONE(0),
  FallingTub(1),
  HandFan(2);

  final int value;
  const GadgetTypeId(this.value);

  factory GadgetTypeId.fromValue(int value) {
    switch (value) {
      case 0: return GadgetTypeId.NONE;
      case 1: return GadgetTypeId.FallingTub;
      case 2: return GadgetTypeId.HandFan;
      default: throw StateError('Invalid value $value for bit flag enum');
    }
  }

  static GadgetTypeId? _createOrNull(int? value) =>
      value == null ? null : GadgetTypeId.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static const fb.Reader<GadgetTypeId> reader = _GadgetTypeIdReader();
}

class _GadgetTypeIdReader extends fb.Reader<GadgetTypeId> {
  const _GadgetTypeIdReader();

  @override
  int get size => 1;

  @override
  GadgetTypeId read(fb.BufferContext bc, int offset) =>
      GadgetTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
}

class _GadgetReader extends fb.UnionReader {
  _GadgetReader(GadgetTypeId? type) : super(_get(type));

  static fb.Reader? _get(GadgetTypeId? type) {
    switch (type?.value) {
      case 1: return FallingTub.reader;
      case 2: return HandFan.reader;
      default: return null;
    }
  }
}

class Attacker {
  Attacker._(this._bc, this._bcOffset);
  factory Attacker(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Attacker> reader = _AttackerReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get swordAttackDamage => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);

  @override
  String toString() {
    return 'Attacker{swordAttackDamage: ${swordAttackDamage}}';
  }

  AttackerT unpack() => AttackerT(
      swordAttackDamage: swordAttackDamage);

  static int pack(fb.Builder fbBuilder, AttackerT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class AttackerT implements fb.Packable {
  int swordAttackDamage;

  AttackerT({
      this.swordAttackDamage = 0});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt32(0, swordAttackDamage);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'AttackerT{swordAttackDamage: ${swordAttackDamage}}';
  }
}

class _AttackerReader extends fb.TableReader<Attacker> {
  const _AttackerReader();

  @override
  Attacker createObject(fb.BufferContext bc, int offset) => 
    Attacker._(bc, offset);
}

class AttackerBuilder {
  AttackerBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addSwordAttackDamage(int? swordAttackDamage) {
    fbBuilder.addInt32(0, swordAttackDamage);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class AttackerObjectBuilder extends fb.ObjectBuilder {
  final int? _swordAttackDamage;

  AttackerObjectBuilder({
    int? swordAttackDamage,
  })
      : _swordAttackDamage = swordAttackDamage;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt32(0, _swordAttackDamage);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class Rapunzel {
  Rapunzel._(this._bc, this._bcOffset);

  static const fb.Reader<Rapunzel> reader = _RapunzelReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get hairLength => const fb.Int32Reader().read(_bc, _bcOffset + 0);

  @override
  String toString() {
    return 'Rapunzel{hairLength: ${hairLength}}';
  }

  RapunzelT unpack() => RapunzelT(
      hairLength: hairLength);

  static int pack(fb.Builder fbBuilder, RapunzelT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class RapunzelT implements fb.Packable {
  int hairLength;

  RapunzelT({
      required this.hairLength});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putInt32(hairLength);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'RapunzelT{hairLength: ${hairLength}}';
  }
}

class _RapunzelReader extends fb.StructReader<Rapunzel> {
  const _RapunzelReader();

  @override
  int get size => 4;

  @override
  Rapunzel createObject(fb.BufferContext bc, int offset) => 
    Rapunzel._(bc, offset);
}

class RapunzelBuilder {
  RapunzelBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(int hairLength) {
    fbBuilder.putInt32(hairLength);
    return fbBuilder.offset;
  }

}

class RapunzelObjectBuilder extends fb.ObjectBuilder {
  final int _hairLength;

  RapunzelObjectBuilder({
    required int hairLength,
  })
      : _hairLength = hairLength;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putInt32(_hairLength);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class BookReader {
  BookReader._(this._bc, this._bcOffset);

  static const fb.Reader<BookReader> reader = _BookReaderReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get booksRead => const fb.Int32Reader().read(_bc, _bcOffset + 0);

  @override
  String toString() {
    return 'BookReader{booksRead: ${booksRead}}';
  }

  BookReaderT unpack() => BookReaderT(
      booksRead: booksRead);

  static int pack(fb.Builder fbBuilder, BookReaderT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class BookReaderT implements fb.Packable {
  int booksRead;

  BookReaderT({
      required this.booksRead});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putInt32(booksRead);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'BookReaderT{booksRead: ${booksRead}}';
  }
}

class _BookReaderReader extends fb.StructReader<BookReader> {
  const _BookReaderReader();

  @override
  int get size => 4;

  @override
  BookReader createObject(fb.BufferContext bc, int offset) => 
    BookReader._(bc, offset);
}

class BookReaderBuilder {
  BookReaderBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(int booksRead) {
    fbBuilder.putInt32(booksRead);
    return fbBuilder.offset;
  }

}

class BookReaderObjectBuilder extends fb.ObjectBuilder {
  final int _booksRead;

  BookReaderObjectBuilder({
    required int booksRead,
  })
      : _booksRead = booksRead;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putInt32(_booksRead);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class FallingTub {
  FallingTub._(this._bc, this._bcOffset);

  static const fb.Reader<FallingTub> reader = _FallingTubReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get weight => const fb.Int32Reader().read(_bc, _bcOffset + 0);

  @override
  String toString() {
    return 'FallingTub{weight: ${weight}}';
  }

  FallingTubT unpack() => FallingTubT(
      weight: weight);

  static int pack(fb.Builder fbBuilder, FallingTubT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class FallingTubT implements fb.Packable {
  int weight;

  FallingTubT({
      required this.weight});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putInt32(weight);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'FallingTubT{weight: ${weight}}';
  }
}

class _FallingTubReader extends fb.StructReader<FallingTub> {
  const _FallingTubReader();

  @override
  int get size => 4;

  @override
  FallingTub createObject(fb.BufferContext bc, int offset) => 
    FallingTub._(bc, offset);
}

class FallingTubBuilder {
  FallingTubBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(int weight) {
    fbBuilder.putInt32(weight);
    return fbBuilder.offset;
  }

}

class FallingTubObjectBuilder extends fb.ObjectBuilder {
  final int _weight;

  FallingTubObjectBuilder({
    required int weight,
  })
      : _weight = weight;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putInt32(_weight);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class HandFan {
  HandFan._(this._bc, this._bcOffset);
  factory HandFan(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<HandFan> reader = _HandFanReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get length => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);

  @override
  String toString() {
    return 'HandFan{length: ${length}}';
  }

  HandFanT unpack() => HandFanT(
      length: length);

  static int pack(fb.Builder fbBuilder, HandFanT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class HandFanT implements fb.Packable {
  int length;

  HandFanT({
      this.length = 0});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt32(0, length);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'HandFanT{length: ${length}}';
  }
}

class _HandFanReader extends fb.TableReader<HandFan> {
  const _HandFanReader();

  @override
  HandFan createObject(fb.BufferContext bc, int offset) => 
    HandFan._(bc, offset);
}

class HandFanBuilder {
  HandFanBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addLength(int? length) {
    fbBuilder.addInt32(0, length);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class HandFanObjectBuilder extends fb.ObjectBuilder {
  final int? _length;

  HandFanObjectBuilder({
    int? length,
  })
      : _length = length;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(1);
    fbBuilder.addInt32(0, _length);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class Movie {
  Movie._(this._bc, this._bcOffset);
  factory Movie(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Movie> reader = _MovieReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  CharacterTypeId? get mainCharacterType => CharacterTypeId._createOrNull(const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 4));
  dynamic get mainCharacter => _CharacterReader(mainCharacterType).vTableGetNullable(_bc, _bcOffset, 6);
  List<CharacterTypeId>? get charactersType => const fb.ListReader<CharacterTypeId>(CharacterTypeId.reader).vTableGetNullable(_bc, _bcOffset, 8);
  List<dynamic>? get characters => fb.UnionListReader((index) => _CharacterReader(charactersType?[index])).vTableGetNullable(_bc, _bcOffset, 10);

  @override
  String toString() {
    return 'Movie{mainCharacterType: ${mainCharacterType}, mainCharacter: ${mainCharacter}, charactersType: ${charactersType}, characters: ${characters}}';
  }

  MovieT unpack() => MovieT(
      mainCharacterType: mainCharacterType,
      mainCharacter: mainCharacter is String ? mainCharacter : mainCharacter?.unpack(),
      charactersType: charactersType?.toList(),
      characters: characters?.map((e) => e is String ? e : e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, MovieT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class MovieT implements fb.Packable {
  CharacterTypeId? mainCharacterType;
  dynamic mainCharacter;
  List<CharacterTypeId>? charactersType;
  List<dynamic>? characters;

  MovieT({
      this.mainCharacterType,
      this.mainCharacter,
      this.charactersType,
      this.characters});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? mainCharacterOffset = mainCharacter is String ? fbBuilder.writeString(mainCharacter) : mainCharacter?.pack(fbBuilder);
    final int? charactersTypeOffset = charactersType == null ? null
        : fbBuilder.writeListUint8(charactersType!.map((f) => f.value).toList());
    final int? charactersOffset = characters == null ? null
        : fbBuilder.writeList(characters!.map<int>((u) => u is String ? fbBuilder.writeString(u) : u.pack(fbBuilder)).toList());
    fbBuilder.startTable(4);
    fbBuilder.addUint8(0, mainCharacterType?.value);
    fbBuilder.addOffset(1, mainCharacterOffset);
    fbBuilder.addOffset(2, charactersTypeOffset);
    fbBuilder.addOffset(3, charactersOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'MovieT{mainCharacterType: ${mainCharacterType}, mainCharacter: ${mainCharacter}, charactersType: ${charactersType}, characters: ${characters}}';
  }
}

class _MovieReader extends fb.TableReader<Movie> {
  const _MovieReader();

  @override
  Movie createObject(fb.BufferContext bc, int offset) => 
    Movie._(bc, offset);
}

class MovieBuilder {
  MovieBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addMainCharacterType(CharacterTypeId? mainCharacterType) {
    fbBuilder.addUint8(0, mainCharacterType?.value);
    return fbBuilder.offset;
  }
  int addMainCharacterOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addCharactersTypeOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addCharactersOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class MovieObjectBuilder extends fb.ObjectBuilder {
  final CharacterTypeId? _mainCharacterType;
  final dynamic _mainCharacter;
  final List<CharacterTypeId>? _charactersType;
  final List<dynamic>? _characters;

  MovieObjectBuilder({
    CharacterTypeId? mainCharacterType,
    dynamic mainCharacter,
    List<CharacterTypeId>? charactersType,
    List<dynamic>? characters,
  })
      : _mainCharacterType = mainCharacterType,
        _mainCharacter = mainCharacter,
        _charactersType = charactersType,
        _characters = characters;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? mainCharacterOffset = _mainCharacter is String ? fbBuilder.writeString(_mainCharacter) : _mainCharacter?.getOrCreateOffset(fbBuilder);
    final int? charactersTypeOffset = _charactersType == null ? null
        : fbBuilder.writeListUint8(_charactersType!.map((f) => f.value).toList());
    final int? charactersOffset = _characters == null ? null
        : fbBuilder.writeList(_characters!.map<int>((u) => u is String ? fbBuilder.writeString(u) : u.getOrCreateOffset(fbBuilder)).toList());
    fbBuilder.startTable(4);
    fbBuilder.addUint8(0, _mainCharacterType?.value);
    fbBuilder.addOffset(1, mainCharacterOffset);
    fbBuilder.addOffset(2, charactersTypeOffset);
    fbBuilder.addOffset(3, charactersOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

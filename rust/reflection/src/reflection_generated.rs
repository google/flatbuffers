// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod reflection {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BASE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BASE_TYPE: i8 = 19;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BASE_TYPE: [BaseType; 20] = [
  BaseType::None,
  BaseType::UType,
  BaseType::Bool,
  BaseType::Byte,
  BaseType::UByte,
  BaseType::Short,
  BaseType::UShort,
  BaseType::Int,
  BaseType::UInt,
  BaseType::Long,
  BaseType::ULong,
  BaseType::Float,
  BaseType::Double,
  BaseType::String,
  BaseType::Vector,
  BaseType::Obj,
  BaseType::Union,
  BaseType::Array,
  BaseType::Vector64,
  BaseType::MaxBaseType,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BaseType(pub i8);
#[allow(non_upper_case_globals)]
impl BaseType {
  pub const None: Self = Self(0);
  pub const UType: Self = Self(1);
  pub const Bool: Self = Self(2);
  pub const Byte: Self = Self(3);
  pub const UByte: Self = Self(4);
  pub const Short: Self = Self(5);
  pub const UShort: Self = Self(6);
  pub const Int: Self = Self(7);
  pub const UInt: Self = Self(8);
  pub const Long: Self = Self(9);
  pub const ULong: Self = Self(10);
  pub const Float: Self = Self(11);
  pub const Double: Self = Self(12);
  pub const String: Self = Self(13);
  pub const Vector: Self = Self(14);
  pub const Obj: Self = Self(15);
  pub const Union: Self = Self(16);
  pub const Array: Self = Self(17);
  pub const Vector64: Self = Self(18);
  pub const MaxBaseType: Self = Self(19);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 19;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::UType,
    Self::Bool,
    Self::Byte,
    Self::UByte,
    Self::Short,
    Self::UShort,
    Self::Int,
    Self::UInt,
    Self::Long,
    Self::ULong,
    Self::Float,
    Self::Double,
    Self::String,
    Self::Vector,
    Self::Obj,
    Self::Union,
    Self::Array,
    Self::Vector64,
    Self::MaxBaseType,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::UType => Some("UType"),
      Self::Bool => Some("Bool"),
      Self::Byte => Some("Byte"),
      Self::UByte => Some("UByte"),
      Self::Short => Some("Short"),
      Self::UShort => Some("UShort"),
      Self::Int => Some("Int"),
      Self::UInt => Some("UInt"),
      Self::Long => Some("Long"),
      Self::ULong => Some("ULong"),
      Self::Float => Some("Float"),
      Self::Double => Some("Double"),
      Self::String => Some("String"),
      Self::Vector => Some("Vector"),
      Self::Obj => Some("Obj"),
      Self::Union => Some("Union"),
      Self::Array => Some("Array"),
      Self::Vector64 => Some("Vector64"),
      Self::MaxBaseType => Some("MaxBaseType"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BaseType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BaseType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BaseType {
    type Output = BaseType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BaseType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BaseType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BaseType {}
#[allow(non_upper_case_globals)]
mod bitflags_advanced_features {
  flatbuffers::bitflags::bitflags! {
    /// New schema language features that are not supported by old code generators.
    #[derive(Default, Debug, Clone, Copy, PartialEq)]
    pub struct AdvancedFeatures: u64 {
      const AdvancedArrayFeatures = 1;
      const AdvancedUnionFeatures = 2;
      const OptionalScalars = 4;
      const DefaultVectorsAndStrings = 8;
    }
  }
}
pub use self::bitflags_advanced_features::AdvancedFeatures;

impl<'a> flatbuffers::Follow<'a> for AdvancedFeatures {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u64>(buf, loc);
    Self::from_bits_retain(b)
  }
}

impl flatbuffers::Push for AdvancedFeatures {
    type Output = AdvancedFeatures;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u64>(dst, self.bits());
    }
}

impl flatbuffers::EndianScalar for AdvancedFeatures {
  type Scalar = u64;
  #[inline]
  fn to_little_endian(self) -> u64 {
    self.bits().to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u64) -> Self {
    let b = u64::from_le(v);
    Self::from_bits_retain(b)
  }
}

impl<'a> flatbuffers::Verifiable for AdvancedFeatures {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u64::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AdvancedFeatures {}
pub enum TypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Type<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Type<'a> {
  type Inner = Type<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Type<'a> {
  pub const VT_BASE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_FIXED_LENGTH: flatbuffers::VOffsetT = 10;
  pub const VT_BASE_SIZE: flatbuffers::VOffsetT = 12;
  pub const VT_ELEMENT_SIZE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Type { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TypeArgs
  ) -> flatbuffers::WIPOffset<Type<'bldr>> {
    let mut builder = TypeBuilder::new(_fbb);
    builder.add_element_size(args.element_size);
    builder.add_base_size(args.base_size);
    builder.add_index(args.index);
    builder.add_fixed_length(args.fixed_length);
    builder.add_element(args.element);
    builder.add_base_type(args.base_type);
    builder.finish()
  }


  #[inline]
  pub fn base_type(&self) -> BaseType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BaseType>(Type::VT_BASE_TYPE, Some(BaseType::None)).unwrap()}
  }
  #[inline]
  pub fn element(&self) -> BaseType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BaseType>(Type::VT_ELEMENT, Some(BaseType::None)).unwrap()}
  }
  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Type::VT_INDEX, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn fixed_length(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Type::VT_FIXED_LENGTH, Some(0)).unwrap()}
  }
  /// The size (octets) of the `base_type` field.
  #[inline]
  pub fn base_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Type::VT_BASE_SIZE, Some(4)).unwrap()}
  }
  /// The size (octets) of the `element` field, if present.
  #[inline]
  pub fn element_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Type::VT_ELEMENT_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Type<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<BaseType>("base_type", Self::VT_BASE_TYPE, false)?
     .visit_field::<BaseType>("element", Self::VT_ELEMENT, false)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<u16>("fixed_length", Self::VT_FIXED_LENGTH, false)?
     .visit_field::<u32>("base_size", Self::VT_BASE_SIZE, false)?
     .visit_field::<u32>("element_size", Self::VT_ELEMENT_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct TypeArgs {
    pub base_type: BaseType,
    pub element: BaseType,
    pub index: i32,
    pub fixed_length: u16,
    pub base_size: u32,
    pub element_size: u32,
}
impl<'a> Default for TypeArgs {
  #[inline]
  fn default() -> Self {
    TypeArgs {
      base_type: BaseType::None,
      element: BaseType::None,
      index: -1,
      fixed_length: 0,
      base_size: 4,
      element_size: 0,
    }
  }
}

pub struct TypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base_type(&mut self, base_type: BaseType) {
    self.fbb_.push_slot::<BaseType>(Type::VT_BASE_TYPE, base_type, BaseType::None);
  }
  #[inline]
  pub fn add_element(&mut self, element: BaseType) {
    self.fbb_.push_slot::<BaseType>(Type::VT_ELEMENT, element, BaseType::None);
  }
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(Type::VT_INDEX, index, -1);
  }
  #[inline]
  pub fn add_fixed_length(&mut self, fixed_length: u16) {
    self.fbb_.push_slot::<u16>(Type::VT_FIXED_LENGTH, fixed_length, 0);
  }
  #[inline]
  pub fn add_base_size(&mut self, base_size: u32) {
    self.fbb_.push_slot::<u32>(Type::VT_BASE_SIZE, base_size, 4);
  }
  #[inline]
  pub fn add_element_size(&mut self, element_size: u32) {
    self.fbb_.push_slot::<u32>(Type::VT_ELEMENT_SIZE, element_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Type<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Type<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Type");
      ds.field("base_type", &self.base_type());
      ds.field("element", &self.element());
      ds.field("index", &self.index());
      ds.field("fixed_length", &self.fixed_length());
      ds.field("base_size", &self.base_size());
      ds.field("element_size", &self.element_size());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KeyValue<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueArgs<'args>
  ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &KeyValue) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for KeyValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KeyValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct KeyValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyValue::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum EnumValOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EnumVal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumVal<'a> {
  type Inner = EnumVal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EnumVal<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_UNION_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 12;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnumVal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnumValArgs<'args>
  ) -> flatbuffers::WIPOffset<EnumVal<'bldr>> {
    let mut builder = EnumValBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.documentation { builder.add_documentation(x); }
    if let Some(x) = args.union_type { builder.add_union_type(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumVal::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EnumVal::VT_VALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &EnumVal) -> bool {
    self.value() < o.value()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: i64) -> ::core::cmp::Ordering {
    let key = self.value();
    key.cmp(&val)
  }
  #[inline]
  pub fn union_type(&self) -> Option<Type<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(EnumVal::VT_UNION_TYPE, None)}
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EnumVal::VT_DOCUMENTATION, None)}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(EnumVal::VT_ATTRIBUTES, None)}
  }
}

impl flatbuffers::Verifiable for EnumVal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<i64>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("union_type", Self::VT_UNION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("documentation", Self::VT_DOCUMENTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .finish();
    Ok(())
  }
}
pub struct EnumValArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i64,
    pub union_type: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
}
impl<'a> Default for EnumValArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnumValArgs {
      name: None, // required field
      value: 0,
      union_type: None,
      documentation: None,
      attributes: None,
    }
  }
}

pub struct EnumValBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnumValBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: i64) {
    self.fbb_.push_slot::<i64>(EnumVal::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_union_type(&mut self, union_type: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(EnumVal::VT_UNION_TYPE, union_type);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnumValBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnumValBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumVal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EnumVal::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnumVal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnumVal");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.field("union_type", &self.union_type());
      ds.field("documentation", &self.documentation());
      ds.field("attributes", &self.attributes());
      ds.finish()
  }
}
pub enum EnumOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Enum<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Enum<'a> {
  type Inner = Enum<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Enum<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUES: flatbuffers::VOffsetT = 6;
  pub const VT_IS_UNION: flatbuffers::VOffsetT = 8;
  pub const VT_UNDERLYING_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
  pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 14;
  pub const VT_DECLARATION_FILE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Enum { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnumArgs<'args>
  ) -> flatbuffers::WIPOffset<Enum<'bldr>> {
    let mut builder = EnumBuilder::new(_fbb);
    if let Some(x) = args.declaration_file { builder.add_declaration_file(x); }
    if let Some(x) = args.documentation { builder.add_documentation(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.underlying_type { builder.add_underlying_type(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_is_union(args.is_union);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Enum::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Enum) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal>>>>(Enum::VT_VALUES, None).unwrap()}
  }
  #[inline]
  pub fn is_union(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Enum::VT_IS_UNION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn underlying_type(&self) -> Type<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(Enum::VT_UNDERLYING_TYPE, None).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Enum::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Enum::VT_DOCUMENTATION, None)}
  }
  /// File that this Enum is declared in.
  #[inline]
  pub fn declaration_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Enum::VT_DECLARATION_FILE, None)}
  }
}

impl flatbuffers::Verifiable for Enum<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumVal>>>>("values", Self::VT_VALUES, true)?
     .visit_field::<bool>("is_union", Self::VT_IS_UNION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("underlying_type", Self::VT_UNDERLYING_TYPE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("documentation", Self::VT_DOCUMENTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("declaration_file", Self::VT_DECLARATION_FILE, false)?
     .finish();
    Ok(())
  }
}
pub struct EnumArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal<'a>>>>>,
    pub is_union: bool,
    pub underlying_type: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub declaration_file: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnumArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnumArgs {
      name: None, // required field
      values: None, // required field
      is_union: false,
      underlying_type: None, // required field
      attributes: None,
      documentation: None,
      declaration_file: None,
    }
  }
}

pub struct EnumBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnumBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_NAME, name);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumVal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_VALUES, values);
  }
  #[inline]
  pub fn add_is_union(&mut self, is_union: bool) {
    self.fbb_.push_slot::<bool>(Enum::VT_IS_UNION, is_union, false);
  }
  #[inline]
  pub fn add_underlying_type(&mut self, underlying_type: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(Enum::VT_UNDERLYING_TYPE, underlying_type);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn add_declaration_file(&mut self, declaration_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_DECLARATION_FILE, declaration_file);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnumBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnumBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Enum<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Enum::VT_NAME,"name");
    self.fbb_.required(o, Enum::VT_VALUES,"values");
    self.fbb_.required(o, Enum::VT_UNDERLYING_TYPE,"underlying_type");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Enum<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Enum");
      ds.field("name", &self.name());
      ds.field("values", &self.values());
      ds.field("is_union", &self.is_union());
      ds.field("underlying_type", &self.underlying_type());
      ds.field("attributes", &self.attributes());
      ds.field("documentation", &self.documentation());
      ds.field("declaration_file", &self.declaration_file());
      ds.finish()
  }
}
pub enum FieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Field<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Field<'a> {
  type Inner = Field<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Field<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 10;
  pub const VT_DEFAULT_INTEGER: flatbuffers::VOffsetT = 12;
  pub const VT_DEFAULT_REAL: flatbuffers::VOffsetT = 14;
  pub const VT_DEPRECATED: flatbuffers::VOffsetT = 16;
  pub const VT_REQUIRED: flatbuffers::VOffsetT = 18;
  pub const VT_KEY: flatbuffers::VOffsetT = 20;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 22;
  pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 24;
  pub const VT_OPTIONAL: flatbuffers::VOffsetT = 26;
  pub const VT_PADDING: flatbuffers::VOffsetT = 28;
  pub const VT_OFFSET64: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Field { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FieldArgs<'args>
  ) -> flatbuffers::WIPOffset<Field<'bldr>> {
    let mut builder = FieldBuilder::new(_fbb);
    builder.add_default_real(args.default_real);
    builder.add_default_integer(args.default_integer);
    if let Some(x) = args.documentation { builder.add_documentation(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_padding(args.padding);
    builder.add_offset(args.offset);
    builder.add_id(args.id);
    builder.add_offset64(args.offset64);
    builder.add_optional(args.optional);
    builder.add_key(args.key);
    builder.add_required(args.required);
    builder.add_deprecated(args.deprecated);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Field::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Field) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn type_(&self) -> Type<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(Field::VT_TYPE_, None).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Field::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offset(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Field::VT_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn default_integer(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Field::VT_DEFAULT_INTEGER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn default_real(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Field::VT_DEFAULT_REAL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn deprecated(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Field::VT_DEPRECATED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn required(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Field::VT_REQUIRED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn key(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Field::VT_KEY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Field::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Field::VT_DOCUMENTATION, None)}
  }
  #[inline]
  pub fn optional(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Field::VT_OPTIONAL, Some(false)).unwrap()}
  }
  /// Number of padding octets to always add after this field. Structs only.
  #[inline]
  pub fn padding(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Field::VT_PADDING, Some(0)).unwrap()}
  }
  /// If the field uses 64-bit offsets.
  #[inline]
  pub fn offset64(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Field::VT_OFFSET64, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Field<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("type_", Self::VT_TYPE_, true)?
     .visit_field::<u16>("id", Self::VT_ID, false)?
     .visit_field::<u16>("offset", Self::VT_OFFSET, false)?
     .visit_field::<i64>("default_integer", Self::VT_DEFAULT_INTEGER, false)?
     .visit_field::<f64>("default_real", Self::VT_DEFAULT_REAL, false)?
     .visit_field::<bool>("deprecated", Self::VT_DEPRECATED, false)?
     .visit_field::<bool>("required", Self::VT_REQUIRED, false)?
     .visit_field::<bool>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("documentation", Self::VT_DOCUMENTATION, false)?
     .visit_field::<bool>("optional", Self::VT_OPTIONAL, false)?
     .visit_field::<u16>("padding", Self::VT_PADDING, false)?
     .visit_field::<bool>("offset64", Self::VT_OFFSET64, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub id: u16,
    pub offset: u16,
    pub default_integer: i64,
    pub default_real: f64,
    pub deprecated: bool,
    pub required: bool,
    pub key: bool,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub optional: bool,
    pub padding: u16,
    pub offset64: bool,
}
impl<'a> Default for FieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldArgs {
      name: None, // required field
      type_: None, // required field
      id: 0,
      offset: 0,
      default_integer: 0,
      default_real: 0.0,
      deprecated: false,
      required: false,
      key: false,
      attributes: None,
      documentation: None,
      optional: false,
      padding: 0,
      offset64: false,
    }
  }
}

pub struct FieldBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FieldBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(Field::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(Field::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: u16) {
    self.fbb_.push_slot::<u16>(Field::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn add_default_integer(&mut self, default_integer: i64) {
    self.fbb_.push_slot::<i64>(Field::VT_DEFAULT_INTEGER, default_integer, 0);
  }
  #[inline]
  pub fn add_default_real(&mut self, default_real: f64) {
    self.fbb_.push_slot::<f64>(Field::VT_DEFAULT_REAL, default_real, 0.0);
  }
  #[inline]
  pub fn add_deprecated(&mut self, deprecated: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_DEPRECATED, deprecated, false);
  }
  #[inline]
  pub fn add_required(&mut self, required: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_REQUIRED, required, false);
  }
  #[inline]
  pub fn add_key(&mut self, key: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_KEY, key, false);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn add_optional(&mut self, optional: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_OPTIONAL, optional, false);
  }
  #[inline]
  pub fn add_padding(&mut self, padding: u16) {
    self.fbb_.push_slot::<u16>(Field::VT_PADDING, padding, 0);
  }
  #[inline]
  pub fn add_offset64(&mut self, offset64: bool) {
    self.fbb_.push_slot::<bool>(Field::VT_OFFSET64, offset64, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FieldBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Field::VT_NAME,"name");
    self.fbb_.required(o, Field::VT_TYPE_,"type_");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Field<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Field");
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("id", &self.id());
      ds.field("offset", &self.offset());
      ds.field("default_integer", &self.default_integer());
      ds.field("default_real", &self.default_real());
      ds.field("deprecated", &self.deprecated());
      ds.field("required", &self.required());
      ds.field("key", &self.key());
      ds.field("attributes", &self.attributes());
      ds.field("documentation", &self.documentation());
      ds.field("optional", &self.optional());
      ds.field("padding", &self.padding());
      ds.field("offset64", &self.offset64());
      ds.finish()
  }
}
pub enum ObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Object<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Object<'a> {
  type Inner = Object<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Object<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_FIELDS: flatbuffers::VOffsetT = 6;
  pub const VT_IS_STRUCT: flatbuffers::VOffsetT = 8;
  pub const VT_MINALIGN: flatbuffers::VOffsetT = 10;
  pub const VT_BYTESIZE: flatbuffers::VOffsetT = 12;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 14;
  pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 16;
  pub const VT_DECLARATION_FILE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Object { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<Object<'bldr>> {
    let mut builder = ObjectBuilder::new(_fbb);
    if let Some(x) = args.declaration_file { builder.add_declaration_file(x); }
    if let Some(x) = args.documentation { builder.add_documentation(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    builder.add_bytesize(args.bytesize);
    builder.add_minalign(args.minalign);
    if let Some(x) = args.fields { builder.add_fields(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_is_struct(args.is_struct);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Object::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Object) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field>>>>(Object::VT_FIELDS, None).unwrap()}
  }
  #[inline]
  pub fn is_struct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Object::VT_IS_STRUCT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn minalign(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Object::VT_MINALIGN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn bytesize(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Object::VT_BYTESIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Object::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Object::VT_DOCUMENTATION, None)}
  }
  /// File that this Object is declared in.
  #[inline]
  pub fn declaration_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Object::VT_DECLARATION_FILE, None)}
  }
}

impl flatbuffers::Verifiable for Object<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Field>>>>("fields", Self::VT_FIELDS, true)?
     .visit_field::<bool>("is_struct", Self::VT_IS_STRUCT, false)?
     .visit_field::<i32>("minalign", Self::VT_MINALIGN, false)?
     .visit_field::<i32>("bytesize", Self::VT_BYTESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("documentation", Self::VT_DOCUMENTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("declaration_file", Self::VT_DECLARATION_FILE, false)?
     .finish();
    Ok(())
  }
}
pub struct ObjectArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>>>,
    pub is_struct: bool,
    pub minalign: i32,
    pub bytesize: i32,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub declaration_file: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    ObjectArgs {
      name: None, // required field
      fields: None, // required field
      is_struct: false,
      minalign: 0,
      bytesize: 0,
      attributes: None,
      documentation: None,
      declaration_file: None,
    }
  }
}

pub struct ObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_NAME, name);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Field<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_FIELDS, fields);
  }
  #[inline]
  pub fn add_is_struct(&mut self, is_struct: bool) {
    self.fbb_.push_slot::<bool>(Object::VT_IS_STRUCT, is_struct, false);
  }
  #[inline]
  pub fn add_minalign(&mut self, minalign: i32) {
    self.fbb_.push_slot::<i32>(Object::VT_MINALIGN, minalign, 0);
  }
  #[inline]
  pub fn add_bytesize(&mut self, bytesize: i32) {
    self.fbb_.push_slot::<i32>(Object::VT_BYTESIZE, bytesize, 0);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn add_declaration_file(&mut self, declaration_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_DECLARATION_FILE, declaration_file);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Object<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Object::VT_NAME,"name");
    self.fbb_.required(o, Object::VT_FIELDS,"fields");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Object<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Object");
      ds.field("name", &self.name());
      ds.field("fields", &self.fields());
      ds.field("is_struct", &self.is_struct());
      ds.field("minalign", &self.minalign());
      ds.field("bytesize", &self.bytesize());
      ds.field("attributes", &self.attributes());
      ds.field("documentation", &self.documentation());
      ds.field("declaration_file", &self.declaration_file());
      ds.finish()
  }
}
pub enum RPCCallOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RPCCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RPCCall<'a> {
  type Inner = RPCCall<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RPCCall<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_REQUEST: flatbuffers::VOffsetT = 6;
  pub const VT_RESPONSE: flatbuffers::VOffsetT = 8;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
  pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RPCCall { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RPCCallArgs<'args>
  ) -> flatbuffers::WIPOffset<RPCCall<'bldr>> {
    let mut builder = RPCCallBuilder::new(_fbb);
    if let Some(x) = args.documentation { builder.add_documentation(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.response { builder.add_response(x); }
    if let Some(x) = args.request { builder.add_request(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RPCCall::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &RPCCall) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn request(&self) -> Object<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Object>>(RPCCall::VT_REQUEST, None).unwrap()}
  }
  #[inline]
  pub fn response(&self) -> Object<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Object>>(RPCCall::VT_RESPONSE, None).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(RPCCall::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RPCCall::VT_DOCUMENTATION, None)}
  }
}

impl flatbuffers::Verifiable for RPCCall<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Object>>("request", Self::VT_REQUEST, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<Object>>("response", Self::VT_RESPONSE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("documentation", Self::VT_DOCUMENTATION, false)?
     .finish();
    Ok(())
  }
}
pub struct RPCCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub request: Option<flatbuffers::WIPOffset<Object<'a>>>,
    pub response: Option<flatbuffers::WIPOffset<Object<'a>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for RPCCallArgs<'a> {
  #[inline]
  fn default() -> Self {
    RPCCallArgs {
      name: None, // required field
      request: None, // required field
      response: None, // required field
      attributes: None,
      documentation: None,
    }
  }
}

pub struct RPCCallBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RPCCallBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_request(&mut self, request: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(RPCCall::VT_REQUEST, request);
  }
  #[inline]
  pub fn add_response(&mut self, response: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(RPCCall::VT_RESPONSE, response);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RPCCallBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RPCCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RPCCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RPCCall::VT_NAME,"name");
    self.fbb_.required(o, RPCCall::VT_REQUEST,"request");
    self.fbb_.required(o, RPCCall::VT_RESPONSE,"response");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RPCCall<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RPCCall");
      ds.field("name", &self.name());
      ds.field("request", &self.request());
      ds.field("response", &self.response());
      ds.field("attributes", &self.attributes());
      ds.field("documentation", &self.documentation());
      ds.finish()
  }
}
pub enum ServiceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Service<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Service<'a> {
  type Inner = Service<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Service<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_CALLS: flatbuffers::VOffsetT = 6;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 8;
  pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 10;
  pub const VT_DECLARATION_FILE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Service { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ServiceArgs<'args>
  ) -> flatbuffers::WIPOffset<Service<'bldr>> {
    let mut builder = ServiceBuilder::new(_fbb);
    if let Some(x) = args.declaration_file { builder.add_declaration_file(x); }
    if let Some(x) = args.documentation { builder.add_documentation(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.calls { builder.add_calls(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Service) -> bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.name();
    key.cmp(val)
  }
  #[inline]
  pub fn calls(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall>>>>(Service::VT_CALLS, None)}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>>>(Service::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn documentation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Service::VT_DOCUMENTATION, None)}
  }
  /// File that this Service is declared in.
  #[inline]
  pub fn declaration_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_DECLARATION_FILE, None)}
  }
}

impl flatbuffers::Verifiable for Service<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RPCCall>>>>("calls", Self::VT_CALLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("documentation", Self::VT_DOCUMENTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("declaration_file", Self::VT_DECLARATION_FILE, false)?
     .finish();
    Ok(())
  }
}
pub struct ServiceArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub calls: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall<'a>>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub documentation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub declaration_file: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ServiceArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServiceArgs {
      name: None, // required field
      calls: None,
      attributes: None,
      documentation: None,
      declaration_file: None,
    }
  }
}

pub struct ServiceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServiceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_NAME, name);
  }
  #[inline]
  pub fn add_calls(&mut self, calls: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RPCCall<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_CALLS, calls);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_documentation(&mut self, documentation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_DOCUMENTATION, documentation);
  }
  #[inline]
  pub fn add_declaration_file(&mut self, declaration_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_DECLARATION_FILE, declaration_file);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ServiceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ServiceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Service<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Service::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Service<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Service");
      ds.field("name", &self.name());
      ds.field("calls", &self.calls());
      ds.field("attributes", &self.attributes());
      ds.field("documentation", &self.documentation());
      ds.field("declaration_file", &self.declaration_file());
      ds.finish()
  }
}
pub enum SchemaFileOffset {}
#[derive(Copy, Clone, PartialEq)]

/// File specific information.
/// Symbols declared within a file may be recovered by iterating over all
/// symbols and examining the `declaration_file` field.
pub struct SchemaFile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SchemaFile<'a> {
  type Inner = SchemaFile<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SchemaFile<'a> {
  pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
  pub const VT_INCLUDED_FILENAMES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SchemaFile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SchemaFileArgs<'args>
  ) -> flatbuffers::WIPOffset<SchemaFile<'bldr>> {
    let mut builder = SchemaFileBuilder::new(_fbb);
    if let Some(x) = args.included_filenames { builder.add_included_filenames(x); }
    if let Some(x) = args.filename { builder.add_filename(x); }
    builder.finish()
  }


  /// Filename, relative to project root.
  #[inline]
  pub fn filename(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SchemaFile::VT_FILENAME, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &SchemaFile) -> bool {
    self.filename() < o.filename()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.filename();
    key.cmp(val)
  }
  /// Names of included files, relative to project root.
  #[inline]
  pub fn included_filenames(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SchemaFile::VT_INCLUDED_FILENAMES, None)}
  }
}

impl flatbuffers::Verifiable for SchemaFile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("filename", Self::VT_FILENAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("included_filenames", Self::VT_INCLUDED_FILENAMES, false)?
     .finish();
    Ok(())
  }
}
pub struct SchemaFileArgs<'a> {
    pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub included_filenames: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SchemaFileArgs<'a> {
  #[inline]
  fn default() -> Self {
    SchemaFileArgs {
      filename: None, // required field
      included_filenames: None,
    }
  }
}

pub struct SchemaFileBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SchemaFileBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SchemaFile::VT_FILENAME, filename);
  }
  #[inline]
  pub fn add_included_filenames(&mut self, included_filenames: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SchemaFile::VT_INCLUDED_FILENAMES, included_filenames);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SchemaFileBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SchemaFileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SchemaFile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SchemaFile::VT_FILENAME,"filename");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SchemaFile<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SchemaFile");
      ds.field("filename", &self.filename());
      ds.field("included_filenames", &self.included_filenames());
      ds.finish()
  }
}
pub enum SchemaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Schema<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Schema<'a> {
  type Inner = Schema<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Schema<'a> {
  pub const VT_OBJECTS: flatbuffers::VOffsetT = 4;
  pub const VT_ENUMS: flatbuffers::VOffsetT = 6;
  pub const VT_FILE_IDENT: flatbuffers::VOffsetT = 8;
  pub const VT_FILE_EXT: flatbuffers::VOffsetT = 10;
  pub const VT_ROOT_TABLE: flatbuffers::VOffsetT = 12;
  pub const VT_SERVICES: flatbuffers::VOffsetT = 14;
  pub const VT_ADVANCED_FEATURES: flatbuffers::VOffsetT = 16;
  pub const VT_FBS_FILES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Schema { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SchemaArgs<'args>
  ) -> flatbuffers::WIPOffset<Schema<'bldr>> {
    let mut builder = SchemaBuilder::new(_fbb);
    builder.add_advanced_features(args.advanced_features);
    if let Some(x) = args.fbs_files { builder.add_fbs_files(x); }
    if let Some(x) = args.services { builder.add_services(x); }
    if let Some(x) = args.root_table { builder.add_root_table(x); }
    if let Some(x) = args.file_ext { builder.add_file_ext(x); }
    if let Some(x) = args.file_ident { builder.add_file_ident(x); }
    if let Some(x) = args.enums { builder.add_enums(x); }
    if let Some(x) = args.objects { builder.add_objects(x); }
    builder.finish()
  }


  #[inline]
  pub fn objects(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object>>>>(Schema::VT_OBJECTS, None).unwrap()}
  }
  #[inline]
  pub fn enums(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum>>>>(Schema::VT_ENUMS, None).unwrap()}
  }
  #[inline]
  pub fn file_ident(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILE_IDENT, None)}
  }
  #[inline]
  pub fn file_ext(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILE_EXT, None)}
  }
  #[inline]
  pub fn root_table(&self) -> Option<Object<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Object>>(Schema::VT_ROOT_TABLE, None)}
  }
  #[inline]
  pub fn services(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service>>>>(Schema::VT_SERVICES, None)}
  }
  #[inline]
  pub fn advanced_features(&self) -> AdvancedFeatures {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AdvancedFeatures>(Schema::VT_ADVANCED_FEATURES, Some(Default::default())).unwrap()}
  }
  /// All the files used in this compilation. Files are relative to where
  /// flatc was invoked.
  #[inline]
  pub fn fbs_files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SchemaFile<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SchemaFile>>>>(Schema::VT_FBS_FILES, None)}
  }
}

impl flatbuffers::Verifiable for Schema<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Object>>>>("objects", Self::VT_OBJECTS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Enum>>>>("enums", Self::VT_ENUMS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_ident", Self::VT_FILE_IDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_ext", Self::VT_FILE_EXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Object>>("root_table", Self::VT_ROOT_TABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Service>>>>("services", Self::VT_SERVICES, false)?
     .visit_field::<AdvancedFeatures>("advanced_features", Self::VT_ADVANCED_FEATURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SchemaFile>>>>("fbs_files", Self::VT_FBS_FILES, false)?
     .finish();
    Ok(())
  }
}
pub struct SchemaArgs<'a> {
    pub objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object<'a>>>>>,
    pub enums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum<'a>>>>>,
    pub file_ident: Option<flatbuffers::WIPOffset<&'a str>>,
    pub file_ext: Option<flatbuffers::WIPOffset<&'a str>>,
    pub root_table: Option<flatbuffers::WIPOffset<Object<'a>>>,
    pub services: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>>>,
    pub advanced_features: AdvancedFeatures,
    pub fbs_files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SchemaFile<'a>>>>>,
}
impl<'a> Default for SchemaArgs<'a> {
  #[inline]
  fn default() -> Self {
    SchemaArgs {
      objects: None, // required field
      enums: None, // required field
      file_ident: None,
      file_ext: None,
      root_table: None,
      services: None,
      advanced_features: Default::default(),
      fbs_files: None,
    }
  }
}

pub struct SchemaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SchemaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_objects(&mut self, objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Object<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_OBJECTS, objects);
  }
  #[inline]
  pub fn add_enums(&mut self, enums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Enum<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_ENUMS, enums);
  }
  #[inline]
  pub fn add_file_ident(&mut self, file_ident: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILE_IDENT, file_ident);
  }
  #[inline]
  pub fn add_file_ext(&mut self, file_ext: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILE_EXT, file_ext);
  }
  #[inline]
  pub fn add_root_table(&mut self, root_table: flatbuffers::WIPOffset<Object<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Object>>(Schema::VT_ROOT_TABLE, root_table);
  }
  #[inline]
  pub fn add_services(&mut self, services: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Service<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_SERVICES, services);
  }
  #[inline]
  pub fn add_advanced_features(&mut self, advanced_features: AdvancedFeatures) {
    self.fbb_.push_slot::<AdvancedFeatures>(Schema::VT_ADVANCED_FEATURES, advanced_features, Default::default());
  }
  #[inline]
  pub fn add_fbs_files(&mut self, fbs_files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SchemaFile<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FBS_FILES, fbs_files);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SchemaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SchemaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Schema<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Schema::VT_OBJECTS,"objects");
    self.fbb_.required(o, Schema::VT_ENUMS,"enums");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Schema<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Schema");
      ds.field("objects", &self.objects());
      ds.field("enums", &self.enums());
      ds.field("file_ident", &self.file_ident());
      ds.field("file_ext", &self.file_ext());
      ds.field("root_table", &self.root_table());
      ds.field("services", &self.services());
      ds.field("advanced_features", &self.advanced_features());
      ds.field("fbs_files", &self.fbs_files());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Schema`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_schema_unchecked`.
pub fn root_as_schema(buf: &[u8]) -> Result<Schema, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Schema>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Schema` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_schema_unchecked`.
pub fn size_prefixed_root_as_schema(buf: &[u8]) -> Result<Schema, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Schema>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Schema` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_schema_unchecked`.
pub fn root_as_schema_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Schema<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Schema<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Schema` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_schema_unchecked`.
pub fn size_prefixed_root_as_schema_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Schema<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Schema<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Schema and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Schema`.
pub unsafe fn root_as_schema_unchecked(buf: &[u8]) -> Schema {
  flatbuffers::root_unchecked::<Schema>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Schema and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Schema`.
pub unsafe fn size_prefixed_root_as_schema_unchecked(buf: &[u8]) -> Schema {
  flatbuffers::size_prefixed_root_unchecked::<Schema>(buf)
}
pub const SCHEMA_IDENTIFIER: &str = "BFBS";

#[inline]
pub fn schema_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SCHEMA_IDENTIFIER, false)
}

#[inline]
pub fn schema_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SCHEMA_IDENTIFIER, true)
}

pub const SCHEMA_EXTENSION: &str = "bfbs";

#[inline]
pub fn finish_schema_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Schema<'a>>) {
  fbb.finish(root, Some(SCHEMA_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_schema_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Schema<'a>>) {
  fbb.finish_size_prefixed(root, Some(SCHEMA_IDENTIFIER));
}
}  // pub mod reflection


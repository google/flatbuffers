// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod reflection {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_BASE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_BASE_TYPE: i8 = 19;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_BASE_TYPE: [BaseType; 20] = [
        BaseType::None,
        BaseType::UType,
        BaseType::Bool,
        BaseType::Byte,
        BaseType::UByte,
        BaseType::Short,
        BaseType::UShort,
        BaseType::Int,
        BaseType::UInt,
        BaseType::Long,
        BaseType::ULong,
        BaseType::Float,
        BaseType::Double,
        BaseType::String,
        BaseType::Vector,
        BaseType::Obj,
        BaseType::Union,
        BaseType::Array,
        BaseType::Vector64,
        BaseType::MaxBaseType,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct BaseType(pub i8);
    #[allow(non_upper_case_globals)]
    impl BaseType {
        pub const None: Self = Self(0);
        pub const UType: Self = Self(1);
        pub const Bool: Self = Self(2);
        pub const Byte: Self = Self(3);
        pub const UByte: Self = Self(4);
        pub const Short: Self = Self(5);
        pub const UShort: Self = Self(6);
        pub const Int: Self = Self(7);
        pub const UInt: Self = Self(8);
        pub const Long: Self = Self(9);
        pub const ULong: Self = Self(10);
        pub const Float: Self = Self(11);
        pub const Double: Self = Self(12);
        pub const String: Self = Self(13);
        pub const Vector: Self = Self(14);
        pub const Obj: Self = Self(15);
        pub const Union: Self = Self(16);
        pub const Array: Self = Self(17);
        pub const Vector64: Self = Self(18);
        pub const MaxBaseType: Self = Self(19);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 19;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::None,
            Self::UType,
            Self::Bool,
            Self::Byte,
            Self::UByte,
            Self::Short,
            Self::UShort,
            Self::Int,
            Self::UInt,
            Self::Long,
            Self::ULong,
            Self::Float,
            Self::Double,
            Self::String,
            Self::Vector,
            Self::Obj,
            Self::Union,
            Self::Array,
            Self::Vector64,
            Self::MaxBaseType,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::None => Some("None"),
                Self::UType => Some("UType"),
                Self::Bool => Some("Bool"),
                Self::Byte => Some("Byte"),
                Self::UByte => Some("UByte"),
                Self::Short => Some("Short"),
                Self::UShort => Some("UShort"),
                Self::Int => Some("Int"),
                Self::UInt => Some("UInt"),
                Self::Long => Some("Long"),
                Self::ULong => Some("ULong"),
                Self::Float => Some("Float"),
                Self::Double => Some("Double"),
                Self::String => Some("String"),
                Self::Vector => Some("Vector"),
                Self::Obj => Some("Obj"),
                Self::Union => Some("Union"),
                Self::Array => Some("Array"),
                Self::Vector64 => Some("Vector64"),
                Self::MaxBaseType => Some("MaxBaseType"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for BaseType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for BaseType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for BaseType {
        type Output = BaseType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for BaseType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for BaseType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for BaseType {}
    #[allow(non_upper_case_globals)]
    mod bitflags_advanced_features {
        flatbuffers::bitflags::bitflags! {
          /// New schema language features that are not supported by old code generators.
          #[derive(Default)]
          pub struct AdvancedFeatures: u64 {
            const AdvancedArrayFeatures = 1;
            const AdvancedUnionFeatures = 2;
            const OptionalScalars = 4;
            const DefaultVectorsAndStrings = 8;
          }
        }
    }
    pub use self::bitflags_advanced_features::AdvancedFeatures;

    impl<'a> flatbuffers::Follow<'a> for AdvancedFeatures {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u64>(buf, loc);
            // Safety:
            // This is safe because we know bitflags is implemented with a repr transparent uint of the correct size.
            // from_bits_unchecked will be replaced by an equivalent but safe from_bits_retain in bitflags 2.0
            // https://github.com/bitflags/bitflags/issues/262
            Self::from_bits_unchecked(b)
        }
    }

    impl flatbuffers::Push for AdvancedFeatures {
        type Output = AdvancedFeatures;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u64>(dst, self.bits());
        }
    }

    impl flatbuffers::EndianScalar for AdvancedFeatures {
        type Scalar = u64;
        #[inline]
        fn to_little_endian(self) -> u64 {
            self.bits().to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u64) -> Self {
            let b = u64::from_le(v);
            // Safety:
            // This is safe because we know bitflags is implemented with a repr transparent uint of the correct size.
            // from_bits_unchecked will be replaced by an equivalent but safe from_bits_retain in bitflags 2.0
            // https://github.com/bitflags/bitflags/issues/262
            unsafe { Self::from_bits_unchecked(b) }
        }
    }

    impl<'a> flatbuffers::Verifiable for AdvancedFeatures {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u64::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for AdvancedFeatures {}
    pub enum TypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Type<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Type<'a> {
        type Inner = Type<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Type<'a> {
        pub const VT_BASE_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;
        pub const VT_INDEX: flatbuffers::VOffsetT = 8;
        pub const VT_FIXED_LENGTH: flatbuffers::VOffsetT = 10;
        pub const VT_BASE_SIZE: flatbuffers::VOffsetT = 12;
        pub const VT_ELEMENT_SIZE: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Type { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TypeArgs,
        ) -> flatbuffers::WIPOffset<Type<'bldr>> {
            let mut builder = TypeBuilder::new(_fbb);
            builder.add_element_size(args.element_size);
            builder.add_base_size(args.base_size);
            builder.add_index(args.index);
            builder.add_fixed_length(args.fixed_length);
            builder.add_element(args.element);
            builder.add_base_type(args.base_type);
            builder.finish()
        }

        #[inline]
        pub fn base_type(&self) -> BaseType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<BaseType>(Type::VT_BASE_TYPE, Some(BaseType::None))
                    .unwrap()
            }
        }
        #[inline]
        pub fn element(&self) -> BaseType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<BaseType>(Type::VT_ELEMENT, Some(BaseType::None))
                    .unwrap()
            }
        }
        #[inline]
        pub fn index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(Type::VT_INDEX, Some(-1)).unwrap() }
        }
        #[inline]
        pub fn fixed_length(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u16>(Type::VT_FIXED_LENGTH, Some(0))
                    .unwrap()
            }
        }
        /// The size (octets) of the `base_type` field.
        #[inline]
        pub fn base_size(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Type::VT_BASE_SIZE, Some(4)).unwrap() }
        }
        /// The size (octets) of the `element` field, if present.
        #[inline]
        pub fn element_size(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Type::VT_ELEMENT_SIZE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Type<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<BaseType>("base_type", Self::VT_BASE_TYPE, false)?
                .visit_field::<BaseType>("element", Self::VT_ELEMENT, false)?
                .visit_field::<i32>("index", Self::VT_INDEX, false)?
                .visit_field::<u16>("fixed_length", Self::VT_FIXED_LENGTH, false)?
                .visit_field::<u32>("base_size", Self::VT_BASE_SIZE, false)?
                .visit_field::<u32>("element_size", Self::VT_ELEMENT_SIZE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TypeArgs {
        pub base_type: BaseType,
        pub element: BaseType,
        pub index: i32,
        pub fixed_length: u16,
        pub base_size: u32,
        pub element_size: u32,
    }
    impl<'a> Default for TypeArgs {
        #[inline]
        fn default() -> Self {
            TypeArgs {
                base_type: BaseType::None,
                element: BaseType::None,
                index: -1,
                fixed_length: 0,
                base_size: 4,
                element_size: 0,
            }
        }
    }

    pub struct TypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_base_type(&mut self, base_type: BaseType) {
            self.fbb_
                .push_slot::<BaseType>(Type::VT_BASE_TYPE, base_type, BaseType::None);
        }
        #[inline]
        pub fn add_element(&mut self, element: BaseType) {
            self.fbb_
                .push_slot::<BaseType>(Type::VT_ELEMENT, element, BaseType::None);
        }
        #[inline]
        pub fn add_index(&mut self, index: i32) {
            self.fbb_.push_slot::<i32>(Type::VT_INDEX, index, -1);
        }
        #[inline]
        pub fn add_fixed_length(&mut self, fixed_length: u16) {
            self.fbb_
                .push_slot::<u16>(Type::VT_FIXED_LENGTH, fixed_length, 0);
        }
        #[inline]
        pub fn add_base_size(&mut self, base_size: u32) {
            self.fbb_.push_slot::<u32>(Type::VT_BASE_SIZE, base_size, 4);
        }
        #[inline]
        pub fn add_element_size(&mut self, element_size: u32) {
            self.fbb_
                .push_slot::<u32>(Type::VT_ELEMENT_SIZE, element_size, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Type<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Type<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Type");
            ds.field("base_type", &self.base_type());
            ds.field("element", &self.element());
            ds.field("index", &self.index());
            ds.field("fixed_length", &self.fixed_length());
            ds.field("base_size", &self.base_size());
            ds.field("element_size", &self.element_size());
            ds.finish()
        }
    }
    pub enum KeyValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct KeyValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {
        type Inner = KeyValue<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> KeyValue<'a> {
        pub const VT_KEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            KeyValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args KeyValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {
            let mut builder = KeyValueBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.key {
                builder.add_key(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn key(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &KeyValue) -> bool {
            self.key() < o.key()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.key();
            key.cmp(val)
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for KeyValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct KeyValueArgs<'a> {
        pub key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for KeyValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            KeyValueArgs {
                key: None, // required field
                value: None,
            }
        }
    }

    pub struct KeyValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> KeyValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            KeyValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, KeyValue::VT_KEY, "key");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for KeyValue<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("KeyValue");
            ds.field("key", &self.key());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum EnumValOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct EnumVal<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for EnumVal<'a> {
        type Inner = EnumVal<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> EnumVal<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_UNION_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 12;
        pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            EnumVal { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EnumValArgs<'args>,
        ) -> flatbuffers::WIPOffset<EnumVal<'bldr>> {
            let mut builder = EnumValBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.attributes {
                builder.add_attributes(x);
            }
            if let Some(x) = args.documentation {
                builder.add_documentation(x);
            }
            if let Some(x) = args.union_type {
                builder.add_union_type(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(EnumVal::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(EnumVal::VT_VALUE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &EnumVal) -> bool {
            self.value() < o.value()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: i64) -> ::core::cmp::Ordering {
            let key = self.value();
            key.cmp(&val)
        }
        #[inline]
        pub fn union_type(&self) -> Option<Type<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Type>>(EnumVal::VT_UNION_TYPE, None)
            }
        }
        #[inline]
        pub fn documentation(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(EnumVal::VT_DOCUMENTATION, None)
            }
        }
        #[inline]
        pub fn attributes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>(EnumVal::VT_ATTRIBUTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for EnumVal<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<i64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Type>>(
                    "union_type",
                    Self::VT_UNION_TYPE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("documentation", Self::VT_DOCUMENTATION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>("attributes", Self::VT_ATTRIBUTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct EnumValArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: i64,
        pub union_type: Option<flatbuffers::WIPOffset<Type<'a>>>,
        pub documentation: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub attributes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
            >,
        >,
    }
    impl<'a> Default for EnumValArgs<'a> {
        #[inline]
        fn default() -> Self {
            EnumValArgs {
                name: None, // required field
                value: 0,
                union_type: None,
                documentation: None,
                attributes: None,
            }
        }
    }

    pub struct EnumValBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EnumValBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_NAME, name);
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_.push_slot::<i64>(EnumVal::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_union_type(&mut self, union_type: flatbuffers::WIPOffset<Type<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(
                EnumVal::VT_UNION_TYPE,
                union_type,
            );
        }
        #[inline]
        pub fn add_documentation(
            &mut self,
            documentation: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                EnumVal::VT_DOCUMENTATION,
                documentation,
            );
        }
        #[inline]
        pub fn add_attributes(
            &mut self,
            attributes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(EnumVal::VT_ATTRIBUTES, attributes);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnumValBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EnumValBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<EnumVal<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, EnumVal::VT_NAME, "name");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for EnumVal<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("EnumVal");
            ds.field("name", &self.name());
            ds.field("value", &self.value());
            ds.field("union_type", &self.union_type());
            ds.field("documentation", &self.documentation());
            ds.field("attributes", &self.attributes());
            ds.finish()
        }
    }
    pub enum EnumOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Enum<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Enum<'a> {
        type Inner = Enum<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Enum<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUES: flatbuffers::VOffsetT = 6;
        pub const VT_IS_UNION: flatbuffers::VOffsetT = 8;
        pub const VT_UNDERLYING_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
        pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 14;
        pub const VT_DECLARATION_FILE: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Enum { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EnumArgs<'args>,
        ) -> flatbuffers::WIPOffset<Enum<'bldr>> {
            let mut builder = EnumBuilder::new(_fbb);
            if let Some(x) = args.declaration_file {
                builder.add_declaration_file(x);
            }
            if let Some(x) = args.documentation {
                builder.add_documentation(x);
            }
            if let Some(x) = args.attributes {
                builder.add_attributes(x);
            }
            if let Some(x) = args.underlying_type {
                builder.add_underlying_type(x);
            }
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_is_union(args.is_union);
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Enum::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &Enum) -> bool {
            self.name() < o.name()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.name();
            key.cmp(val)
        }
        #[inline]
        pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal>>,
                    >>(Enum::VT_VALUES, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn is_union(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Enum::VT_IS_UNION, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn underlying_type(&self) -> Type<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Type>>(Enum::VT_UNDERLYING_TYPE, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn attributes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>(Enum::VT_ATTRIBUTES, None)
            }
        }
        #[inline]
        pub fn documentation(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Enum::VT_DOCUMENTATION, None)
            }
        }
        /// File that this Enum is declared in.
        #[inline]
        pub fn declaration_file(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Enum::VT_DECLARATION_FILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Enum<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumVal>>,
                >>("values", Self::VT_VALUES, true)?
                .visit_field::<bool>("is_union", Self::VT_IS_UNION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Type>>(
                    "underlying_type",
                    Self::VT_UNDERLYING_TYPE,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>("attributes", Self::VT_ATTRIBUTES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("documentation", Self::VT_DOCUMENTATION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "declaration_file",
                    Self::VT_DECLARATION_FILE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct EnumArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumVal<'a>>>,
            >,
        >,
        pub is_union: bool,
        pub underlying_type: Option<flatbuffers::WIPOffset<Type<'a>>>,
        pub attributes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
            >,
        >,
        pub documentation: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub declaration_file: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for EnumArgs<'a> {
        #[inline]
        fn default() -> Self {
            EnumArgs {
                name: None,   // required field
                values: None, // required field
                is_union: false,
                underlying_type: None, // required field
                attributes: None,
                documentation: None,
                declaration_file: None,
            }
        }
    }

    pub struct EnumBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EnumBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_NAME, name);
        }
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<EnumVal<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_VALUES, values);
        }
        #[inline]
        pub fn add_is_union(&mut self, is_union: bool) {
            self.fbb_
                .push_slot::<bool>(Enum::VT_IS_UNION, is_union, false);
        }
        #[inline]
        pub fn add_underlying_type(&mut self, underlying_type: flatbuffers::WIPOffset<Type<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(
                Enum::VT_UNDERLYING_TYPE,
                underlying_type,
            );
        }
        #[inline]
        pub fn add_attributes(
            &mut self,
            attributes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Enum::VT_ATTRIBUTES, attributes);
        }
        #[inline]
        pub fn add_documentation(
            &mut self,
            documentation: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Enum::VT_DOCUMENTATION,
                documentation,
            );
        }
        #[inline]
        pub fn add_declaration_file(&mut self, declaration_file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Enum::VT_DECLARATION_FILE,
                declaration_file,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnumBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EnumBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Enum<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Enum::VT_NAME, "name");
            self.fbb_.required(o, Enum::VT_VALUES, "values");
            self.fbb_
                .required(o, Enum::VT_UNDERLYING_TYPE, "underlying_type");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Enum<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Enum");
            ds.field("name", &self.name());
            ds.field("values", &self.values());
            ds.field("is_union", &self.is_union());
            ds.field("underlying_type", &self.underlying_type());
            ds.field("attributes", &self.attributes());
            ds.field("documentation", &self.documentation());
            ds.field("declaration_file", &self.declaration_file());
            ds.finish()
        }
    }
    pub enum FieldOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Field<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Field<'a> {
        type Inner = Field<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Field<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
        pub const VT_ID: flatbuffers::VOffsetT = 8;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 10;
        pub const VT_DEFAULT_INTEGER: flatbuffers::VOffsetT = 12;
        pub const VT_DEFAULT_REAL: flatbuffers::VOffsetT = 14;
        pub const VT_DEPRECATED: flatbuffers::VOffsetT = 16;
        pub const VT_REQUIRED: flatbuffers::VOffsetT = 18;
        pub const VT_KEY: flatbuffers::VOffsetT = 20;
        pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 22;
        pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 24;
        pub const VT_OPTIONAL: flatbuffers::VOffsetT = 26;
        pub const VT_PADDING: flatbuffers::VOffsetT = 28;
        pub const VT_OFFSET64: flatbuffers::VOffsetT = 30;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Field { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FieldArgs<'args>,
        ) -> flatbuffers::WIPOffset<Field<'bldr>> {
            let mut builder = FieldBuilder::new(_fbb);
            builder.add_default_real(args.default_real);
            builder.add_default_integer(args.default_integer);
            if let Some(x) = args.documentation {
                builder.add_documentation(x);
            }
            if let Some(x) = args.attributes {
                builder.add_attributes(x);
            }
            if let Some(x) = args.type_ {
                builder.add_type_(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_padding(args.padding);
            builder.add_offset(args.offset);
            builder.add_id(args.id);
            builder.add_offset64(args.offset64);
            builder.add_optional(args.optional);
            builder.add_key(args.key);
            builder.add_required(args.required);
            builder.add_deprecated(args.deprecated);
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Field::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &Field) -> bool {
            self.name() < o.name()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.name();
            key.cmp(val)
        }
        #[inline]
        pub fn type_(&self) -> Type<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Type>>(Field::VT_TYPE_, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn id(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(Field::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn offset(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(Field::VT_OFFSET, Some(0)).unwrap() }
        }
        #[inline]
        pub fn default_integer(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(Field::VT_DEFAULT_INTEGER, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn default_real(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(Field::VT_DEFAULT_REAL, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn deprecated(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Field::VT_DEPRECATED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn required(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Field::VT_REQUIRED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn key(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<bool>(Field::VT_KEY, Some(false)).unwrap() }
        }
        #[inline]
        pub fn attributes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>(Field::VT_ATTRIBUTES, None)
            }
        }
        #[inline]
        pub fn documentation(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Field::VT_DOCUMENTATION, None)
            }
        }
        #[inline]
        pub fn optional(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Field::VT_OPTIONAL, Some(false))
                    .unwrap()
            }
        }
        /// Number of padding octets to always add after this field. Structs only.
        #[inline]
        pub fn padding(&self) -> u16 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u16>(Field::VT_PADDING, Some(0)).unwrap() }
        }
        /// If the field uses 64-bit offsets.
        #[inline]
        pub fn offset64(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Field::VT_OFFSET64, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Field<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<Type>>("type_", Self::VT_TYPE_, true)?
                .visit_field::<u16>("id", Self::VT_ID, false)?
                .visit_field::<u16>("offset", Self::VT_OFFSET, false)?
                .visit_field::<i64>("default_integer", Self::VT_DEFAULT_INTEGER, false)?
                .visit_field::<f64>("default_real", Self::VT_DEFAULT_REAL, false)?
                .visit_field::<bool>("deprecated", Self::VT_DEPRECATED, false)?
                .visit_field::<bool>("required", Self::VT_REQUIRED, false)?
                .visit_field::<bool>("key", Self::VT_KEY, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>("attributes", Self::VT_ATTRIBUTES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("documentation", Self::VT_DOCUMENTATION, false)?
                .visit_field::<bool>("optional", Self::VT_OPTIONAL, false)?
                .visit_field::<u16>("padding", Self::VT_PADDING, false)?
                .visit_field::<bool>("offset64", Self::VT_OFFSET64, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FieldArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
        pub id: u16,
        pub offset: u16,
        pub default_integer: i64,
        pub default_real: f64,
        pub deprecated: bool,
        pub required: bool,
        pub key: bool,
        pub attributes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
            >,
        >,
        pub documentation: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub optional: bool,
        pub padding: u16,
        pub offset64: bool,
    }
    impl<'a> Default for FieldArgs<'a> {
        #[inline]
        fn default() -> Self {
            FieldArgs {
                name: None,  // required field
                type_: None, // required field
                id: 0,
                offset: 0,
                default_integer: 0,
                default_real: 0.0,
                deprecated: false,
                required: false,
                key: false,
                attributes: None,
                documentation: None,
                optional: false,
                padding: 0,
                offset64: false,
            }
        }
    }

    pub struct FieldBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_NAME, name);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Type>>(Field::VT_TYPE_, type_);
        }
        #[inline]
        pub fn add_id(&mut self, id: u16) {
            self.fbb_.push_slot::<u16>(Field::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_offset(&mut self, offset: u16) {
            self.fbb_.push_slot::<u16>(Field::VT_OFFSET, offset, 0);
        }
        #[inline]
        pub fn add_default_integer(&mut self, default_integer: i64) {
            self.fbb_
                .push_slot::<i64>(Field::VT_DEFAULT_INTEGER, default_integer, 0);
        }
        #[inline]
        pub fn add_default_real(&mut self, default_real: f64) {
            self.fbb_
                .push_slot::<f64>(Field::VT_DEFAULT_REAL, default_real, 0.0);
        }
        #[inline]
        pub fn add_deprecated(&mut self, deprecated: bool) {
            self.fbb_
                .push_slot::<bool>(Field::VT_DEPRECATED, deprecated, false);
        }
        #[inline]
        pub fn add_required(&mut self, required: bool) {
            self.fbb_
                .push_slot::<bool>(Field::VT_REQUIRED, required, false);
        }
        #[inline]
        pub fn add_key(&mut self, key: bool) {
            self.fbb_.push_slot::<bool>(Field::VT_KEY, key, false);
        }
        #[inline]
        pub fn add_attributes(
            &mut self,
            attributes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_ATTRIBUTES, attributes);
        }
        #[inline]
        pub fn add_documentation(
            &mut self,
            documentation: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Field::VT_DOCUMENTATION,
                documentation,
            );
        }
        #[inline]
        pub fn add_optional(&mut self, optional: bool) {
            self.fbb_
                .push_slot::<bool>(Field::VT_OPTIONAL, optional, false);
        }
        #[inline]
        pub fn add_padding(&mut self, padding: u16) {
            self.fbb_.push_slot::<u16>(Field::VT_PADDING, padding, 0);
        }
        #[inline]
        pub fn add_offset64(&mut self, offset64: bool) {
            self.fbb_
                .push_slot::<bool>(Field::VT_OFFSET64, offset64, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FieldBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Field::VT_NAME, "name");
            self.fbb_.required(o, Field::VT_TYPE_, "type_");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Field<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Field");
            ds.field("name", &self.name());
            ds.field("type_", &self.type_());
            ds.field("id", &self.id());
            ds.field("offset", &self.offset());
            ds.field("default_integer", &self.default_integer());
            ds.field("default_real", &self.default_real());
            ds.field("deprecated", &self.deprecated());
            ds.field("required", &self.required());
            ds.field("key", &self.key());
            ds.field("attributes", &self.attributes());
            ds.field("documentation", &self.documentation());
            ds.field("optional", &self.optional());
            ds.field("padding", &self.padding());
            ds.field("offset64", &self.offset64());
            ds.finish()
        }
    }
    pub enum ObjectOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Object<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Object<'a> {
        type Inner = Object<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Object<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_FIELDS: flatbuffers::VOffsetT = 6;
        pub const VT_IS_STRUCT: flatbuffers::VOffsetT = 8;
        pub const VT_MINALIGN: flatbuffers::VOffsetT = 10;
        pub const VT_BYTESIZE: flatbuffers::VOffsetT = 12;
        pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 14;
        pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 16;
        pub const VT_DECLARATION_FILE: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Object { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ObjectArgs<'args>,
        ) -> flatbuffers::WIPOffset<Object<'bldr>> {
            let mut builder = ObjectBuilder::new(_fbb);
            if let Some(x) = args.declaration_file {
                builder.add_declaration_file(x);
            }
            if let Some(x) = args.documentation {
                builder.add_documentation(x);
            }
            if let Some(x) = args.attributes {
                builder.add_attributes(x);
            }
            builder.add_bytesize(args.bytesize);
            builder.add_minalign(args.minalign);
            if let Some(x) = args.fields {
                builder.add_fields(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_is_struct(args.is_struct);
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Object::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &Object) -> bool {
            self.name() < o.name()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.name();
            key.cmp(val)
        }
        #[inline]
        pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field>>,
                    >>(Object::VT_FIELDS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn is_struct(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Object::VT_IS_STRUCT, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn minalign(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(Object::VT_MINALIGN, Some(0)).unwrap() }
        }
        #[inline]
        pub fn bytesize(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(Object::VT_BYTESIZE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn attributes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>(Object::VT_ATTRIBUTES, None)
            }
        }
        #[inline]
        pub fn documentation(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Object::VT_DOCUMENTATION, None)
            }
        }
        /// File that this Object is declared in.
        #[inline]
        pub fn declaration_file(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Object::VT_DECLARATION_FILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Object<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Field>>,
                >>("fields", Self::VT_FIELDS, true)?
                .visit_field::<bool>("is_struct", Self::VT_IS_STRUCT, false)?
                .visit_field::<i32>("minalign", Self::VT_MINALIGN, false)?
                .visit_field::<i32>("bytesize", Self::VT_BYTESIZE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>("attributes", Self::VT_ATTRIBUTES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("documentation", Self::VT_DOCUMENTATION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "declaration_file",
                    Self::VT_DECLARATION_FILE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ObjectArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub fields: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Field<'a>>>,
            >,
        >,
        pub is_struct: bool,
        pub minalign: i32,
        pub bytesize: i32,
        pub attributes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
            >,
        >,
        pub documentation: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub declaration_file: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ObjectArgs<'a> {
        #[inline]
        fn default() -> Self {
            ObjectArgs {
                name: None,   // required field
                fields: None, // required field
                is_struct: false,
                minalign: 0,
                bytesize: 0,
                attributes: None,
                documentation: None,
                declaration_file: None,
            }
        }
    }

    pub struct ObjectBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ObjectBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_NAME, name);
        }
        #[inline]
        pub fn add_fields(
            &mut self,
            fields: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Field<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_FIELDS, fields);
        }
        #[inline]
        pub fn add_is_struct(&mut self, is_struct: bool) {
            self.fbb_
                .push_slot::<bool>(Object::VT_IS_STRUCT, is_struct, false);
        }
        #[inline]
        pub fn add_minalign(&mut self, minalign: i32) {
            self.fbb_.push_slot::<i32>(Object::VT_MINALIGN, minalign, 0);
        }
        #[inline]
        pub fn add_bytesize(&mut self, bytesize: i32) {
            self.fbb_.push_slot::<i32>(Object::VT_BYTESIZE, bytesize, 0);
        }
        #[inline]
        pub fn add_attributes(
            &mut self,
            attributes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Object::VT_ATTRIBUTES, attributes);
        }
        #[inline]
        pub fn add_documentation(
            &mut self,
            documentation: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Object::VT_DOCUMENTATION,
                documentation,
            );
        }
        #[inline]
        pub fn add_declaration_file(&mut self, declaration_file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Object::VT_DECLARATION_FILE,
                declaration_file,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObjectBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ObjectBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Object<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Object::VT_NAME, "name");
            self.fbb_.required(o, Object::VT_FIELDS, "fields");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Object<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Object");
            ds.field("name", &self.name());
            ds.field("fields", &self.fields());
            ds.field("is_struct", &self.is_struct());
            ds.field("minalign", &self.minalign());
            ds.field("bytesize", &self.bytesize());
            ds.field("attributes", &self.attributes());
            ds.field("documentation", &self.documentation());
            ds.field("declaration_file", &self.declaration_file());
            ds.finish()
        }
    }
    pub enum RPCCallOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RPCCall<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RPCCall<'a> {
        type Inner = RPCCall<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RPCCall<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_REQUEST: flatbuffers::VOffsetT = 6;
        pub const VT_RESPONSE: flatbuffers::VOffsetT = 8;
        pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
        pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RPCCall { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RPCCallArgs<'args>,
        ) -> flatbuffers::WIPOffset<RPCCall<'bldr>> {
            let mut builder = RPCCallBuilder::new(_fbb);
            if let Some(x) = args.documentation {
                builder.add_documentation(x);
            }
            if let Some(x) = args.attributes {
                builder.add_attributes(x);
            }
            if let Some(x) = args.response {
                builder.add_response(x);
            }
            if let Some(x) = args.request {
                builder.add_request(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(RPCCall::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &RPCCall) -> bool {
            self.name() < o.name()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.name();
            key.cmp(val)
        }
        #[inline]
        pub fn request(&self) -> Object<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Object>>(RPCCall::VT_REQUEST, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn response(&self) -> Object<'a> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Object>>(RPCCall::VT_RESPONSE, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn attributes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>(RPCCall::VT_ATTRIBUTES, None)
            }
        }
        #[inline]
        pub fn documentation(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(RPCCall::VT_DOCUMENTATION, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RPCCall<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<Object>>(
                    "request",
                    Self::VT_REQUEST,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Object>>(
                    "response",
                    Self::VT_RESPONSE,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>("attributes", Self::VT_ATTRIBUTES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("documentation", Self::VT_DOCUMENTATION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RPCCallArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub request: Option<flatbuffers::WIPOffset<Object<'a>>>,
        pub response: Option<flatbuffers::WIPOffset<Object<'a>>>,
        pub attributes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
            >,
        >,
        pub documentation: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for RPCCallArgs<'a> {
        #[inline]
        fn default() -> Self {
            RPCCallArgs {
                name: None,     // required field
                request: None,  // required field
                response: None, // required field
                attributes: None,
                documentation: None,
            }
        }
    }

    pub struct RPCCallBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RPCCallBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_NAME, name);
        }
        #[inline]
        pub fn add_request(&mut self, request: flatbuffers::WIPOffset<Object<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Object>>(RPCCall::VT_REQUEST, request);
        }
        #[inline]
        pub fn add_response(&mut self, response: flatbuffers::WIPOffset<Object<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Object>>(RPCCall::VT_RESPONSE, response);
        }
        #[inline]
        pub fn add_attributes(
            &mut self,
            attributes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RPCCall::VT_ATTRIBUTES, attributes);
        }
        #[inline]
        pub fn add_documentation(
            &mut self,
            documentation: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RPCCall::VT_DOCUMENTATION,
                documentation,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RPCCallBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RPCCallBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RPCCall<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, RPCCall::VT_NAME, "name");
            self.fbb_.required(o, RPCCall::VT_REQUEST, "request");
            self.fbb_.required(o, RPCCall::VT_RESPONSE, "response");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RPCCall<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RPCCall");
            ds.field("name", &self.name());
            ds.field("request", &self.request());
            ds.field("response", &self.response());
            ds.field("attributes", &self.attributes());
            ds.field("documentation", &self.documentation());
            ds.finish()
        }
    }
    pub enum ServiceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Service<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Service<'a> {
        type Inner = Service<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Service<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_CALLS: flatbuffers::VOffsetT = 6;
        pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 8;
        pub const VT_DOCUMENTATION: flatbuffers::VOffsetT = 10;
        pub const VT_DECLARATION_FILE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Service { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ServiceArgs<'args>,
        ) -> flatbuffers::WIPOffset<Service<'bldr>> {
            let mut builder = ServiceBuilder::new(_fbb);
            if let Some(x) = args.declaration_file {
                builder.add_declaration_file(x);
            }
            if let Some(x) = args.documentation {
                builder.add_documentation(x);
            }
            if let Some(x) = args.attributes {
                builder.add_attributes(x);
            }
            if let Some(x) = args.calls {
                builder.add_calls(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_NAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &Service) -> bool {
            self.name() < o.name()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.name();
            key.cmp(val)
        }
        #[inline]
        pub fn calls(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall>>,
                >>(Service::VT_CALLS, None)
            }
        }
        #[inline]
        pub fn attributes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>(Service::VT_ATTRIBUTES, None)
            }
        }
        #[inline]
        pub fn documentation(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Service::VT_DOCUMENTATION, None)
            }
        }
        /// File that this Service is declared in.
        #[inline]
        pub fn declaration_file(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_DECLARATION_FILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Service<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RPCCall>>,
                >>("calls", Self::VT_CALLS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KeyValue>>,
                >>("attributes", Self::VT_ATTRIBUTES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("documentation", Self::VT_DOCUMENTATION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "declaration_file",
                    Self::VT_DECLARATION_FILE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ServiceArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub calls: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RPCCall<'a>>>,
            >,
        >,
        pub attributes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KeyValue<'a>>>,
            >,
        >,
        pub documentation: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub declaration_file: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ServiceArgs<'a> {
        #[inline]
        fn default() -> Self {
            ServiceArgs {
                name: None, // required field
                calls: None,
                attributes: None,
                documentation: None,
                declaration_file: None,
            }
        }
    }

    pub struct ServiceBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ServiceBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_NAME, name);
        }
        #[inline]
        pub fn add_calls(
            &mut self,
            calls: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RPCCall<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_CALLS, calls);
        }
        #[inline]
        pub fn add_attributes(
            &mut self,
            attributes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<KeyValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_ATTRIBUTES, attributes);
        }
        #[inline]
        pub fn add_documentation(
            &mut self,
            documentation: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Service::VT_DOCUMENTATION,
                documentation,
            );
        }
        #[inline]
        pub fn add_declaration_file(&mut self, declaration_file: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Service::VT_DECLARATION_FILE,
                declaration_file,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ServiceBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ServiceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Service<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Service::VT_NAME, "name");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Service<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Service");
            ds.field("name", &self.name());
            ds.field("calls", &self.calls());
            ds.field("attributes", &self.attributes());
            ds.field("documentation", &self.documentation());
            ds.field("declaration_file", &self.declaration_file());
            ds.finish()
        }
    }
    pub enum SchemaFileOffset {}
    #[derive(Copy, Clone, PartialEq)]

    /// File specific information.
    /// Symbols declared within a file may be recovered by iterating over all
    /// symbols and examining the `declaration_file` field.
    pub struct SchemaFile<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SchemaFile<'a> {
        type Inner = SchemaFile<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SchemaFile<'a> {
        pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
        pub const VT_INCLUDED_FILENAMES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SchemaFile { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SchemaFileArgs<'args>,
        ) -> flatbuffers::WIPOffset<SchemaFile<'bldr>> {
            let mut builder = SchemaFileBuilder::new(_fbb);
            if let Some(x) = args.included_filenames {
                builder.add_included_filenames(x);
            }
            if let Some(x) = args.filename {
                builder.add_filename(x);
            }
            builder.finish()
        }

        /// Filename, relative to project root.
        #[inline]
        pub fn filename(&self) -> &'a str {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SchemaFile::VT_FILENAME, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &SchemaFile) -> bool {
            self.filename() < o.filename()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
            let key = self.filename();
            key.cmp(val)
        }
        /// Names of included files, relative to project root.
        #[inline]
        pub fn included_filenames(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(SchemaFile::VT_INCLUDED_FILENAMES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SchemaFile<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "filename",
                    Self::VT_FILENAME,
                    true,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("included_filenames", Self::VT_INCLUDED_FILENAMES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SchemaFileArgs<'a> {
        pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
        pub included_filenames: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for SchemaFileArgs<'a> {
        #[inline]
        fn default() -> Self {
            SchemaFileArgs {
                filename: None, // required field
                included_filenames: None,
            }
        }
    }

    pub struct SchemaFileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SchemaFileBuilder<'a, 'b> {
        #[inline]
        pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SchemaFile::VT_FILENAME, filename);
        }
        #[inline]
        pub fn add_included_filenames(
            &mut self,
            included_filenames: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SchemaFile::VT_INCLUDED_FILENAMES,
                included_filenames,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SchemaFileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SchemaFileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SchemaFile<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, SchemaFile::VT_FILENAME, "filename");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SchemaFile<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SchemaFile");
            ds.field("filename", &self.filename());
            ds.field("included_filenames", &self.included_filenames());
            ds.finish()
        }
    }
    pub enum SchemaOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Schema<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Schema<'a> {
        type Inner = Schema<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Schema<'a> {
        pub const VT_OBJECTS: flatbuffers::VOffsetT = 4;
        pub const VT_ENUMS: flatbuffers::VOffsetT = 6;
        pub const VT_FILE_IDENT: flatbuffers::VOffsetT = 8;
        pub const VT_FILE_EXT: flatbuffers::VOffsetT = 10;
        pub const VT_ROOT_TABLE: flatbuffers::VOffsetT = 12;
        pub const VT_SERVICES: flatbuffers::VOffsetT = 14;
        pub const VT_ADVANCED_FEATURES: flatbuffers::VOffsetT = 16;
        pub const VT_FBS_FILES: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Schema { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SchemaArgs<'args>,
        ) -> flatbuffers::WIPOffset<Schema<'bldr>> {
            let mut builder = SchemaBuilder::new(_fbb);
            builder.add_advanced_features(args.advanced_features);
            if let Some(x) = args.fbs_files {
                builder.add_fbs_files(x);
            }
            if let Some(x) = args.services {
                builder.add_services(x);
            }
            if let Some(x) = args.root_table {
                builder.add_root_table(x);
            }
            if let Some(x) = args.file_ext {
                builder.add_file_ext(x);
            }
            if let Some(x) = args.file_ident {
                builder.add_file_ident(x);
            }
            if let Some(x) = args.enums {
                builder.add_enums(x);
            }
            if let Some(x) = args.objects {
                builder.add_objects(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn objects(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object>>,
                    >>(Schema::VT_OBJECTS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn enums(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum<'a>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum>>,
                    >>(Schema::VT_ENUMS, None)
                    .unwrap()
            }
        }
        #[inline]
        pub fn file_ident(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILE_IDENT, None)
            }
        }
        #[inline]
        pub fn file_ext(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Schema::VT_FILE_EXT, None)
            }
        }
        #[inline]
        pub fn root_table(&self) -> Option<Object<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Object>>(Schema::VT_ROOT_TABLE, None)
            }
        }
        #[inline]
        pub fn services(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service>>,
                >>(Schema::VT_SERVICES, None)
            }
        }
        #[inline]
        pub fn advanced_features(&self) -> AdvancedFeatures {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<AdvancedFeatures>(Schema::VT_ADVANCED_FEATURES, Some(Default::default()))
                    .unwrap()
            }
        }
        /// All the files used in this compilation. Files are relative to where
        /// flatc was invoked.
        #[inline]
        pub fn fbs_files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SchemaFile<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SchemaFile>>,
                >>(Schema::VT_FBS_FILES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Schema<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Object>>,
                >>("objects", Self::VT_OBJECTS, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Enum>>,
                >>("enums", Self::VT_ENUMS, true)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "file_ident",
                    Self::VT_FILE_IDENT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "file_ext",
                    Self::VT_FILE_EXT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Object>>(
                    "root_table",
                    Self::VT_ROOT_TABLE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Service>>,
                >>("services", Self::VT_SERVICES, false)?
                .visit_field::<AdvancedFeatures>(
                    "advanced_features",
                    Self::VT_ADVANCED_FEATURES,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SchemaFile>>,
                >>("fbs_files", Self::VT_FBS_FILES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SchemaArgs<'a> {
        pub objects: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Object<'a>>>,
            >,
        >,
        pub enums: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Enum<'a>>>>,
        >,
        pub file_ident: Option<flatbuffers::WIPOffset<&'a str>>,
        pub file_ext: Option<flatbuffers::WIPOffset<&'a str>>,
        pub root_table: Option<flatbuffers::WIPOffset<Object<'a>>>,
        pub services: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>,
            >,
        >,
        pub advanced_features: AdvancedFeatures,
        pub fbs_files: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SchemaFile<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SchemaArgs<'a> {
        #[inline]
        fn default() -> Self {
            SchemaArgs {
                objects: None, // required field
                enums: None,   // required field
                file_ident: None,
                file_ext: None,
                root_table: None,
                services: None,
                advanced_features: Default::default(),
                fbs_files: None,
            }
        }
    }

    pub struct SchemaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SchemaBuilder<'a, 'b> {
        #[inline]
        pub fn add_objects(
            &mut self,
            objects: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Object<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_OBJECTS, objects);
        }
        #[inline]
        pub fn add_enums(
            &mut self,
            enums: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Enum<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_ENUMS, enums);
        }
        #[inline]
        pub fn add_file_ident(&mut self, file_ident: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILE_IDENT, file_ident);
        }
        #[inline]
        pub fn add_file_ext(&mut self, file_ext: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FILE_EXT, file_ext);
        }
        #[inline]
        pub fn add_root_table(&mut self, root_table: flatbuffers::WIPOffset<Object<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Object>>(
                    Schema::VT_ROOT_TABLE,
                    root_table,
                );
        }
        #[inline]
        pub fn add_services(
            &mut self,
            services: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Service<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_SERVICES, services);
        }
        #[inline]
        pub fn add_advanced_features(&mut self, advanced_features: AdvancedFeatures) {
            self.fbb_.push_slot::<AdvancedFeatures>(
                Schema::VT_ADVANCED_FEATURES,
                advanced_features,
                Default::default(),
            );
        }
        #[inline]
        pub fn add_fbs_files(
            &mut self,
            fbs_files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SchemaFile<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FBS_FILES, fbs_files);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SchemaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SchemaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Schema<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Schema::VT_OBJECTS, "objects");
            self.fbb_.required(o, Schema::VT_ENUMS, "enums");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Schema<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Schema");
            ds.field("objects", &self.objects());
            ds.field("enums", &self.enums());
            ds.field("file_ident", &self.file_ident());
            ds.field("file_ext", &self.file_ext());
            ds.field("root_table", &self.root_table());
            ds.field("services", &self.services());
            ds.field("advanced_features", &self.advanced_features());
            ds.field("fbs_files", &self.fbs_files());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Schema`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_schema_unchecked`.
    pub fn root_as_schema(buf: &[u8]) -> Result<Schema, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Schema>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Schema` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_schema_unchecked`.
    pub fn size_prefixed_root_as_schema(
        buf: &[u8],
    ) -> Result<Schema, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Schema>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Schema` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_schema_unchecked`.
    pub fn root_as_schema_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Schema<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Schema<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Schema` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_schema_unchecked`.
    pub fn size_prefixed_root_as_schema_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Schema<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Schema<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Schema and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Schema`.
    pub unsafe fn root_as_schema_unchecked(buf: &[u8]) -> Schema {
        flatbuffers::root_unchecked::<Schema>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Schema and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Schema`.
    pub unsafe fn size_prefixed_root_as_schema_unchecked(buf: &[u8]) -> Schema {
        flatbuffers::size_prefixed_root_unchecked::<Schema>(buf)
    }
    pub const SCHEMA_IDENTIFIER: &str = "BFBS";

    #[inline]
    pub fn schema_buffer_has_identifier(buf: &[u8]) -> bool {
        flatbuffers::buffer_has_identifier(buf, SCHEMA_IDENTIFIER, false)
    }

    #[inline]
    pub fn schema_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
        flatbuffers::buffer_has_identifier(buf, SCHEMA_IDENTIFIER, true)
    }

    pub const SCHEMA_EXTENSION: &str = "bfbs";

    #[inline]
    pub fn finish_schema_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Schema<'a>>,
    ) {
        fbb.finish(root, Some(SCHEMA_IDENTIFIER));
    }

    #[inline]
    pub fn finish_size_prefixed_schema_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Schema<'a>>,
    ) {
        fbb.finish_size_prefixed(root, Some(SCHEMA_IDENTIFIER));
    }
} // pub mod reflection

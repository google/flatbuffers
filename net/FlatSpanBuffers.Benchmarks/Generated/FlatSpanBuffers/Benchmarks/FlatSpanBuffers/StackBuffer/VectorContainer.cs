// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Benchmarks.FlatSpanBuffers.StackBuffer
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
public ref struct VectorContainer : IFlatbufferSpanObject
{
  private TableSpan __p;
  public ByteSpanBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static VectorContainer GetRootAsVectorContainer(ByteSpanBuffer _bb) { return GetRootAsVectorContainer(_bb, new VectorContainer()); }
  public static VectorContainer GetRootAsVectorContainer(ByteSpanBuffer _bb, VectorContainer obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteSpanBuffer _bb) { __p = new TableSpan(_i, _bb); }
  public VectorContainer __assign(int _i, ByteSpanBuffer _bb) { __init(_i, _bb); return this; }

  public RefStructNullable<ReadOnlySpan<byte>> Bytes { get { int o = __p.__offset(4); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(4)) : default; } }
  public RefStructNullable<Span<byte>> MutableBytes { get { int o = __p.__offset(4); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(4)) : default; } }
  public bool MutateBytes(int j, byte bytes) { int o = __p.__offset(4); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, bytes); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<short>> Shorts { get { int o = __p.__offset(6); return o != 0 ? new RefStructNullable<ReadOnlySpan<short>>(__p.__vector_as_span<short>(6)) : default; } }
  public RefStructNullable<Span<short>> MutableShorts { get { int o = __p.__offset(6); return o != 0 ? new RefStructNullable<Span<short>>(__p.__vector_as_span<short>(6)) : default; } }
  public bool MutateShorts(int j, short shorts) { int o = __p.__offset(6); if (o != 0) { __p.bb.Put<short>(__p.__vector(o) + j * 2, shorts); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<int>> Ints { get { int o = __p.__offset(8); return o != 0 ? new RefStructNullable<ReadOnlySpan<int>>(__p.__vector_as_span<int>(8)) : default; } }
  public RefStructNullable<Span<int>> MutableInts { get { int o = __p.__offset(8); return o != 0 ? new RefStructNullable<Span<int>>(__p.__vector_as_span<int>(8)) : default; } }
  public bool MutateInts(int j, int ints) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<int>(__p.__vector(o) + j * 4, ints); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<long>> Longs { get { int o = __p.__offset(10); return o != 0 ? new RefStructNullable<ReadOnlySpan<long>>(__p.__vector_as_span<long>(10)) : default; } }
  public RefStructNullable<Span<long>> MutableLongs { get { int o = __p.__offset(10); return o != 0 ? new RefStructNullable<Span<long>>(__p.__vector_as_span<long>(10)) : default; } }
  public bool MutateLongs(int j, long longs) { int o = __p.__offset(10); if (o != 0) { __p.bb.Put<long>(__p.__vector(o) + j * 8, longs); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<float>> Floats { get { int o = __p.__offset(12); return o != 0 ? new RefStructNullable<ReadOnlySpan<float>>(__p.__vector_as_span<float>(12)) : default; } }
  public RefStructNullable<Span<float>> MutableFloats { get { int o = __p.__offset(12); return o != 0 ? new RefStructNullable<Span<float>>(__p.__vector_as_span<float>(12)) : default; } }
  public bool MutateFloats(int j, float floats) { int o = __p.__offset(12); if (o != 0) { __p.bb.Put<float>(__p.__vector(o) + j * 4, floats); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<double>> Doubles { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<ReadOnlySpan<double>>(__p.__vector_as_span<double>(14)) : default; } }
  public RefStructNullable<Span<double>> MutableDoubles { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<Span<double>>(__p.__vector_as_span<double>(14)) : default; } }
  public bool MutateDoubles(int j, double doubles) { int o = __p.__offset(14); if (o != 0) { __p.bb.Put<double>(__p.__vector(o) + j * 8, doubles); return true; } else { return false; } }
  public RefStructNullable<StringVectorSpan> Strings { get { int o = __p.__offset(16); return o != 0 ? new RefStructNullable<StringVectorSpan>(new StringVectorSpan(__p, o)) : default; } }

  public static Offset<Benchmarks.FlatSpanBuffers.StackBuffer.VectorContainer> CreateVectorContainer(ref FlatSpanBufferBuilder builder,
      VectorOffset bytesOffset = default(VectorOffset),
      VectorOffset shortsOffset = default(VectorOffset),
      VectorOffset intsOffset = default(VectorOffset),
      VectorOffset longsOffset = default(VectorOffset),
      VectorOffset floatsOffset = default(VectorOffset),
      VectorOffset doublesOffset = default(VectorOffset),
      VectorOffset stringsOffset = default(VectorOffset)) {
    builder.StartTable(7);
    VectorContainer.AddStrings(ref builder, stringsOffset);
    VectorContainer.AddDoubles(ref builder, doublesOffset);
    VectorContainer.AddFloats(ref builder, floatsOffset);
    VectorContainer.AddLongs(ref builder, longsOffset);
    VectorContainer.AddInts(ref builder, intsOffset);
    VectorContainer.AddShorts(ref builder, shortsOffset);
    VectorContainer.AddBytes(ref builder, bytesOffset);
    return VectorContainer.EndVectorContainer(ref builder);
  }

  public static void StartVectorContainer(ref FlatSpanBufferBuilder builder) { builder.StartTable(7); }
  public static void AddBytes(ref FlatSpanBufferBuilder builder, VectorOffset bytesOffset) { builder.AddOffset(0, bytesOffset, 0); }
  public static VectorOffset CreateBytesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateBytesVector(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { return CreateBytesVectorBlock(ref builder, data); }
  public static void StartBytesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddShorts(ref FlatSpanBufferBuilder builder, VectorOffset shortsOffset) { builder.AddOffset(1, shortsOffset, 0); }
  public static VectorOffset CreateShortsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<short> data) { builder.StartVector(2, data.Length, 2); builder.AddSpan<short>(data); return builder.EndVector(); }
  public static VectorOffset CreateShortsVector(ref FlatSpanBufferBuilder builder, scoped Span<short> data) { return CreateShortsVectorBlock(ref builder, data); }
  public static void StartShortsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(2, numElems, 2); }
  public static void AddInts(ref FlatSpanBufferBuilder builder, VectorOffset intsOffset) { builder.AddOffset(2, intsOffset, 0); }
  public static VectorOffset CreateIntsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<int> data) { builder.StartVector(4, data.Length, 4); builder.AddSpan<int>(data); return builder.EndVector(); }
  public static VectorOffset CreateIntsVector(ref FlatSpanBufferBuilder builder, scoped Span<int> data) { return CreateIntsVectorBlock(ref builder, data); }
  public static void StartIntsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLongs(ref FlatSpanBufferBuilder builder, VectorOffset longsOffset) { builder.AddOffset(3, longsOffset, 0); }
  public static VectorOffset CreateLongsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<long> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<long>(data); return builder.EndVector(); }
  public static VectorOffset CreateLongsVector(ref FlatSpanBufferBuilder builder, scoped Span<long> data) { return CreateLongsVectorBlock(ref builder, data); }
  public static void StartLongsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddFloats(ref FlatSpanBufferBuilder builder, VectorOffset floatsOffset) { builder.AddOffset(4, floatsOffset, 0); }
  public static VectorOffset CreateFloatsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<float> data) { builder.StartVector(4, data.Length, 4); builder.AddSpan<float>(data); return builder.EndVector(); }
  public static VectorOffset CreateFloatsVector(ref FlatSpanBufferBuilder builder, scoped Span<float> data) { return CreateFloatsVectorBlock(ref builder, data); }
  public static void StartFloatsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddDoubles(ref FlatSpanBufferBuilder builder, VectorOffset doublesOffset) { builder.AddOffset(5, doublesOffset, 0); }
  public static VectorOffset CreateDoublesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<double> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<double>(data); return builder.EndVector(); }
  public static VectorOffset CreateDoublesVector(ref FlatSpanBufferBuilder builder, scoped Span<double> data) { return CreateDoublesVectorBlock(ref builder, data); }
  public static void StartDoublesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddStrings(ref FlatSpanBufferBuilder builder, VectorOffset stringsOffset) { builder.AddOffset(6, stringsOffset, 0); }
  public static VectorOffset CreateStringsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<StringOffset>(data); return builder.EndVector(); }
  public static VectorOffset CreateStringsVector(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { return CreateStringsVectorBlock(ref builder, data); }
  public static void StartStringsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Benchmarks.FlatSpanBuffers.StackBuffer.VectorContainer> EndVectorContainer(ref FlatSpanBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Benchmarks.FlatSpanBuffers.StackBuffer.VectorContainer>(o);
  }
  public VectorContainerT UnPack() {
    var _o = new VectorContainerT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(VectorContainerT _o) {
    var _bytes_vec = this.Bytes;
    var _bytes_len = _bytes_vec.HasValue ? _bytes_vec.Value.Length : 0;
    if (_o.Bytes == null) {
      _o.Bytes = new List<byte>(_bytes_len);
    }
    ObjectApiUtil.ResizeList(_o.Bytes, _bytes_len);
    if (_bytes_vec.HasValue) { _bytes_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Bytes)); }
    var _shorts_vec = this.Shorts;
    var _shorts_len = _shorts_vec.HasValue ? _shorts_vec.Value.Length : 0;
    if (_o.Shorts == null) {
      _o.Shorts = new List<short>(_shorts_len);
    }
    ObjectApiUtil.ResizeList(_o.Shorts, _shorts_len);
    if (_shorts_vec.HasValue) { _shorts_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Shorts)); }
    var _ints_vec = this.Ints;
    var _ints_len = _ints_vec.HasValue ? _ints_vec.Value.Length : 0;
    if (_o.Ints == null) {
      _o.Ints = new List<int>(_ints_len);
    }
    ObjectApiUtil.ResizeList(_o.Ints, _ints_len);
    if (_ints_vec.HasValue) { _ints_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Ints)); }
    var _longs_vec = this.Longs;
    var _longs_len = _longs_vec.HasValue ? _longs_vec.Value.Length : 0;
    if (_o.Longs == null) {
      _o.Longs = new List<long>(_longs_len);
    }
    ObjectApiUtil.ResizeList(_o.Longs, _longs_len);
    if (_longs_vec.HasValue) { _longs_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Longs)); }
    var _floats_vec = this.Floats;
    var _floats_len = _floats_vec.HasValue ? _floats_vec.Value.Length : 0;
    if (_o.Floats == null) {
      _o.Floats = new List<float>(_floats_len);
    }
    ObjectApiUtil.ResizeList(_o.Floats, _floats_len);
    if (_floats_vec.HasValue) { _floats_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Floats)); }
    var _doubles_vec = this.Doubles;
    var _doubles_len = _doubles_vec.HasValue ? _doubles_vec.Value.Length : 0;
    if (_o.Doubles == null) {
      _o.Doubles = new List<double>(_doubles_len);
    }
    ObjectApiUtil.ResizeList(_o.Doubles, _doubles_len);
    if (_doubles_vec.HasValue) { _doubles_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Doubles)); }
    var _strings_vec = this.Strings;
    var _strings_len = _strings_vec.HasValue ? _strings_vec.Value.Length : 0;
    if (_o.Strings == null) {
      _o.Strings = new List<string>(_strings_len);
    } else {
      _o.Strings.Clear();
      if (_o.Strings.Capacity < _strings_len) {
        _o.Strings.Capacity = _strings_len;
      }
    }
    if (_strings_vec.HasValue) {
      var _strings_value = _strings_vec.Value;
      for (var _j = 0; _j < _strings_len; ++_j) { _o.Strings.Add(_strings_value[_j]); }
    }
  }
  public static Offset<Benchmarks.FlatSpanBuffers.StackBuffer.VectorContainer> Pack(ref FlatSpanBufferBuilder builder, VectorContainerT _o) {
    if (_o == null) return default(Offset<Benchmarks.FlatSpanBuffers.StackBuffer.VectorContainer>);
    var _bytes = default(VectorOffset);
    if (_o.Bytes != null) {
      _bytes = CreateBytesVector(ref builder, CollectionsMarshal.AsSpan(_o.Bytes));
    }
    var _shorts = default(VectorOffset);
    if (_o.Shorts != null) {
      _shorts = CreateShortsVector(ref builder, CollectionsMarshal.AsSpan(_o.Shorts));
    }
    var _ints = default(VectorOffset);
    if (_o.Ints != null) {
      _ints = CreateIntsVector(ref builder, CollectionsMarshal.AsSpan(_o.Ints));
    }
    var _longs = default(VectorOffset);
    if (_o.Longs != null) {
      _longs = CreateLongsVector(ref builder, CollectionsMarshal.AsSpan(_o.Longs));
    }
    var _floats = default(VectorOffset);
    if (_o.Floats != null) {
      _floats = CreateFloatsVector(ref builder, CollectionsMarshal.AsSpan(_o.Floats));
    }
    var _doubles = default(VectorOffset);
    if (_o.Doubles != null) {
      _doubles = CreateDoublesVector(ref builder, CollectionsMarshal.AsSpan(_o.Doubles));
    }
    var _strings = default(VectorOffset);
    if (_o.Strings != null) {
      var _strings_len = _o.Strings.Count;
      StringOffset[] _strings_arr = null;
      try {
        Span<StringOffset> __strings = _strings_len <= 64
          ? stackalloc StringOffset[_strings_len]
          : (_strings_arr = ArrayPool<StringOffset>.Shared.Rent(_strings_len)).AsSpan(0, _strings_len);
        for (var _j = 0; _j < _strings_len; ++_j) { __strings[_j] = builder.CreateString(_o.Strings[_j]); }
        _strings = CreateStringsVector(ref builder, __strings);
      } finally {
        if (_strings_arr != null) { ArrayPool<StringOffset>.Shared.Return(_strings_arr); }
      }
    }
    return CreateVectorContainer(
      ref builder,
      _bytes,
      _shorts,
      _ints,
      _longs,
      _floats,
      _doubles,
      _strings);
  }
}


}

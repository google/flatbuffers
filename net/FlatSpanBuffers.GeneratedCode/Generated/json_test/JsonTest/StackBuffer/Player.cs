// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace JsonTest.StackBuffer
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
public ref struct Player : IFlatbufferSpanObject
{
  private TableSpan __p;
  public ByteSpanBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Player GetRootAsPlayer(ByteSpanBuffer _bb) { return GetRootAsPlayer(_bb, new Player()); }
  public static Player GetRootAsPlayer(ByteSpanBuffer _bb, Player obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteSpanBuffer _bb) { __p = new TableSpan(_i, _bb); }
  public Player __assign(int _i, ByteSpanBuffer _bb) { __init(_i, _bb); return this; }

  public long Id { get { int o = __p.__offset(4); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public string Name { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
  public ReadOnlySpan<byte> GetNameBytes() { return __p.__vector_as_span<byte>(6); }
  public int Level { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)1; } }
  public float Health { get { int o = __p.__offset(10); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)100.0f; } }
  public RefStructNullable<JsonTest.StackBuffer.Vec2> Position { get { int o = __p.__offset(12); return o != 0 ? new RefStructNullable<JsonTest.StackBuffer.Vec2>((new JsonTest.StackBuffer.Vec2()).__assign(o + __p.bb_pos, __p.bb)) : default; } }
  public JsonTest.Status Status { get { int o = __p.__offset(14); return o != 0 ? (JsonTest.Status)__p.bb.Get<sbyte>(o + __p.bb_pos) : JsonTest.Status.Active; } }
  public JsonTest.Priority Priorities { get { int o = __p.__offset(16); return o != 0 ? (JsonTest.Priority)__p.bb.Get<byte>(o + __p.bb_pos) : 0; } }
  public RefStructNullable<TableVectorSpan<JsonTest.StackBuffer.Item>> Inventory { get { int o = __p.__offset(18); return o != 0 ? new RefStructNullable<TableVectorSpan<JsonTest.StackBuffer.Item>>(new TableVectorSpan<JsonTest.StackBuffer.Item>(__p, o, 4)) : default; } }
  public bool TryGetInventoryByKey(int key, out JsonTest.StackBuffer.Item value) { int o = __p.__offset(18); if (o != 0) { return JsonTest.StackBuffer.Item.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public JsonTest.Equipment EquippedType { get { int o = __p.__offset(20); return o != 0 ? (JsonTest.Equipment)__p.bb.Get<byte>(o + __p.bb_pos) : JsonTest.Equipment.NONE; } }
  public RefStructNullable<TTable> Equipped<TTable>() where TTable : struct, IFlatbufferSpanObject, allows ref struct { int o = __p.__offset(22); return o != 0 ? new RefStructNullable<TTable>(__p.__union<TTable>(o + __p.bb_pos)) : default; }
  public JsonTest.StackBuffer.Weapon EquippedAsWeapon() { return Equipped<JsonTest.StackBuffer.Weapon>().Value; }
  public JsonTest.StackBuffer.Armor EquippedAsArmor() { return Equipped<JsonTest.StackBuffer.Armor>().Value; }
  public RefStructNullable<StringVectorSpan> Tags { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<StringVectorSpan>(new StringVectorSpan(__p, o)) : default; } }
  public RefStructNullable<ReadOnlySpan<int>> Scores { get { int o = __p.__offset(26); return o != 0 ? new RefStructNullable<ReadOnlySpan<int>>(__p.__vector_as_span<int>(26)) : default; } }
  public RefStructNullable<JsonTest.StackBuffer.Color> Color { get { int o = __p.__offset(28); return o != 0 ? new RefStructNullable<JsonTest.StackBuffer.Color>((new JsonTest.StackBuffer.Color()).__assign(o + __p.bb_pos, __p.bb)) : default; } }

  public static void StartPlayer(ref FlatSpanBufferBuilder builder) { builder.StartTable(13); }
  public static void AddId(ref FlatSpanBufferBuilder builder, long id) { builder.Add<long>(0, id, 0); }
  public static void AddName(ref FlatSpanBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(1, nameOffset, 0); }
  public static void AddLevel(ref FlatSpanBufferBuilder builder, int level) { builder.Add<int>(2, level, 1); }
  public static void AddHealth(ref FlatSpanBufferBuilder builder, float health) { builder.Add<float>(3, health, 100.0f); }
  public static void AddPosition(ref FlatSpanBufferBuilder builder, Offset<JsonTest.StackBuffer.Vec2> positionOffset) { builder.AddStruct(4, positionOffset, 0); }
  public static void AddStatus(ref FlatSpanBufferBuilder builder, JsonTest.Status status) { builder.Add<sbyte>(5, (sbyte)status, 1); }
  public static void AddPriorities(ref FlatSpanBufferBuilder builder, JsonTest.Priority priorities) { builder.Add<byte>(6, (byte)priorities, 0); }
  public static void AddInventory(ref FlatSpanBufferBuilder builder, VectorOffset inventoryOffset) { builder.AddOffset(7, inventoryOffset, 0); }
  public static VectorOffset CreateInventoryVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<Offset<JsonTest.StackBuffer.Item>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<JsonTest.StackBuffer.Item>>(data); return builder.EndVector(); }
  public static VectorOffset CreateInventoryVector(ref FlatSpanBufferBuilder builder, scoped Span<Offset<JsonTest.StackBuffer.Item>> data) { return CreateInventoryVectorBlock(ref builder, data); }
  public static void StartInventoryVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEquippedType(ref FlatSpanBufferBuilder builder, JsonTest.Equipment equippedType) { builder.Add<byte>(8, (byte)equippedType, 0); }
  public static void AddEquipped(ref FlatSpanBufferBuilder builder, int equippedOffset) { builder.AddOffset(9, equippedOffset, 0); }
  public static void AddTags(ref FlatSpanBufferBuilder builder, VectorOffset tagsOffset) { builder.AddOffset(10, tagsOffset, 0); }
  public static VectorOffset CreateTagsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<StringOffset>(data); return builder.EndVector(); }
  public static VectorOffset CreateTagsVector(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { return CreateTagsVectorBlock(ref builder, data); }
  public static void StartTagsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddScores(ref FlatSpanBufferBuilder builder, VectorOffset scoresOffset) { builder.AddOffset(11, scoresOffset, 0); }
  public static VectorOffset CreateScoresVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<int> data) { builder.StartVector(4, data.Length, 4); builder.AddSpan<int>(data); return builder.EndVector(); }
  public static VectorOffset CreateScoresVector(ref FlatSpanBufferBuilder builder, scoped Span<int> data) { return CreateScoresVectorBlock(ref builder, data); }
  public static void StartScoresVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddColor(ref FlatSpanBufferBuilder builder, Offset<JsonTest.StackBuffer.Color> colorOffset) { builder.AddStruct(12, colorOffset, 0); }
  public static Offset<JsonTest.StackBuffer.Player> EndPlayer(ref FlatSpanBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 6);  // name
    return new Offset<JsonTest.StackBuffer.Player>(o);
  }

  public static VectorOffset CreateSortedVectorOfPlayer(ref FlatSpanBufferBuilder builder, scoped Span<Offset<Player>> offsets) {
    var comparer = new SortedVectorUtils.VectorOffsetComparer<Player, ByteSpanBuffer, byte>(builder.DataBuffer, 6);
    RefStructSorters.Sort(offsets, ref comparer);
    return builder.CreateVectorOfTables<Player>(offsets);
  }

  public static bool TryGetByKey(int vectorLocation, string key, ByteSpanBuffer bb, out Player value) {
    return SortedVectorUtils.TryGetByKey<Player, ByteSpanBuffer>(vectorLocation, key, ref bb, 6, out value);
  }
  public PlayerT UnPack() {
    var _o = new PlayerT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PlayerT _o) {
    _o.Id = this.Id;
    _o.Name = this.Name;
    _o.Level = this.Level;
    _o.Health = this.Health;
    if (this.Position.HasValue) {
      if (_o.Position == null) _o.Position = new JsonTest.Vec2T();
      this.Position.Value.UnPackTo(_o.Position);
    } else {
      _o.Position = null;
    }
    _o.Status = this.Status;
    _o.Priorities = this.Priorities;
    var _inventory_vec = this.Inventory;
    var _inventory_len = _inventory_vec.HasValue ? _inventory_vec.Value.Length : 0;
    if (_o.Inventory == null) {
      _o.Inventory = new List<JsonTest.ItemT>(_inventory_len);
    }
    ObjectApiUtil.ResizeList(_o.Inventory, _inventory_len);
    if (_inventory_vec.HasValue) {
      var _inventory_value = _inventory_vec.Value;
      for (var _j = 0; _j < _inventory_len; ++_j) {
        var _src = _inventory_value[_j];
        if (_o.Inventory[_j] == null) { _o.Inventory[_j] = new ItemT(); }
        _src.UnPackTo(_o.Inventory[_j]);
      }
    }
    if (_o.Equipped == null) {
      _o.Equipped = new JsonTest.EquipmentUnion();
    }
    var _EquippedOldType = _o.Equipped.Type;
    _o.Equipped.Type = this.EquippedType;
    switch (this.EquippedType) {
      default:
        _o.Equipped.Value = null;
        break;
      case JsonTest.Equipment.Weapon:
        if (this.Equipped<JsonTest.StackBuffer.Weapon>().HasValue) {
          if (_EquippedOldType == JsonTest.Equipment.Weapon) {
            this.Equipped<JsonTest.StackBuffer.Weapon>().Value.UnPackTo((JsonTest.WeaponT)_o.Equipped.Value);
          } else {
            _o.Equipped.Value = this.Equipped<JsonTest.StackBuffer.Weapon>().Value.UnPack();
          }
        } else {
          _o.Equipped.Value = null;
        }
        break;
      case JsonTest.Equipment.Armor:
        if (this.Equipped<JsonTest.StackBuffer.Armor>().HasValue) {
          if (_EquippedOldType == JsonTest.Equipment.Armor) {
            this.Equipped<JsonTest.StackBuffer.Armor>().Value.UnPackTo((JsonTest.ArmorT)_o.Equipped.Value);
          } else {
            _o.Equipped.Value = this.Equipped<JsonTest.StackBuffer.Armor>().Value.UnPack();
          }
        } else {
          _o.Equipped.Value = null;
        }
        break;
    }
    var _tags_vec = this.Tags;
    var _tags_len = _tags_vec.HasValue ? _tags_vec.Value.Length : 0;
    if (_o.Tags == null) {
      _o.Tags = new List<string>(_tags_len);
    } else {
      _o.Tags.Clear();
      if (_o.Tags.Capacity < _tags_len) {
        _o.Tags.Capacity = _tags_len;
      }
    }
    if (_tags_vec.HasValue) {
      var _tags_value = _tags_vec.Value;
      for (var _j = 0; _j < _tags_len; ++_j) { _o.Tags.Add(_tags_value[_j]); }
    }
    var _scores_vec = this.Scores;
    var _scores_len = _scores_vec.HasValue ? _scores_vec.Value.Length : 0;
    if (_o.Scores == null) {
      _o.Scores = new List<int>(_scores_len);
    }
    ObjectApiUtil.ResizeList(_o.Scores, _scores_len);
    if (_scores_vec.HasValue) { _scores_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Scores)); }
    if (this.Color.HasValue) {
      if (_o.Color == null) _o.Color = new JsonTest.ColorT();
      this.Color.Value.UnPackTo(_o.Color);
    } else {
      _o.Color = null;
    }
  }
  public static Offset<JsonTest.StackBuffer.Player> Pack(ref FlatSpanBufferBuilder builder, PlayerT _o) {
    if (_o == null) return default(Offset<JsonTest.StackBuffer.Player>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _inventory = default(VectorOffset);
    if (_o.Inventory != null) {
      var _inventory_len = _o.Inventory.Count;
      Offset<JsonTest.StackBuffer.Item>[] _inventory_arr = null;
      try {
        Span<Offset<JsonTest.StackBuffer.Item>> __inventory = _inventory_len <= 64
          ? stackalloc Offset<JsonTest.StackBuffer.Item>[_inventory_len]
          : (_inventory_arr = ArrayPool<Offset<JsonTest.StackBuffer.Item>>.Shared.Rent(_inventory_len)).AsSpan(0, _inventory_len);
        for (var _j = 0; _j < _inventory_len; ++_j) { __inventory[_j] = JsonTest.StackBuffer.Item.Pack(ref builder, _o.Inventory[_j]); }
        _inventory = CreateInventoryVector(ref builder, __inventory);
      } finally {
        if (_inventory_arr != null) { ArrayPool<Offset<JsonTest.StackBuffer.Item>>.Shared.Return(_inventory_arr); }
      }
    }
    var _equipped_type = _o.Equipped == null ? JsonTest.Equipment.NONE : _o.Equipped.Type;
    var _equipped = _o.Equipped == null ? 0 : JsonTest.EquipmentUnion.Pack(ref builder, _o.Equipped);
    var _tags = default(VectorOffset);
    if (_o.Tags != null) {
      var _tags_len = _o.Tags.Count;
      StringOffset[] _tags_arr = null;
      try {
        Span<StringOffset> __tags = _tags_len <= 64
          ? stackalloc StringOffset[_tags_len]
          : (_tags_arr = ArrayPool<StringOffset>.Shared.Rent(_tags_len)).AsSpan(0, _tags_len);
        for (var _j = 0; _j < _tags_len; ++_j) { __tags[_j] = builder.CreateString(_o.Tags[_j]); }
        _tags = CreateTagsVector(ref builder, __tags);
      } finally {
        if (_tags_arr != null) { ArrayPool<StringOffset>.Shared.Return(_tags_arr); }
      }
    }
    var _scores = default(VectorOffset);
    if (_o.Scores != null) {
      _scores = CreateScoresVector(ref builder, CollectionsMarshal.AsSpan(_o.Scores));
    }
    StartPlayer(ref builder);
    AddId(ref builder, _o.Id);
    AddName(ref builder, _name);
    AddLevel(ref builder, _o.Level);
    AddHealth(ref builder, _o.Health);
    AddPosition(ref builder, JsonTest.StackBuffer.Vec2.Pack(ref builder, _o.Position));
    AddStatus(ref builder, _o.Status);
    AddPriorities(ref builder, _o.Priorities);
    AddInventory(ref builder, _inventory);
    AddEquippedType(ref builder, _equipped_type);
    AddEquipped(ref builder, _equipped);
    AddTags(ref builder, _tags);
    AddScores(ref builder, _scores);
    AddColor(ref builder, JsonTest.StackBuffer.Color.Pack(ref builder, _o.Color));
    return EndPlayer(ref builder);
  }
}


}

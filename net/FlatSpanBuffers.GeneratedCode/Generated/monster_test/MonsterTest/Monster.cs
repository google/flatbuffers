// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MonsterTest
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
public struct Monster : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Monster GetRootAsMonster(ByteBuffer _bb) { return GetRootAsMonster(_bb, new Monster()); }
  public static Monster GetRootAsMonster(ByteBuffer _bb, Monster obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public static bool VerifyMonster(ByteBuffer _bb) {Google.FlatSpanBuffers.Verifier verifier = new Google.FlatSpanBuffers.Verifier(_bb); return verifier.VerifyBuffer("", false, MonsterTest.MonsterVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Monster __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public MonsterTest.Vec3? Pos { get { int o = __p.__offset(4); return o != 0 ? (MonsterTest.Vec3?)(new MonsterTest.Vec3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public short Mana { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)150; } }
  public bool MutateMana(short mana) { int o = __p.__offset(6); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, mana); return true; } else { return false; } }
  public short Hp { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)100; } }
  public bool MutateHp(short hp) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, hp); return true; } else { return false; } }
  public string Name { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
  public ReadOnlySpan<byte> GetNameBytes() { return __p.__vector_as_span<byte>(10); }
  public RefStructNullable<Span<byte>> MutableName { get { int o = __p.__offset(10); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(10)) : default; } }
  public RefStructNullable<ReadOnlySpan<byte>> Inventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public RefStructNullable<Span<byte>> MutableInventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public bool MutateInventory(int j, byte inventory) { int o = __p.__offset(14); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, inventory); return true; } else { return false; } }
  public MonsterTest.Color Color { get { int o = __p.__offset(16); return o != 0 ? (MonsterTest.Color)__p.bb.Get<sbyte>(o + __p.bb_pos) : MonsterTest.Color.Blue; } }
  public bool MutateColor(MonsterTest.Color color) { int o = __p.__offset(16); if (o != 0) { __p.bb.Put<sbyte>(o + __p.bb_pos, (sbyte)color); return true; } else { return false; } }
  public TableVector<MonsterTest.Weapon>? Weapons { get { int o = __p.__offset(18); return o != 0 ? new TableVector<MonsterTest.Weapon>(__p, o, 4) : null; } }
  public MonsterTest.Equipment EquippedType { get { int o = __p.__offset(20); return o != 0 ? (MonsterTest.Equipment)__p.bb.Get<byte>(o + __p.bb_pos) : MonsterTest.Equipment.NONE; } }
  public TTable? Equipped<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(22); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public MonsterTest.Weapon EquippedAsWeapon() { return Equipped<MonsterTest.Weapon>().Value; }
  public StructVector<MonsterTest.Vec3>? Path { get { int o = __p.__offset(24); return o != 0 ? new StructVector<MonsterTest.Vec3>(__p, o, 12) : null; } }

  public static Offset<MonsterTest.Monster> CreateMonster(FlatBufferBuilder builder,
      MonsterTest.Vec3T pos = null,
      short mana = 150,
      short hp = 100,
      StringOffset nameOffset = default(StringOffset),
      VectorOffset inventoryOffset = default(VectorOffset),
      MonsterTest.Color color = MonsterTest.Color.Blue,
      VectorOffset weaponsOffset = default(VectorOffset),
      MonsterTest.Equipment equipped_type = MonsterTest.Equipment.NONE,
      int equippedOffset = 0,
      VectorOffset pathOffset = default(VectorOffset)) {
    builder.StartTable(11);
    Monster.AddPath(builder, pathOffset);
    Monster.AddEquipped(builder, equippedOffset);
    Monster.AddWeapons(builder, weaponsOffset);
    Monster.AddInventory(builder, inventoryOffset);
    Monster.AddName(builder, nameOffset);
    Monster.AddPos(builder, MonsterTest.Vec3.Pack(builder, pos));
    Monster.AddHp(builder, hp);
    Monster.AddMana(builder, mana);
    Monster.AddEquippedType(builder, equipped_type);
    Monster.AddColor(builder, color);
    return Monster.EndMonster(builder);
  }

  public static void StartMonster(FlatBufferBuilder builder) { builder.StartTable(11); }
  public static void AddPos(FlatBufferBuilder builder, Offset<MonsterTest.Vec3> posOffset) { builder.AddStruct(0, posOffset, 0); }
  public static void AddMana(FlatBufferBuilder builder, short mana) { builder.Add<short>(1, mana, 150); }
  public static void AddHp(FlatBufferBuilder builder, short hp) { builder.Add<short>(2, hp, 100); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(3, nameOffset, 0); }
  public static void AddInventory(FlatBufferBuilder builder, VectorOffset inventoryOffset) { builder.AddOffset(5, inventoryOffset, 0); }
  public static VectorOffset CreateInventoryVectorBlock(FlatBufferBuilder builder, Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateInventoryVector(FlatBufferBuilder builder, Span<byte> data) { return CreateInventoryVectorBlock(builder, data); }
  public static void StartInventoryVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddColor(FlatBufferBuilder builder, MonsterTest.Color color) { builder.Add<sbyte>(6, (sbyte)color, 2); }
  public static void AddWeapons(FlatBufferBuilder builder, VectorOffset weaponsOffset) { builder.AddOffset(7, weaponsOffset, 0); }
  public static VectorOffset CreateWeaponsVectorBlock(FlatBufferBuilder builder, Span<Offset<MonsterTest.Weapon>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MonsterTest.Weapon>>(data); return builder.EndVector(); }
  public static VectorOffset CreateWeaponsVector(FlatBufferBuilder builder, Span<Offset<MonsterTest.Weapon>> data) { return CreateWeaponsVectorBlock(builder, data); }
  public static void StartWeaponsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEquippedType(FlatBufferBuilder builder, MonsterTest.Equipment equippedType) { builder.Add<byte>(8, (byte)equippedType, 0); }
  public static void AddEquipped(FlatBufferBuilder builder, int equippedOffset) { builder.AddOffset(9, equippedOffset, 0); }
  public static void AddPath(FlatBufferBuilder builder, VectorOffset pathOffset) { builder.AddOffset(10, pathOffset, 0); }
  public static void StartPathVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(12, numElems, 4); }
  public static Offset<MonsterTest.Monster> EndMonster(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<MonsterTest.Monster>(o);
  }
  public static void FinishMonsterBuffer(FlatBufferBuilder builder, Offset<MonsterTest.Monster> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedMonsterBuffer(FlatBufferBuilder builder, Offset<MonsterTest.Monster> offset) { builder.FinishSizePrefixed(offset.Value); }
  public MonsterT UnPack() {
    var _o = new MonsterT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MonsterT _o) {
    if (this.Pos.HasValue) {
      if (_o.Pos == null) _o.Pos = new MonsterTest.Vec3T();
      this.Pos.Value.UnPackTo(_o.Pos);
    } else {
      _o.Pos = null;
    }
    _o.Mana = this.Mana;
    _o.Hp = this.Hp;
    _o.Name = this.Name;
    var _inventory_vec = this.Inventory;
    var _inventory_len = _inventory_vec.HasValue ? _inventory_vec.Value.Length : 0;
    if (_o.Inventory == null) {
      _o.Inventory = new List<byte>(_inventory_len);
    }
    ObjectApiUtil.ResizeList(_o.Inventory, _inventory_len);
    if (_inventory_vec.HasValue) { _inventory_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Inventory)); }
    _o.Color = this.Color;
    var _weapons_vec = this.Weapons;
    var _weapons_len = _weapons_vec.HasValue ? _weapons_vec.Value.Length : 0;
    if (_o.Weapons == null) {
      _o.Weapons = new List<MonsterTest.WeaponT>(_weapons_len);
    }
    ObjectApiUtil.ResizeList(_o.Weapons, _weapons_len);
    if (_weapons_vec.HasValue) {
      var _weapons_value = _weapons_vec.Value;
      for (var _j = 0; _j < _weapons_len; ++_j) {
        var _src = _weapons_value[_j];
        if (_o.Weapons[_j] == null) { _o.Weapons[_j] = new WeaponT(); }
        _src.UnPackTo(_o.Weapons[_j]);
      }
    }
    if (_o.Equipped == null) {
      _o.Equipped = new MonsterTest.EquipmentUnion();
    }
    var _EquippedOldType = _o.Equipped.Type;
    _o.Equipped.Type = this.EquippedType;
    switch (this.EquippedType) {
      default:
        _o.Equipped.Value = null;
        break;
      case MonsterTest.Equipment.Weapon:
        if (this.Equipped<MonsterTest.Weapon>().HasValue) {
          if (_EquippedOldType == MonsterTest.Equipment.Weapon) {
            this.Equipped<MonsterTest.Weapon>().Value.UnPackTo((MonsterTest.WeaponT)_o.Equipped.Value);
          } else {
            _o.Equipped.Value = this.Equipped<MonsterTest.Weapon>().Value.UnPack();
          }
        } else {
          _o.Equipped.Value = null;
        }
        break;
    }
    var _path_vec = this.Path;
    var _path_len = _path_vec.HasValue ? _path_vec.Value.Length : 0;
    if (_o.Path == null) {
      _o.Path = new List<MonsterTest.Vec3T>(_path_len);
    }
    ObjectApiUtil.ResizeList(_o.Path, _path_len);
    if (_path_vec.HasValue) {
      var _path_value = _path_vec.Value;
      for (var _j = 0; _j < _path_len; ++_j) {
        var _src = _path_value[_j];
        if (_o.Path[_j] == null) { _o.Path[_j] = new Vec3T(); }
        _src.UnPackTo(_o.Path[_j]);
      }
    }
  }
  public static Offset<MonsterTest.Monster> Pack(FlatBufferBuilder builder, MonsterT _o) {
    if (_o == null) return default(Offset<MonsterTest.Monster>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _inventory = default(VectorOffset);
    if (_o.Inventory != null) {
      _inventory = CreateInventoryVector(builder, CollectionsMarshal.AsSpan(_o.Inventory));
    }
    var _weapons = default(VectorOffset);
    if (_o.Weapons != null) {
      var _weapons_len = _o.Weapons.Count;
      Offset<MonsterTest.Weapon>[] _weapons_arr = null;
      try {
        Span<Offset<MonsterTest.Weapon>> __weapons = _weapons_len <= 64
          ? stackalloc Offset<MonsterTest.Weapon>[_weapons_len]
          : (_weapons_arr = ArrayPool<Offset<MonsterTest.Weapon>>.Shared.Rent(_weapons_len)).AsSpan(0, _weapons_len);
        for (var _j = 0; _j < _weapons_len; ++_j) { __weapons[_j] = MonsterTest.Weapon.Pack(builder, _o.Weapons[_j]); }
        _weapons = CreateWeaponsVector(builder, __weapons);
      } finally {
        if (_weapons_arr != null) { ArrayPool<Offset<MonsterTest.Weapon>>.Shared.Return(_weapons_arr); }
      }
    }
    var _equipped_type = _o.Equipped == null ? MonsterTest.Equipment.NONE : _o.Equipped.Type;
    var _equipped = _o.Equipped == null ? 0 : MonsterTest.EquipmentUnion.Pack(builder, _o.Equipped);
    var _path = default(VectorOffset);
    if (_o.Path != null) {
      StartPathVector(builder, _o.Path.Count);
      for (var _j = _o.Path.Count - 1; _j >= 0; --_j) { MonsterTest.Vec3.Pack(builder, _o.Path[_j]); }
      _path = builder.EndVector();
    }
    return CreateMonster(
      builder,
      _o.Pos,
      _o.Mana,
      _o.Hp,
      _name,
      _inventory,
      _o.Color,
      _weapons,
      _equipped_type,
      _equipped,
      _path);
  }
}

public class MonsterT
{
  public MonsterTest.Vec3T Pos { get; set; }
  public short Mana { get; set; }
  public short Hp { get; set; }
  public string Name { get; set; }
  public List<byte> Inventory { get; set; }
  public MonsterTest.Color Color { get; set; }
  public List<MonsterTest.WeaponT> Weapons { get; set; }
  public MonsterTest.EquipmentUnion Equipped { get; set; }
  public List<MonsterTest.Vec3T> Path { get; set; }

  public MonsterT() {
    this.Pos = new MonsterTest.Vec3T();
    this.Mana = 150;
    this.Hp = 100;
    this.Name = null;
    this.Inventory = null;
    this.Color = MonsterTest.Color.Blue;
    this.Weapons = null;
    this.Equipped = null;
    this.Path = null;
  }
  public static MonsterT DeserializeFromBinary(byte[] fbBuffer) {
    return Monster.GetRootAsMonster(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    Monster.FinishMonsterBuffer(fbb, Monster.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedSpan().ToArray();
  }
}


static public class MonsterVerify
{
  static public bool Verify(ref Google.FlatSpanBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Pos*/, 12 /*MonsterTest.Vec3*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Mana*/, 2 /*short*/, 2, false)
      && verifier.VerifyField(tablePos, 8 /*Hp*/, 2 /*short*/, 2, false)
      && verifier.VerifyString(tablePos, 10 /*Name*/, false)
      && verifier.VerifyVectorOfData(tablePos, 14 /*Inventory*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 16 /*Color*/, 1 /*MonsterTest.Color*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 18 /*Weapons*/, MonsterTest.WeaponVerify.Verify, false)
      && verifier.VerifyField(tablePos, 20 /*EquippedType*/, 1 /*MonsterTest.Equipment*/, 1, false)
      && verifier.VerifyUnion(tablePos, 20, 22 /*Equipped*/, MonsterTest.EquipmentVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 24 /*Path*/, 12 /*MonsterTest.Vec3*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}

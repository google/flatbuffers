// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MonsterTest.StackBuffer
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
public ref struct Monster : IFlatbufferSpanObject
{
  private TableSpan __p;
  public ByteSpanBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Monster GetRootAsMonster(ByteSpanBuffer _bb) { return GetRootAsMonster(_bb, new Monster()); }
  public static Monster GetRootAsMonster(ByteSpanBuffer _bb, Monster obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public static bool VerifyMonster(ByteSpanBuffer _bb) {Google.FlatSpanBuffers.Verifier verifier = new Google.FlatSpanBuffers.Verifier(_bb); return verifier.VerifyBuffer("", false, MonsterTest.MonsterVerify.Verify); }
  public void __init(int _i, ByteSpanBuffer _bb) { __p = new TableSpan(_i, _bb); }
  public Monster __assign(int _i, ByteSpanBuffer _bb) { __init(_i, _bb); return this; }

  public RefStructNullable<MonsterTest.StackBuffer.Vec3> Pos { get { int o = __p.__offset(4); return o != 0 ? new RefStructNullable<MonsterTest.StackBuffer.Vec3>((new MonsterTest.StackBuffer.Vec3()).__assign(o + __p.bb_pos, __p.bb)) : default; } }
  public short Mana { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)150; } }
  public bool MutateMana(short mana) { int o = __p.__offset(6); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, mana); return true; } else { return false; } }
  public short Hp { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)100; } }
  public bool MutateHp(short hp) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, hp); return true; } else { return false; } }
  public string Name { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
  public ReadOnlySpan<byte> GetNameBytes() { return __p.__vector_as_span<byte>(10); }
  public RefStructNullable<Span<byte>> MutableName { get { int o = __p.__offset(10); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(10)) : default; } }
  public RefStructNullable<ReadOnlySpan<byte>> Inventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public RefStructNullable<Span<byte>> MutableInventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public MonsterTest.Color Color { get { int o = __p.__offset(16); return o != 0 ? (MonsterTest.Color)__p.bb.Get<sbyte>(o + __p.bb_pos) : MonsterTest.Color.Blue; } }
  public bool MutateColor(MonsterTest.Color color) { int o = __p.__offset(16); if (o != 0) { __p.bb.Put<sbyte>(o + __p.bb_pos, (sbyte)color); return true; } else { return false; } }
  public RefStructNullable<TableVectorSpan<MonsterTest.StackBuffer.Weapon>> Weapons { get { int o = __p.__offset(18); return o != 0 ? new RefStructNullable<TableVectorSpan<MonsterTest.StackBuffer.Weapon>>(new TableVectorSpan<MonsterTest.StackBuffer.Weapon>(__p, o, 4)) : default; } }
  public MonsterTest.Equipment EquippedType { get { int o = __p.__offset(20); return o != 0 ? (MonsterTest.Equipment)__p.bb.Get<byte>(o + __p.bb_pos) : MonsterTest.Equipment.NONE; } }
  public RefStructNullable<TTable> Equipped<TTable>() where TTable : struct, IFlatbufferSpanObject, allows ref struct { int o = __p.__offset(22); return o != 0 ? new RefStructNullable<TTable>(__p.__union<TTable>(o + __p.bb_pos)) : default; }
  public MonsterTest.StackBuffer.Weapon EquippedAsWeapon() { return Equipped<MonsterTest.StackBuffer.Weapon>().Value; }
  public RefStructNullable<StructVectorSpan<MonsterTest.StackBuffer.Vec3>> Path { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<StructVectorSpan<MonsterTest.StackBuffer.Vec3>>(new StructVectorSpan<MonsterTest.StackBuffer.Vec3>(__p, o, 12)) : default; } }

  public static void StartMonster(ref FlatSpanBufferBuilder builder) { builder.StartTable(11); }
  public static void AddPos(ref FlatSpanBufferBuilder builder, Offset<MonsterTest.StackBuffer.Vec3> posOffset) { builder.AddStruct(0, posOffset, 0); }
  public static void AddMana(ref FlatSpanBufferBuilder builder, short mana) { builder.Add<short>(1, mana, 150); }
  public static void AddHp(ref FlatSpanBufferBuilder builder, short hp) { builder.Add<short>(2, hp, 100); }
  public static void AddName(ref FlatSpanBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(3, nameOffset, 0); }
  public static void AddInventory(ref FlatSpanBufferBuilder builder, VectorOffset inventoryOffset) { builder.AddOffset(5, inventoryOffset, 0); }
  public static VectorOffset CreateInventoryVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateInventoryVector(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { return CreateInventoryVectorBlock(ref builder, data); }
  public static void StartInventoryVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddColor(ref FlatSpanBufferBuilder builder, MonsterTest.Color color) { builder.Add<sbyte>(6, (sbyte)color, 2); }
  public static void AddWeapons(ref FlatSpanBufferBuilder builder, VectorOffset weaponsOffset) { builder.AddOffset(7, weaponsOffset, 0); }
  public static VectorOffset CreateWeaponsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MonsterTest.StackBuffer.Weapon>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MonsterTest.StackBuffer.Weapon>>(data); return builder.EndVector(); }
  public static VectorOffset CreateWeaponsVector(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MonsterTest.StackBuffer.Weapon>> data) { return CreateWeaponsVectorBlock(ref builder, data); }
  public static void StartWeaponsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEquippedType(ref FlatSpanBufferBuilder builder, MonsterTest.Equipment equippedType) { builder.Add<byte>(8, (byte)equippedType, 0); }
  public static void AddEquipped(ref FlatSpanBufferBuilder builder, int equippedOffset) { builder.AddOffset(9, equippedOffset, 0); }
  public static void AddPath(ref FlatSpanBufferBuilder builder, VectorOffset pathOffset) { builder.AddOffset(10, pathOffset, 0); }
  public static void StartPathVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(12, numElems, 4); }
  public static Offset<MonsterTest.StackBuffer.Monster> EndMonster(ref FlatSpanBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<MonsterTest.StackBuffer.Monster>(o);
  }
  public static void FinishMonsterBuffer(ref FlatSpanBufferBuilder builder, Offset<MonsterTest.StackBuffer.Monster> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedMonsterBuffer(ref FlatSpanBufferBuilder builder, Offset<MonsterTest.StackBuffer.Monster> offset) { builder.FinishSizePrefixed(offset.Value); }
  public MonsterT UnPack() {
    var _o = new MonsterT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MonsterT _o) {
    if (this.Pos.HasValue) {
      if (_o.Pos == null) _o.Pos = new MonsterTest.Vec3T();
      this.Pos.Value.UnPackTo(_o.Pos);
    } else {
      _o.Pos = null;
    }
    _o.Mana = this.Mana;
    _o.Hp = this.Hp;
    _o.Name = this.Name;
    var _inventory_vec = this.Inventory;
    var _inventory_len = _inventory_vec.HasValue ? _inventory_vec.Value.Length : 0;
    if (_o.Inventory == null) {
      _o.Inventory = new List<byte>(_inventory_len);
    }
    ObjectApiUtil.ResizeList(_o.Inventory, _inventory_len);
    if (_inventory_vec.HasValue) { _inventory_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Inventory)); }
    _o.Color = this.Color;
    var _weapons_vec = this.Weapons;
    var _weapons_len = _weapons_vec.HasValue ? _weapons_vec.Value.Length : 0;
    if (_o.Weapons == null) {
      _o.Weapons = new List<MonsterTest.WeaponT>(_weapons_len);
    }
    ObjectApiUtil.ResizeList(_o.Weapons, _weapons_len);
    if (_weapons_vec.HasValue) {
      var _weapons_value = _weapons_vec.Value;
      for (var _j = 0; _j < _weapons_len; ++_j) {
        var _src = _weapons_value[_j];
        if (_o.Weapons[_j] == null) { _o.Weapons[_j] = new WeaponT(); }
        _src.UnPackTo(_o.Weapons[_j]);
      }
    }
    if (_o.Equipped == null) {
      _o.Equipped = new MonsterTest.EquipmentUnion();
    }
    var _EquippedOldType = _o.Equipped.Type;
    _o.Equipped.Type = this.EquippedType;
    switch (this.EquippedType) {
      default:
        _o.Equipped.Value = null;
        break;
      case MonsterTest.Equipment.Weapon:
        if (this.Equipped<MonsterTest.StackBuffer.Weapon>().HasValue) {
          if (_EquippedOldType == MonsterTest.Equipment.Weapon) {
            this.Equipped<MonsterTest.StackBuffer.Weapon>().Value.UnPackTo((MonsterTest.WeaponT)_o.Equipped.Value);
          } else {
            _o.Equipped.Value = this.Equipped<MonsterTest.StackBuffer.Weapon>().Value.UnPack();
          }
        } else {
          _o.Equipped.Value = null;
        }
        break;
    }
    var _path_vec = this.Path;
    var _path_len = _path_vec.HasValue ? _path_vec.Value.Length : 0;
    if (_o.Path == null) {
      _o.Path = new List<MonsterTest.Vec3T>(_path_len);
    }
    ObjectApiUtil.ResizeList(_o.Path, _path_len);
    if (_path_vec.HasValue) {
      var _path_value = _path_vec.Value;
      for (var _j = 0; _j < _path_len; ++_j) {
        var _src = _path_value[_j];
        if (_o.Path[_j] == null) { _o.Path[_j] = new Vec3T(); }
        _src.UnPackTo(_o.Path[_j]);
      }
    }
  }
  public static Offset<MonsterTest.StackBuffer.Monster> Pack(ref FlatSpanBufferBuilder builder, MonsterT _o) {
    if (_o == null) return default(Offset<MonsterTest.StackBuffer.Monster>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _inventory = default(VectorOffset);
    if (_o.Inventory != null) {
      _inventory = CreateInventoryVector(ref builder, CollectionsMarshal.AsSpan(_o.Inventory));
    }
    var _weapons = default(VectorOffset);
    if (_o.Weapons != null) {
      var _weapons_len = _o.Weapons.Count;
      Offset<MonsterTest.StackBuffer.Weapon>[] _weapons_arr = null;
      try {
        Span<Offset<MonsterTest.StackBuffer.Weapon>> __weapons = _weapons_len <= 64
          ? stackalloc Offset<MonsterTest.StackBuffer.Weapon>[_weapons_len]
          : (_weapons_arr = ArrayPool<Offset<MonsterTest.StackBuffer.Weapon>>.Shared.Rent(_weapons_len)).AsSpan(0, _weapons_len);
        for (var _j = 0; _j < _weapons_len; ++_j) { __weapons[_j] = MonsterTest.StackBuffer.Weapon.Pack(ref builder, _o.Weapons[_j]); }
        _weapons = CreateWeaponsVector(ref builder, __weapons);
      } finally {
        if (_weapons_arr != null) { ArrayPool<Offset<MonsterTest.StackBuffer.Weapon>>.Shared.Return(_weapons_arr); }
      }
    }
    var _equipped_type = _o.Equipped == null ? MonsterTest.Equipment.NONE : _o.Equipped.Type;
    var _equipped = _o.Equipped == null ? 0 : MonsterTest.EquipmentUnion.Pack(ref builder, _o.Equipped);
    var _path = default(VectorOffset);
    if (_o.Path != null) {
      StartPathVector(ref builder, _o.Path.Count);
      for (var _j = _o.Path.Count - 1; _j >= 0; --_j) { MonsterTest.StackBuffer.Vec3.Pack(ref builder, _o.Path[_j]); }
      _path = builder.EndVector();
    }
    StartMonster(ref builder);
    AddPos(ref builder, MonsterTest.StackBuffer.Vec3.Pack(ref builder, _o.Pos));
    AddMana(ref builder, _o.Mana);
    AddHp(ref builder, _o.Hp);
    AddName(ref builder, _name);
    AddInventory(ref builder, _inventory);
    AddColor(ref builder, _o.Color);
    AddWeapons(ref builder, _weapons);
    AddEquippedType(ref builder, _equipped_type);
    AddEquipped(ref builder, _equipped);
    AddPath(ref builder, _path);
    return EndMonster(ref builder);
  }
}


}

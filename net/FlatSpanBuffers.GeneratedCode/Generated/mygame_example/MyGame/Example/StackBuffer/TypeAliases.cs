// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MyGame.Example.StackBuffer
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
public ref struct TypeAliases : IFlatbufferSpanObject
{
  private TableSpan __p;
  public ByteSpanBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static TypeAliases GetRootAsTypeAliases(ByteSpanBuffer _bb) { return GetRootAsTypeAliases(_bb, new TypeAliases()); }
  public static TypeAliases GetRootAsTypeAliases(ByteSpanBuffer _bb, TypeAliases obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteSpanBuffer _bb) { __p = new TableSpan(_i, _bb); }
  public TypeAliases __assign(int _i, ByteSpanBuffer _bb) { __init(_i, _bb); return this; }

  public sbyte I8 { get { int o = __p.__offset(4); return o != 0 ? __p.bb.Get<sbyte>(o + __p.bb_pos) : (sbyte)0; } }
  public bool MutateI8(sbyte i8) { int o = __p.__offset(4); if (o != 0) { __p.bb.Put<sbyte>(o + __p.bb_pos, i8); return true; } else { return false; } }
  public byte U8 { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get<byte>(o + __p.bb_pos) : (byte)0; } }
  public bool MutateU8(byte u8) { int o = __p.__offset(6); if (o != 0) { __p.bb.PutByte(o + __p.bb_pos, u8); return true; } else { return false; } }
  public short I16 { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)0; } }
  public bool MutateI16(short i16) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, i16); return true; } else { return false; } }
  public ushort U16 { get { int o = __p.__offset(10); return o != 0 ? __p.bb.Get<ushort>(o + __p.bb_pos) : (ushort)0; } }
  public bool MutateU16(ushort u16) { int o = __p.__offset(10); if (o != 0) { __p.bb.Put<ushort>(o + __p.bb_pos, u16); return true; } else { return false; } }
  public int I32 { get { int o = __p.__offset(12); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)0; } }
  public bool MutateI32(int i32) { int o = __p.__offset(12); if (o != 0) { __p.bb.Put<int>(o + __p.bb_pos, i32); return true; } else { return false; } }
  public uint U32 { get { int o = __p.__offset(14); return o != 0 ? __p.bb.Get<uint>(o + __p.bb_pos) : (uint)0; } }
  public bool MutateU32(uint u32) { int o = __p.__offset(14); if (o != 0) { __p.bb.Put<uint>(o + __p.bb_pos, u32); return true; } else { return false; } }
  public long I64 { get { int o = __p.__offset(16); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public bool MutateI64(long i64) { int o = __p.__offset(16); if (o != 0) { __p.bb.Put<long>(o + __p.bb_pos, i64); return true; } else { return false; } }
  public ulong U64 { get { int o = __p.__offset(18); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateU64(ulong u64) { int o = __p.__offset(18); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, u64); return true; } else { return false; } }
  public float F32 { get { int o = __p.__offset(20); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)0.0f; } }
  public bool MutateF32(float f32) { int o = __p.__offset(20); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, f32); return true; } else { return false; } }
  public double F64 { get { int o = __p.__offset(22); return o != 0 ? __p.bb.Get<double>(o + __p.bb_pos) : (double)0.0; } }
  public bool MutateF64(double f64) { int o = __p.__offset(22); if (o != 0) { __p.bb.Put<double>(o + __p.bb_pos, f64); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<sbyte>> V8 { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<ReadOnlySpan<sbyte>>(__p.__vector_as_span<sbyte>(24)) : default; } }
  public RefStructNullable<Span<sbyte>> MutableV8 { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<Span<sbyte>>(__p.__vector_as_span<sbyte>(24)) : default; } }
  public bool MutateV8(int j, sbyte v8) { int o = __p.__offset(24); if (o != 0) { __p.bb.Put<sbyte>(__p.__vector(o) + j * 1, v8); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<double>> Vf64 { get { int o = __p.__offset(26); return o != 0 ? new RefStructNullable<ReadOnlySpan<double>>(__p.__vector_as_span<double>(26)) : default; } }
  public RefStructNullable<Span<double>> MutableVf64 { get { int o = __p.__offset(26); return o != 0 ? new RefStructNullable<Span<double>>(__p.__vector_as_span<double>(26)) : default; } }
  public bool MutateVf64(int j, double vf64) { int o = __p.__offset(26); if (o != 0) { __p.bb.Put<double>(__p.__vector(o) + j * 8, vf64); return true; } else { return false; } }

  public static Offset<MyGame.Example.StackBuffer.TypeAliases> CreateTypeAliases(ref FlatSpanBufferBuilder builder,
      sbyte i8 = 0,
      byte u8 = 0,
      short i16 = 0,
      ushort u16 = 0,
      int i32 = 0,
      uint u32 = 0,
      long i64 = 0,
      ulong u64 = 0,
      float f32 = 0.0f,
      double f64 = 0.0,
      VectorOffset v8Offset = default(VectorOffset),
      VectorOffset vf64Offset = default(VectorOffset)) {
    builder.StartTable(12);
    TypeAliases.AddF64(ref builder, f64);
    TypeAliases.AddU64(ref builder, u64);
    TypeAliases.AddI64(ref builder, i64);
    TypeAliases.AddVf64(ref builder, vf64Offset);
    TypeAliases.AddV8(ref builder, v8Offset);
    TypeAliases.AddF32(ref builder, f32);
    TypeAliases.AddU32(ref builder, u32);
    TypeAliases.AddI32(ref builder, i32);
    TypeAliases.AddU16(ref builder, u16);
    TypeAliases.AddI16(ref builder, i16);
    TypeAliases.AddU8(ref builder, u8);
    TypeAliases.AddI8(ref builder, i8);
    return TypeAliases.EndTypeAliases(ref builder);
  }

  public static void StartTypeAliases(ref FlatSpanBufferBuilder builder) { builder.StartTable(12); }
  public static void AddI8(ref FlatSpanBufferBuilder builder, sbyte i8) { builder.Add<sbyte>(0, i8, 0); }
  public static void AddU8(ref FlatSpanBufferBuilder builder, byte u8) { builder.Add<byte>(1, u8, 0); }
  public static void AddI16(ref FlatSpanBufferBuilder builder, short i16) { builder.Add<short>(2, i16, 0); }
  public static void AddU16(ref FlatSpanBufferBuilder builder, ushort u16) { builder.Add<ushort>(3, u16, 0); }
  public static void AddI32(ref FlatSpanBufferBuilder builder, int i32) { builder.Add<int>(4, i32, 0); }
  public static void AddU32(ref FlatSpanBufferBuilder builder, uint u32) { builder.Add<uint>(5, u32, 0); }
  public static void AddI64(ref FlatSpanBufferBuilder builder, long i64) { builder.Add<long>(6, i64, 0); }
  public static void AddU64(ref FlatSpanBufferBuilder builder, ulong u64) { builder.Add<ulong>(7, u64, 0); }
  public static void AddF32(ref FlatSpanBufferBuilder builder, float f32) { builder.Add<float>(8, f32, 0.0f); }
  public static void AddF64(ref FlatSpanBufferBuilder builder, double f64) { builder.Add<double>(9, f64, 0.0); }
  public static void AddV8(ref FlatSpanBufferBuilder builder, VectorOffset v8Offset) { builder.AddOffset(10, v8Offset, 0); }
  public static VectorOffset CreateV8VectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<sbyte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<sbyte>(data); return builder.EndVector(); }
  public static VectorOffset CreateV8Vector(ref FlatSpanBufferBuilder builder, scoped Span<sbyte> data) { return CreateV8VectorBlock(ref builder, data); }
  public static void StartV8Vector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddVf64(ref FlatSpanBufferBuilder builder, VectorOffset vf64Offset) { builder.AddOffset(11, vf64Offset, 0); }
  public static VectorOffset CreateVf64VectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<double> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<double>(data); return builder.EndVector(); }
  public static VectorOffset CreateVf64Vector(ref FlatSpanBufferBuilder builder, scoped Span<double> data) { return CreateVf64VectorBlock(ref builder, data); }
  public static void StartVf64Vector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<MyGame.Example.StackBuffer.TypeAliases> EndTypeAliases(ref FlatSpanBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<MyGame.Example.StackBuffer.TypeAliases>(o);
  }
  public TypeAliasesT UnPack() {
    var _o = new TypeAliasesT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TypeAliasesT _o) {
    _o.I8 = this.I8;
    _o.U8 = this.U8;
    _o.I16 = this.I16;
    _o.U16 = this.U16;
    _o.I32 = this.I32;
    _o.U32 = this.U32;
    _o.I64 = this.I64;
    _o.U64 = this.U64;
    _o.F32 = this.F32;
    _o.F64 = this.F64;
    var _v8_vec = this.V8;
    var _v8_len = _v8_vec.HasValue ? _v8_vec.Value.Length : 0;
    if (_o.V8 == null) {
      _o.V8 = new List<sbyte>(_v8_len);
    }
    ObjectApiUtil.ResizeList(_o.V8, _v8_len);
    if (_v8_vec.HasValue) { _v8_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.V8)); }
    var _vf64_vec = this.Vf64;
    var _vf64_len = _vf64_vec.HasValue ? _vf64_vec.Value.Length : 0;
    if (_o.Vf64 == null) {
      _o.Vf64 = new List<double>(_vf64_len);
    }
    ObjectApiUtil.ResizeList(_o.Vf64, _vf64_len);
    if (_vf64_vec.HasValue) { _vf64_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Vf64)); }
  }
  public static Offset<MyGame.Example.StackBuffer.TypeAliases> Pack(ref FlatSpanBufferBuilder builder, TypeAliasesT _o) {
    if (_o == null) return default(Offset<MyGame.Example.StackBuffer.TypeAliases>);
    var _v8 = default(VectorOffset);
    if (_o.V8 != null) {
      _v8 = CreateV8Vector(ref builder, CollectionsMarshal.AsSpan(_o.V8));
    }
    var _vf64 = default(VectorOffset);
    if (_o.Vf64 != null) {
      _vf64 = CreateVf64Vector(ref builder, CollectionsMarshal.AsSpan(_o.Vf64));
    }
    return CreateTypeAliases(
      ref builder,
      _o.I8,
      _o.U8,
      _o.I16,
      _o.U16,
      _o.I32,
      _o.U32,
      _o.I64,
      _o.U64,
      _o.F32,
      _o.F64,
      _v8,
      _vf64);
  }
}


}

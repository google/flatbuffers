// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MyGame.Example.StackBuffer
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
/// an example documentation comment: "monster object"
public ref struct Monster : IFlatbufferSpanObject
{
  private TableSpan __p;
  public ByteSpanBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Monster GetRootAsMonster(ByteSpanBuffer _bb) { return GetRootAsMonster(_bb, new Monster()); }
  public static Monster GetRootAsMonster(ByteSpanBuffer _bb, Monster obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public static bool MonsterBufferHasIdentifier(ByteSpanBuffer _bb) { return TableSpan.__has_identifier(_bb, "MONS"); }
  public static bool VerifyMonster(ByteSpanBuffer _bb) {Google.FlatSpanBuffers.Verifier verifier = new Google.FlatSpanBuffers.Verifier(_bb); return verifier.VerifyBuffer("MONS", false, MyGame.Example.MonsterVerify.Verify); }
  public void __init(int _i, ByteSpanBuffer _bb) { __p = new TableSpan(_i, _bb); }
  public Monster __assign(int _i, ByteSpanBuffer _bb) { __init(_i, _bb); return this; }

  public RefStructNullable<MyGame.Example.StackBuffer.Vec3> Pos { get { int o = __p.__offset(4); return o != 0 ? new RefStructNullable<MyGame.Example.StackBuffer.Vec3>((new MyGame.Example.StackBuffer.Vec3()).__assign(o + __p.bb_pos, __p.bb)) : default; } }
  public short Mana { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)150; } }
  public bool MutateMana(short mana) { int o = __p.__offset(6); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, mana); return true; } else { return false; } }
  public short Hp { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)100; } }
  public bool MutateHp(short hp) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, hp); return true; } else { return false; } }
  public string Name { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
  public ReadOnlySpan<byte> GetNameBytes() { return __p.__vector_as_span<byte>(10); }
  public RefStructNullable<Span<byte>> MutableName { get { int o = __p.__offset(10); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(10)) : default; } }
  public RefStructNullable<ReadOnlySpan<byte>> Inventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public RefStructNullable<Span<byte>> MutableInventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public MyGame.Example.Color Color { get { int o = __p.__offset(16); return o != 0 ? (MyGame.Example.Color)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.Color.Blue; } }
  public bool MutateColor(MyGame.Example.Color color) { int o = __p.__offset(16); if (o != 0) { __p.bb.PutByte(o + __p.bb_pos, (byte)color); return true; } else { return false; } }
  public MyGame.Example.Any TestType { get { int o = __p.__offset(18); return o != 0 ? (MyGame.Example.Any)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.Any.NONE; } }
  public RefStructNullable<TTable> Test<TTable>() where TTable : struct, IFlatbufferSpanObject, allows ref struct { int o = __p.__offset(20); return o != 0 ? new RefStructNullable<TTable>(__p.__union<TTable>(o + __p.bb_pos)) : default; }
  public MyGame.Example.StackBuffer.Monster TestAsMonster() { return Test<MyGame.Example.StackBuffer.Monster>().Value; }
  public MyGame.Example.StackBuffer.TestSimpleTableWithEnum TestAsTestSimpleTableWithEnum() { return Test<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().Value; }
  public MyGame.Example2.StackBuffer.Monster TestAsMyGame_Example2_Monster() { return Test<MyGame.Example2.StackBuffer.Monster>().Value; }
  public RefStructNullable<StructVectorSpan<MyGame.Example.StackBuffer.Test>> Test4 { get { int o = __p.__offset(22); return o != 0 ? new RefStructNullable<StructVectorSpan<MyGame.Example.StackBuffer.Test>>(new StructVectorSpan<MyGame.Example.StackBuffer.Test>(__p, o, 4)) : default; } }
  public RefStructNullable<StringVectorSpan> Testarrayofstring { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<StringVectorSpan>(new StringVectorSpan(__p, o)) : default; } }
  /// an example documentation comment: this will end up in the generated code
  /// multiline too
  public RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Monster>> Testarrayoftables { get { int o = __p.__offset(26); return o != 0 ? new RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Monster>>(new TableVectorSpan<MyGame.Example.StackBuffer.Monster>(__p, o, 4)) : default; } }
  public bool TryGetTestarrayoftablesByKey(string key, out MyGame.Example.StackBuffer.Monster value) { int o = __p.__offset(26); if (o != 0) { return MyGame.Example.StackBuffer.Monster.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public RefStructNullable<MyGame.Example.StackBuffer.Monster> Enemy { get { int o = __p.__offset(28); return o != 0 ? new RefStructNullable<MyGame.Example.StackBuffer.Monster>((new MyGame.Example.StackBuffer.Monster()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb)) : default; } }
  public RefStructNullable<ReadOnlySpan<byte>> Testnestedflatbuffer { get { int o = __p.__offset(30); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(30)) : default; } }
  public RefStructNullable<Span<byte>> MutableTestnestedflatbuffer { get { int o = __p.__offset(30); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(30)) : default; } }
  public MyGame.Example.StackBuffer.Monster GetTestnestedflatbufferAsMonster() { int o = __p.__offset(30); return o != 0 ? (new MyGame.Example.StackBuffer.Monster()).__assign(__p.__indirect(__p.__vector(o)), __p.bb) : default; }
  public RefStructNullable<MyGame.Example.StackBuffer.Stat> Testempty { get { int o = __p.__offset(32); return o != 0 ? new RefStructNullable<MyGame.Example.StackBuffer.Stat>((new MyGame.Example.StackBuffer.Stat()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb)) : default; } }
  public bool Testbool { get { int o = __p.__offset(34); return o != 0 ? __p.bb.Get<bool>(o + __p.bb_pos) : (bool)false; } }
  public bool MutateTestbool(bool testbool) { int o = __p.__offset(34); if (o != 0) { __p.bb.PutByte(o + __p.bb_pos, (byte)(testbool ? 1 : 0)); return true; } else { return false; } }
  public int Testhashs32Fnv1 { get { int o = __p.__offset(36); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)0; } }
  public bool MutateTesthashs32Fnv1(int testhashs32_fnv1) { int o = __p.__offset(36); if (o != 0) { __p.bb.Put<int>(o + __p.bb_pos, testhashs32_fnv1); return true; } else { return false; } }
  public uint Testhashu32Fnv1 { get { int o = __p.__offset(38); return o != 0 ? __p.bb.Get<uint>(o + __p.bb_pos) : (uint)0; } }
  public bool MutateTesthashu32Fnv1(uint testhashu32_fnv1) { int o = __p.__offset(38); if (o != 0) { __p.bb.Put<uint>(o + __p.bb_pos, testhashu32_fnv1); return true; } else { return false; } }
  public long Testhashs64Fnv1 { get { int o = __p.__offset(40); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public bool MutateTesthashs64Fnv1(long testhashs64_fnv1) { int o = __p.__offset(40); if (o != 0) { __p.bb.Put<long>(o + __p.bb_pos, testhashs64_fnv1); return true; } else { return false; } }
  public ulong Testhashu64Fnv1 { get { int o = __p.__offset(42); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateTesthashu64Fnv1(ulong testhashu64_fnv1) { int o = __p.__offset(42); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, testhashu64_fnv1); return true; } else { return false; } }
  public int Testhashs32Fnv1a { get { int o = __p.__offset(44); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)0; } }
  public bool MutateTesthashs32Fnv1a(int testhashs32_fnv1a) { int o = __p.__offset(44); if (o != 0) { __p.bb.Put<int>(o + __p.bb_pos, testhashs32_fnv1a); return true; } else { return false; } }
  public uint Testhashu32Fnv1a { get { int o = __p.__offset(46); return o != 0 ? __p.bb.Get<uint>(o + __p.bb_pos) : (uint)0; } }
  public bool MutateTesthashu32Fnv1a(uint testhashu32_fnv1a) { int o = __p.__offset(46); if (o != 0) { __p.bb.Put<uint>(o + __p.bb_pos, testhashu32_fnv1a); return true; } else { return false; } }
  public long Testhashs64Fnv1a { get { int o = __p.__offset(48); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public bool MutateTesthashs64Fnv1a(long testhashs64_fnv1a) { int o = __p.__offset(48); if (o != 0) { __p.bb.Put<long>(o + __p.bb_pos, testhashs64_fnv1a); return true; } else { return false; } }
  public ulong Testhashu64Fnv1a { get { int o = __p.__offset(50); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateTesthashu64Fnv1a(ulong testhashu64_fnv1a) { int o = __p.__offset(50); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, testhashu64_fnv1a); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<bool>> Testarrayofbools { get { int o = __p.__offset(52); return o != 0 ? new RefStructNullable<ReadOnlySpan<bool>>(__p.__vector_as_span<bool>(52)) : default; } }
  public RefStructNullable<Span<bool>> MutableTestarrayofbools { get { int o = __p.__offset(52); return o != 0 ? new RefStructNullable<Span<bool>>(__p.__vector_as_span<bool>(52)) : default; } }
  public float Testf { get { int o = __p.__offset(54); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)3.14159f; } }
  public bool MutateTestf(float testf) { int o = __p.__offset(54); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, testf); return true; } else { return false; } }
  public float Testf2 { get { int o = __p.__offset(56); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)3.0f; } }
  public bool MutateTestf2(float testf2) { int o = __p.__offset(56); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, testf2); return true; } else { return false; } }
  public float Testf3 { get { int o = __p.__offset(58); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)0.0f; } }
  public bool MutateTestf3(float testf3) { int o = __p.__offset(58); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, testf3); return true; } else { return false; } }
  public RefStructNullable<StringVectorSpan> Testarrayofstring2 { get { int o = __p.__offset(60); return o != 0 ? new RefStructNullable<StringVectorSpan>(new StringVectorSpan(__p, o)) : default; } }
  public RefStructNullable<StructVectorSpan<MyGame.Example.StackBuffer.Ability>> Testarrayofsortedstruct { get { int o = __p.__offset(62); return o != 0 ? new RefStructNullable<StructVectorSpan<MyGame.Example.StackBuffer.Ability>>(new StructVectorSpan<MyGame.Example.StackBuffer.Ability>(__p, o, 8)) : default; } }
  public RefStructNullable<ReadOnlySpan<byte>> Flex { get { int o = __p.__offset(64); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(64)) : default; } }
  public RefStructNullable<Span<byte>> MutableFlex { get { int o = __p.__offset(64); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(64)) : default; } }
  public RefStructNullable<StructVectorSpan<MyGame.Example.StackBuffer.Test>> Test5 { get { int o = __p.__offset(66); return o != 0 ? new RefStructNullable<StructVectorSpan<MyGame.Example.StackBuffer.Test>>(new StructVectorSpan<MyGame.Example.StackBuffer.Test>(__p, o, 4)) : default; } }
  public RefStructNullable<ReadOnlySpan<long>> VectorOfLongs { get { int o = __p.__offset(68); return o != 0 ? new RefStructNullable<ReadOnlySpan<long>>(__p.__vector_as_span<long>(68)) : default; } }
  public RefStructNullable<Span<long>> MutableVectorOfLongs { get { int o = __p.__offset(68); return o != 0 ? new RefStructNullable<Span<long>>(__p.__vector_as_span<long>(68)) : default; } }
  public RefStructNullable<ReadOnlySpan<double>> VectorOfDoubles { get { int o = __p.__offset(70); return o != 0 ? new RefStructNullable<ReadOnlySpan<double>>(__p.__vector_as_span<double>(70)) : default; } }
  public RefStructNullable<Span<double>> MutableVectorOfDoubles { get { int o = __p.__offset(70); return o != 0 ? new RefStructNullable<Span<double>>(__p.__vector_as_span<double>(70)) : default; } }
  public RefStructNullable<MyGame.StackBuffer.InParentNamespace> ParentNamespaceTest { get { int o = __p.__offset(72); return o != 0 ? new RefStructNullable<MyGame.StackBuffer.InParentNamespace>((new MyGame.StackBuffer.InParentNamespace()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb)) : default; } }
  public RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Referrable>> VectorOfReferrables { get { int o = __p.__offset(74); return o != 0 ? new RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Referrable>>(new TableVectorSpan<MyGame.Example.StackBuffer.Referrable>(__p, o, 4)) : default; } }
  public bool TryGetVectorOfReferrablesByKey(ulong key, out MyGame.Example.StackBuffer.Referrable value) { int o = __p.__offset(74); if (o != 0) { return MyGame.Example.StackBuffer.Referrable.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public ulong SingleWeakReference { get { int o = __p.__offset(76); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateSingleWeakReference(ulong single_weak_reference) { int o = __p.__offset(76); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, single_weak_reference); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<ulong>> VectorOfWeakReferences { get { int o = __p.__offset(78); return o != 0 ? new RefStructNullable<ReadOnlySpan<ulong>>(__p.__vector_as_span<ulong>(78)) : default; } }
  public RefStructNullable<Span<ulong>> MutableVectorOfWeakReferences { get { int o = __p.__offset(78); return o != 0 ? new RefStructNullable<Span<ulong>>(__p.__vector_as_span<ulong>(78)) : default; } }
  public RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Referrable>> VectorOfStrongReferrables { get { int o = __p.__offset(80); return o != 0 ? new RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Referrable>>(new TableVectorSpan<MyGame.Example.StackBuffer.Referrable>(__p, o, 4)) : default; } }
  public bool TryGetVectorOfStrongReferrablesByKey(ulong key, out MyGame.Example.StackBuffer.Referrable value) { int o = __p.__offset(80); if (o != 0) { return MyGame.Example.StackBuffer.Referrable.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public ulong CoOwningReference { get { int o = __p.__offset(82); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateCoOwningReference(ulong co_owning_reference) { int o = __p.__offset(82); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, co_owning_reference); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<ulong>> VectorOfCoOwningReferences { get { int o = __p.__offset(84); return o != 0 ? new RefStructNullable<ReadOnlySpan<ulong>>(__p.__vector_as_span<ulong>(84)) : default; } }
  public RefStructNullable<Span<ulong>> MutableVectorOfCoOwningReferences { get { int o = __p.__offset(84); return o != 0 ? new RefStructNullable<Span<ulong>>(__p.__vector_as_span<ulong>(84)) : default; } }
  public ulong NonOwningReference { get { int o = __p.__offset(86); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateNonOwningReference(ulong non_owning_reference) { int o = __p.__offset(86); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, non_owning_reference); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<ulong>> VectorOfNonOwningReferences { get { int o = __p.__offset(88); return o != 0 ? new RefStructNullable<ReadOnlySpan<ulong>>(__p.__vector_as_span<ulong>(88)) : default; } }
  public RefStructNullable<Span<ulong>> MutableVectorOfNonOwningReferences { get { int o = __p.__offset(88); return o != 0 ? new RefStructNullable<Span<ulong>>(__p.__vector_as_span<ulong>(88)) : default; } }
  public MyGame.Example.AnyUniqueAliases AnyUniqueType { get { int o = __p.__offset(90); return o != 0 ? (MyGame.Example.AnyUniqueAliases)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.AnyUniqueAliases.NONE; } }
  public RefStructNullable<TTable> AnyUnique<TTable>() where TTable : struct, IFlatbufferSpanObject, allows ref struct { int o = __p.__offset(92); return o != 0 ? new RefStructNullable<TTable>(__p.__union<TTable>(o + __p.bb_pos)) : default; }
  public MyGame.Example.StackBuffer.Monster AnyUniqueAsM() { return AnyUnique<MyGame.Example.StackBuffer.Monster>().Value; }
  public MyGame.Example.StackBuffer.TestSimpleTableWithEnum AnyUniqueAsTS() { return AnyUnique<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().Value; }
  public MyGame.Example2.StackBuffer.Monster AnyUniqueAsM2() { return AnyUnique<MyGame.Example2.StackBuffer.Monster>().Value; }
  public MyGame.Example.AnyAmbiguousAliases AnyAmbiguousType { get { int o = __p.__offset(94); return o != 0 ? (MyGame.Example.AnyAmbiguousAliases)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.AnyAmbiguousAliases.NONE; } }
  public RefStructNullable<TTable> AnyAmbiguous<TTable>() where TTable : struct, IFlatbufferSpanObject, allows ref struct { int o = __p.__offset(96); return o != 0 ? new RefStructNullable<TTable>(__p.__union<TTable>(o + __p.bb_pos)) : default; }
  public MyGame.Example.StackBuffer.Monster AnyAmbiguousAsM1() { return AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value; }
  public MyGame.Example.StackBuffer.Monster AnyAmbiguousAsM2() { return AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value; }
  public MyGame.Example.StackBuffer.Monster AnyAmbiguousAsM3() { return AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value; }
  public RefStructNullable<ReadOnlySpan<MyGame.Example.Color>> VectorOfEnums { get { int o = __p.__offset(98); return o != 0 ? new RefStructNullable<ReadOnlySpan<MyGame.Example.Color>>(__p.__vector_as_span<MyGame.Example.Color>(98)) : default; } }
  public RefStructNullable<Span<MyGame.Example.Color>> MutableVectorOfEnums { get { int o = __p.__offset(98); return o != 0 ? new RefStructNullable<Span<MyGame.Example.Color>>(__p.__vector_as_span<MyGame.Example.Color>(98)) : default; } }
  public MyGame.Example.Race SignedEnum { get { int o = __p.__offset(100); return o != 0 ? (MyGame.Example.Race)__p.bb.Get<sbyte>(o + __p.bb_pos) : MyGame.Example.Race.None; } }
  public bool MutateSignedEnum(MyGame.Example.Race signed_enum) { int o = __p.__offset(100); if (o != 0) { __p.bb.Put<sbyte>(o + __p.bb_pos, (sbyte)signed_enum); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<byte>> Testrequirednestedflatbuffer { get { int o = __p.__offset(102); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(102)) : default; } }
  public RefStructNullable<Span<byte>> MutableTestrequirednestedflatbuffer { get { int o = __p.__offset(102); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(102)) : default; } }
  public MyGame.Example.StackBuffer.Monster GetTestrequirednestedflatbufferAsMonster() { int o = __p.__offset(102); return o != 0 ? (new MyGame.Example.StackBuffer.Monster()).__assign(__p.__indirect(__p.__vector(o)), __p.bb) : default; }
  public RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Stat>> ScalarKeySortedTables { get { int o = __p.__offset(104); return o != 0 ? new RefStructNullable<TableVectorSpan<MyGame.Example.StackBuffer.Stat>>(new TableVectorSpan<MyGame.Example.StackBuffer.Stat>(__p, o, 4)) : default; } }
  public bool TryGetScalarKeySortedTablesByKey(ushort key, out MyGame.Example.StackBuffer.Stat value) { int o = __p.__offset(104); if (o != 0) { return MyGame.Example.StackBuffer.Stat.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public RefStructNullable<MyGame.Example.StackBuffer.Test> NativeInline { get { int o = __p.__offset(106); return o != 0 ? new RefStructNullable<MyGame.Example.StackBuffer.Test>((new MyGame.Example.StackBuffer.Test()).__assign(o + __p.bb_pos, __p.bb)) : default; } }
  public MyGame.Example.LongEnum LongEnumNonEnumDefault { get { int o = __p.__offset(108); return o != 0 ? (MyGame.Example.LongEnum)__p.bb.Get<ulong>(o + __p.bb_pos) : 0; } }
  public bool MutateLongEnumNonEnumDefault(MyGame.Example.LongEnum long_enum_non_enum_default) { int o = __p.__offset(108); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, (ulong)long_enum_non_enum_default); return true; } else { return false; } }
  public MyGame.Example.LongEnum LongEnumNormalDefault { get { int o = __p.__offset(110); return o != 0 ? (MyGame.Example.LongEnum)__p.bb.Get<ulong>(o + __p.bb_pos) : MyGame.Example.LongEnum.LongOne; } }
  public bool MutateLongEnumNormalDefault(MyGame.Example.LongEnum long_enum_normal_default) { int o = __p.__offset(110); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, (ulong)long_enum_normal_default); return true; } else { return false; } }
  public float NanDefault { get { int o = __p.__offset(112); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.NaN; } }
  public bool MutateNanDefault(float nan_default) { int o = __p.__offset(112); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, nan_default); return true; } else { return false; } }
  public float InfDefault { get { int o = __p.__offset(114); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutateInfDefault(float inf_default) { int o = __p.__offset(114); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, inf_default); return true; } else { return false; } }
  public float PositiveInfDefault { get { int o = __p.__offset(116); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutatePositiveInfDefault(float positive_inf_default) { int o = __p.__offset(116); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, positive_inf_default); return true; } else { return false; } }
  public float InfinityDefault { get { int o = __p.__offset(118); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutateInfinityDefault(float infinity_default) { int o = __p.__offset(118); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, infinity_default); return true; } else { return false; } }
  public float PositiveInfinityDefault { get { int o = __p.__offset(120); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutatePositiveInfinityDefault(float positive_infinity_default) { int o = __p.__offset(120); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, positive_infinity_default); return true; } else { return false; } }
  public float NegativeInfDefault { get { int o = __p.__offset(122); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.NegativeInfinity; } }
  public bool MutateNegativeInfDefault(float negative_inf_default) { int o = __p.__offset(122); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, negative_inf_default); return true; } else { return false; } }
  public float NegativeInfinityDefault { get { int o = __p.__offset(124); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.NegativeInfinity; } }
  public bool MutateNegativeInfinityDefault(float negative_infinity_default) { int o = __p.__offset(124); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, negative_infinity_default); return true; } else { return false; } }
  public double DoubleInfDefault { get { int o = __p.__offset(126); return o != 0 ? __p.bb.Get<double>(o + __p.bb_pos) : (double)Double.PositiveInfinity; } }
  public bool MutateDoubleInfDefault(double double_inf_default) { int o = __p.__offset(126); if (o != 0) { __p.bb.Put<double>(o + __p.bb_pos, double_inf_default); return true; } else { return false; } }

  public static void StartMonster(ref FlatSpanBufferBuilder builder) { builder.StartTable(62); }
  public static void AddPos(ref FlatSpanBufferBuilder builder, Offset<MyGame.Example.StackBuffer.Vec3> posOffset) { builder.AddStruct(0, posOffset, 0); }
  public static void AddMana(ref FlatSpanBufferBuilder builder, short mana) { builder.Add<short>(1, mana, 150); }
  public static void AddHp(ref FlatSpanBufferBuilder builder, short hp) { builder.Add<short>(2, hp, 100); }
  public static void AddName(ref FlatSpanBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(3, nameOffset, 0); }
  public static void AddInventory(ref FlatSpanBufferBuilder builder, VectorOffset inventoryOffset) { builder.AddOffset(5, inventoryOffset, 0); }
  public static VectorOffset CreateInventoryVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateInventoryVector(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { return CreateInventoryVectorBlock(ref builder, data); }
  public static void StartInventoryVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddColor(ref FlatSpanBufferBuilder builder, MyGame.Example.Color color) { builder.Add<byte>(6, (byte)color, 8); }
  public static void AddTestType(ref FlatSpanBufferBuilder builder, MyGame.Example.Any testType) { builder.Add<byte>(7, (byte)testType, 0); }
  public static void AddTest(ref FlatSpanBufferBuilder builder, int testOffset) { builder.AddOffset(8, testOffset, 0); }
  public static void AddTest4(ref FlatSpanBufferBuilder builder, VectorOffset test4Offset) { builder.AddOffset(9, test4Offset, 0); }
  public static void StartTest4Vector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 2); }
  public static void AddTestarrayofstring(ref FlatSpanBufferBuilder builder, VectorOffset testarrayofstringOffset) { builder.AddOffset(10, testarrayofstringOffset, 0); }
  public static VectorOffset CreateTestarrayofstringVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<StringOffset>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayofstringVector(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { return CreateTestarrayofstringVectorBlock(ref builder, data); }
  public static void StartTestarrayofstringVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTestarrayoftables(ref FlatSpanBufferBuilder builder, VectorOffset testarrayoftablesOffset) { builder.AddOffset(11, testarrayoftablesOffset, 0); }
  public static VectorOffset CreateTestarrayoftablesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Monster>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.StackBuffer.Monster>>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayoftablesVector(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Monster>> data) { return CreateTestarrayoftablesVectorBlock(ref builder, data); }
  public static void StartTestarrayoftablesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEnemy(ref FlatSpanBufferBuilder builder, Offset<MyGame.Example.StackBuffer.Monster> enemyOffset) { builder.AddOffset(12, enemyOffset, 0); }
  public static void AddTestnestedflatbuffer(ref FlatSpanBufferBuilder builder, VectorOffset testnestedflatbufferOffset) { builder.AddOffset(13, testnestedflatbufferOffset, 0); }
  public static VectorOffset CreateTestnestedflatbufferVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestnestedflatbufferVector(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { return CreateTestnestedflatbufferVectorBlock(ref builder, data); }
  public static void StartTestnestedflatbufferVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTestempty(ref FlatSpanBufferBuilder builder, Offset<MyGame.Example.StackBuffer.Stat> testemptyOffset) { builder.AddOffset(14, testemptyOffset, 0); }
  public static void AddTestbool(ref FlatSpanBufferBuilder builder, bool testbool) { builder.Add<bool>(15, testbool, false); }
  public static void AddTesthashs32Fnv1(ref FlatSpanBufferBuilder builder, int testhashs32Fnv1) { builder.Add<int>(16, testhashs32Fnv1, 0); }
  public static void AddTesthashu32Fnv1(ref FlatSpanBufferBuilder builder, uint testhashu32Fnv1) { builder.Add<uint>(17, testhashu32Fnv1, 0); }
  public static void AddTesthashs64Fnv1(ref FlatSpanBufferBuilder builder, long testhashs64Fnv1) { builder.Add<long>(18, testhashs64Fnv1, 0); }
  public static void AddTesthashu64Fnv1(ref FlatSpanBufferBuilder builder, ulong testhashu64Fnv1) { builder.Add<ulong>(19, testhashu64Fnv1, 0); }
  public static void AddTesthashs32Fnv1a(ref FlatSpanBufferBuilder builder, int testhashs32Fnv1a) { builder.Add<int>(20, testhashs32Fnv1a, 0); }
  public static void AddTesthashu32Fnv1a(ref FlatSpanBufferBuilder builder, uint testhashu32Fnv1a) { builder.Add<uint>(21, testhashu32Fnv1a, 0); }
  public static void AddTesthashs64Fnv1a(ref FlatSpanBufferBuilder builder, long testhashs64Fnv1a) { builder.Add<long>(22, testhashs64Fnv1a, 0); }
  public static void AddTesthashu64Fnv1a(ref FlatSpanBufferBuilder builder, ulong testhashu64Fnv1a) { builder.Add<ulong>(23, testhashu64Fnv1a, 0); }
  public static void AddTestarrayofbools(ref FlatSpanBufferBuilder builder, VectorOffset testarrayofboolsOffset) { builder.AddOffset(24, testarrayofboolsOffset, 0); }
  public static VectorOffset CreateTestarrayofboolsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<bool> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<bool>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayofboolsVector(ref FlatSpanBufferBuilder builder, scoped Span<bool> data) { return CreateTestarrayofboolsVectorBlock(ref builder, data); }
  public static void StartTestarrayofboolsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTestf(ref FlatSpanBufferBuilder builder, float testf) { builder.Add<float>(25, testf, 3.14159f); }
  public static void AddTestf2(ref FlatSpanBufferBuilder builder, float testf2) { builder.Add<float>(26, testf2, 3.0f); }
  public static void AddTestf3(ref FlatSpanBufferBuilder builder, float testf3) { builder.Add<float>(27, testf3, 0.0f); }
  public static void AddTestarrayofstring2(ref FlatSpanBufferBuilder builder, VectorOffset testarrayofstring2Offset) { builder.AddOffset(28, testarrayofstring2Offset, 0); }
  public static VectorOffset CreateTestarrayofstring2VectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<StringOffset>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayofstring2Vector(ref FlatSpanBufferBuilder builder, scoped Span<StringOffset> data) { return CreateTestarrayofstring2VectorBlock(ref builder, data); }
  public static void StartTestarrayofstring2Vector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTestarrayofsortedstruct(ref FlatSpanBufferBuilder builder, VectorOffset testarrayofsortedstructOffset) { builder.AddOffset(29, testarrayofsortedstructOffset, 0); }
  public static void StartTestarrayofsortedstructVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 4); }
  public static void AddFlex(ref FlatSpanBufferBuilder builder, VectorOffset flexOffset) { builder.AddOffset(30, flexOffset, 0); }
  public static VectorOffset CreateFlexVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateFlexVector(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { return CreateFlexVectorBlock(ref builder, data); }
  public static void StartFlexVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTest5(ref FlatSpanBufferBuilder builder, VectorOffset test5Offset) { builder.AddOffset(31, test5Offset, 0); }
  public static void StartTest5Vector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 2); }
  public static void AddVectorOfLongs(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfLongsOffset) { builder.AddOffset(32, vectorOfLongsOffset, 0); }
  public static VectorOffset CreateVectorOfLongsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<long> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<long>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfLongsVector(ref FlatSpanBufferBuilder builder, scoped Span<long> data) { return CreateVectorOfLongsVectorBlock(ref builder, data); }
  public static void StartVectorOfLongsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddVectorOfDoubles(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfDoublesOffset) { builder.AddOffset(33, vectorOfDoublesOffset, 0); }
  public static VectorOffset CreateVectorOfDoublesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<double> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<double>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfDoublesVector(ref FlatSpanBufferBuilder builder, scoped Span<double> data) { return CreateVectorOfDoublesVectorBlock(ref builder, data); }
  public static void StartVectorOfDoublesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddParentNamespaceTest(ref FlatSpanBufferBuilder builder, Offset<MyGame.StackBuffer.InParentNamespace> parentNamespaceTestOffset) { builder.AddOffset(34, parentNamespaceTestOffset, 0); }
  public static void AddVectorOfReferrables(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfReferrablesOffset) { builder.AddOffset(35, vectorOfReferrablesOffset, 0); }
  public static VectorOffset CreateVectorOfReferrablesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Referrable>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.StackBuffer.Referrable>>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfReferrablesVector(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Referrable>> data) { return CreateVectorOfReferrablesVectorBlock(ref builder, data); }
  public static void StartVectorOfReferrablesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSingleWeakReference(ref FlatSpanBufferBuilder builder, ulong singleWeakReference) { builder.Add<ulong>(36, singleWeakReference, 0); }
  public static void AddVectorOfWeakReferences(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfWeakReferencesOffset) { builder.AddOffset(37, vectorOfWeakReferencesOffset, 0); }
  public static VectorOffset CreateVectorOfWeakReferencesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<ulong> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<ulong>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfWeakReferencesVector(ref FlatSpanBufferBuilder builder, scoped Span<ulong> data) { return CreateVectorOfWeakReferencesVectorBlock(ref builder, data); }
  public static void StartVectorOfWeakReferencesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddVectorOfStrongReferrables(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfStrongReferrablesOffset) { builder.AddOffset(38, vectorOfStrongReferrablesOffset, 0); }
  public static VectorOffset CreateVectorOfStrongReferrablesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Referrable>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.StackBuffer.Referrable>>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfStrongReferrablesVector(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Referrable>> data) { return CreateVectorOfStrongReferrablesVectorBlock(ref builder, data); }
  public static void StartVectorOfStrongReferrablesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCoOwningReference(ref FlatSpanBufferBuilder builder, ulong coOwningReference) { builder.Add<ulong>(39, coOwningReference, 0); }
  public static void AddVectorOfCoOwningReferences(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfCoOwningReferencesOffset) { builder.AddOffset(40, vectorOfCoOwningReferencesOffset, 0); }
  public static VectorOffset CreateVectorOfCoOwningReferencesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<ulong> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<ulong>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfCoOwningReferencesVector(ref FlatSpanBufferBuilder builder, scoped Span<ulong> data) { return CreateVectorOfCoOwningReferencesVectorBlock(ref builder, data); }
  public static void StartVectorOfCoOwningReferencesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddNonOwningReference(ref FlatSpanBufferBuilder builder, ulong nonOwningReference) { builder.Add<ulong>(41, nonOwningReference, 0); }
  public static void AddVectorOfNonOwningReferences(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfNonOwningReferencesOffset) { builder.AddOffset(42, vectorOfNonOwningReferencesOffset, 0); }
  public static VectorOffset CreateVectorOfNonOwningReferencesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<ulong> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<ulong>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfNonOwningReferencesVector(ref FlatSpanBufferBuilder builder, scoped Span<ulong> data) { return CreateVectorOfNonOwningReferencesVectorBlock(ref builder, data); }
  public static void StartVectorOfNonOwningReferencesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddAnyUniqueType(ref FlatSpanBufferBuilder builder, MyGame.Example.AnyUniqueAliases anyUniqueType) { builder.Add<byte>(43, (byte)anyUniqueType, 0); }
  public static void AddAnyUnique(ref FlatSpanBufferBuilder builder, int anyUniqueOffset) { builder.AddOffset(44, anyUniqueOffset, 0); }
  public static void AddAnyAmbiguousType(ref FlatSpanBufferBuilder builder, MyGame.Example.AnyAmbiguousAliases anyAmbiguousType) { builder.Add<byte>(45, (byte)anyAmbiguousType, 0); }
  public static void AddAnyAmbiguous(ref FlatSpanBufferBuilder builder, int anyAmbiguousOffset) { builder.AddOffset(46, anyAmbiguousOffset, 0); }
  public static void AddVectorOfEnums(ref FlatSpanBufferBuilder builder, VectorOffset vectorOfEnumsOffset) { builder.AddOffset(47, vectorOfEnumsOffset, 0); }
  public static VectorOffset CreateVectorOfEnumsVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<MyGame.Example.Color> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<MyGame.Example.Color>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfEnumsVector(ref FlatSpanBufferBuilder builder, scoped Span<MyGame.Example.Color> data) { return CreateVectorOfEnumsVectorBlock(ref builder, data); }
  public static void StartVectorOfEnumsVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddSignedEnum(ref FlatSpanBufferBuilder builder, MyGame.Example.Race signedEnum) { builder.Add<sbyte>(48, (sbyte)signedEnum, -1); }
  public static void AddTestrequirednestedflatbuffer(ref FlatSpanBufferBuilder builder, VectorOffset testrequirednestedflatbufferOffset) { builder.AddOffset(49, testrequirednestedflatbufferOffset, 0); }
  public static VectorOffset CreateTestrequirednestedflatbufferVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestrequirednestedflatbufferVector(ref FlatSpanBufferBuilder builder, scoped Span<byte> data) { return CreateTestrequirednestedflatbufferVectorBlock(ref builder, data); }
  public static void StartTestrequirednestedflatbufferVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddScalarKeySortedTables(ref FlatSpanBufferBuilder builder, VectorOffset scalarKeySortedTablesOffset) { builder.AddOffset(50, scalarKeySortedTablesOffset, 0); }
  public static VectorOffset CreateScalarKeySortedTablesVectorBlock(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Stat>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.StackBuffer.Stat>>(data); return builder.EndVector(); }
  public static VectorOffset CreateScalarKeySortedTablesVector(ref FlatSpanBufferBuilder builder, scoped Span<Offset<MyGame.Example.StackBuffer.Stat>> data) { return CreateScalarKeySortedTablesVectorBlock(ref builder, data); }
  public static void StartScalarKeySortedTablesVector(ref FlatSpanBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddNativeInline(ref FlatSpanBufferBuilder builder, Offset<MyGame.Example.StackBuffer.Test> nativeInlineOffset) { builder.AddStruct(51, nativeInlineOffset, 0); }
  public static void AddLongEnumNonEnumDefault(ref FlatSpanBufferBuilder builder, MyGame.Example.LongEnum longEnumNonEnumDefault) { builder.Add<ulong>(52, (ulong)longEnumNonEnumDefault, 0); }
  public static void AddLongEnumNormalDefault(ref FlatSpanBufferBuilder builder, MyGame.Example.LongEnum longEnumNormalDefault) { builder.Add<ulong>(53, (ulong)longEnumNormalDefault, 2); }
  public static void AddNanDefault(ref FlatSpanBufferBuilder builder, float nanDefault) { builder.Add<float>(54, nanDefault, Single.NaN); }
  public static void AddInfDefault(ref FlatSpanBufferBuilder builder, float infDefault) { builder.Add<float>(55, infDefault, Single.PositiveInfinity); }
  public static void AddPositiveInfDefault(ref FlatSpanBufferBuilder builder, float positiveInfDefault) { builder.Add<float>(56, positiveInfDefault, Single.PositiveInfinity); }
  public static void AddInfinityDefault(ref FlatSpanBufferBuilder builder, float infinityDefault) { builder.Add<float>(57, infinityDefault, Single.PositiveInfinity); }
  public static void AddPositiveInfinityDefault(ref FlatSpanBufferBuilder builder, float positiveInfinityDefault) { builder.Add<float>(58, positiveInfinityDefault, Single.PositiveInfinity); }
  public static void AddNegativeInfDefault(ref FlatSpanBufferBuilder builder, float negativeInfDefault) { builder.Add<float>(59, negativeInfDefault, Single.NegativeInfinity); }
  public static void AddNegativeInfinityDefault(ref FlatSpanBufferBuilder builder, float negativeInfinityDefault) { builder.Add<float>(60, negativeInfinityDefault, Single.NegativeInfinity); }
  public static void AddDoubleInfDefault(ref FlatSpanBufferBuilder builder, double doubleInfDefault) { builder.Add<double>(61, doubleInfDefault, Double.PositiveInfinity); }
  public static Offset<MyGame.Example.StackBuffer.Monster> EndMonster(ref FlatSpanBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 10);  // name
    return new Offset<MyGame.Example.StackBuffer.Monster>(o);
  }
  public static void FinishMonsterBuffer(ref FlatSpanBufferBuilder builder, Offset<MyGame.Example.StackBuffer.Monster> offset) { builder.Finish(offset.Value, "MONS"); }
  public static void FinishSizePrefixedMonsterBuffer(ref FlatSpanBufferBuilder builder, Offset<MyGame.Example.StackBuffer.Monster> offset) { builder.FinishSizePrefixed(offset.Value, "MONS"); }

  public static VectorOffset CreateSortedVectorOfMonster(ref FlatSpanBufferBuilder builder, scoped Span<Offset<Monster>> offsets) {
    var comparer = new SortedVectorUtils.VectorOffsetComparer<Monster, ByteSpanBuffer, byte>(builder.DataBuffer, 10);
    RefStructSorters.Sort(offsets, ref comparer);
    return builder.CreateVectorOfTables<Monster>(offsets);
  }

  public static bool TryGetByKey(int vectorLocation, string key, ByteSpanBuffer bb, out Monster value) {
    return SortedVectorUtils.TryGetByKey<Monster, ByteSpanBuffer>(vectorLocation, key, ref bb, 10, out value);
  }
  public MonsterT UnPack() {
    var _o = new MonsterT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MonsterT _o) {
    if (this.Pos.HasValue) {
      if (_o.Pos == null) _o.Pos = new MyGame.Example.Vec3T();
      this.Pos.Value.UnPackTo(_o.Pos);
    } else {
      _o.Pos = null;
    }
    _o.Mana = this.Mana;
    _o.Hp = this.Hp;
    _o.Name = this.Name;
    var _inventory_vec = this.Inventory;
    var _inventory_len = _inventory_vec.HasValue ? _inventory_vec.Value.Length : 0;
    if (_o.Inventory == null) {
      _o.Inventory = new List<byte>(_inventory_len);
    }
    ObjectApiUtil.ResizeList(_o.Inventory, _inventory_len);
    if (_inventory_vec.HasValue) { _inventory_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Inventory)); }
    _o.Color = this.Color;
    if (_o.Test == null) {
      _o.Test = new MyGame.Example.AnyUnion();
    }
    var _TestOldType = _o.Test.Type;
    _o.Test.Type = this.TestType;
    switch (this.TestType) {
      default:
        _o.Test.Value = null;
        break;
      case MyGame.Example.Any.Monster:
        if (this.Test<MyGame.Example.StackBuffer.Monster>().HasValue) {
          if (_TestOldType == MyGame.Example.Any.Monster) {
            this.Test<MyGame.Example.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.Test.Value);
          } else {
            _o.Test.Value = this.Test<MyGame.Example.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.Test.Value = null;
        }
        break;
      case MyGame.Example.Any.TestSimpleTableWithEnum:
        if (this.Test<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().HasValue) {
          if (_TestOldType == MyGame.Example.Any.TestSimpleTableWithEnum) {
            this.Test<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().Value.UnPackTo((MyGame.Example.TestSimpleTableWithEnumT)_o.Test.Value);
          } else {
            _o.Test.Value = this.Test<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().Value.UnPack();
          }
        } else {
          _o.Test.Value = null;
        }
        break;
      case MyGame.Example.Any.MyGame_Example2_Monster:
        if (this.Test<MyGame.Example2.StackBuffer.Monster>().HasValue) {
          if (_TestOldType == MyGame.Example.Any.MyGame_Example2_Monster) {
            this.Test<MyGame.Example2.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example2.MonsterT)_o.Test.Value);
          } else {
            _o.Test.Value = this.Test<MyGame.Example2.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.Test.Value = null;
        }
        break;
    }
    var _test4_vec = this.Test4;
    var _test4_len = _test4_vec.HasValue ? _test4_vec.Value.Length : 0;
    if (_o.Test4 == null) {
      _o.Test4 = new List<MyGame.Example.TestT>(_test4_len);
    }
    ObjectApiUtil.ResizeList(_o.Test4, _test4_len);
    if (_test4_vec.HasValue) {
      var _test4_value = _test4_vec.Value;
      for (var _j = 0; _j < _test4_len; ++_j) {
        var _src = _test4_value[_j];
        if (_o.Test4[_j] == null) { _o.Test4[_j] = new TestT(); }
        _src.UnPackTo(_o.Test4[_j]);
      }
    }
    var _testarrayofstring_vec = this.Testarrayofstring;
    var _testarrayofstring_len = _testarrayofstring_vec.HasValue ? _testarrayofstring_vec.Value.Length : 0;
    if (_o.Testarrayofstring == null) {
      _o.Testarrayofstring = new List<string>(_testarrayofstring_len);
    } else {
      _o.Testarrayofstring.Clear();
      if (_o.Testarrayofstring.Capacity < _testarrayofstring_len) {
        _o.Testarrayofstring.Capacity = _testarrayofstring_len;
      }
    }
    if (_testarrayofstring_vec.HasValue) {
      var _testarrayofstring_value = _testarrayofstring_vec.Value;
      for (var _j = 0; _j < _testarrayofstring_len; ++_j) { _o.Testarrayofstring.Add(_testarrayofstring_value[_j]); }
    }
    var _testarrayoftables_vec = this.Testarrayoftables;
    var _testarrayoftables_len = _testarrayoftables_vec.HasValue ? _testarrayoftables_vec.Value.Length : 0;
    if (_o.Testarrayoftables == null) {
      _o.Testarrayoftables = new List<MyGame.Example.MonsterT>(_testarrayoftables_len);
    }
    ObjectApiUtil.ResizeList(_o.Testarrayoftables, _testarrayoftables_len);
    if (_testarrayoftables_vec.HasValue) {
      var _testarrayoftables_value = _testarrayoftables_vec.Value;
      for (var _j = 0; _j < _testarrayoftables_len; ++_j) {
        var _src = _testarrayoftables_value[_j];
        if (_o.Testarrayoftables[_j] == null) { _o.Testarrayoftables[_j] = new MonsterT(); }
        _src.UnPackTo(_o.Testarrayoftables[_j]);
      }
    }
    if (this.Enemy.HasValue) {
      if (_o.Enemy == null) _o.Enemy = new MyGame.Example.MonsterT();
      this.Enemy.Value.UnPackTo(_o.Enemy);
    } else {
      _o.Enemy = null;
    }
    var _testnestedflatbuffer_vec = this.Testnestedflatbuffer;
    var _testnestedflatbuffer_len = _testnestedflatbuffer_vec.HasValue ? _testnestedflatbuffer_vec.Value.Length : 0;
    if (_o.Testnestedflatbuffer == null) {
      _o.Testnestedflatbuffer = new List<byte>(_testnestedflatbuffer_len);
    }
    ObjectApiUtil.ResizeList(_o.Testnestedflatbuffer, _testnestedflatbuffer_len);
    if (_testnestedflatbuffer_vec.HasValue) { _testnestedflatbuffer_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Testnestedflatbuffer)); }
    if (this.Testempty.HasValue) {
      if (_o.Testempty == null) _o.Testempty = new MyGame.Example.StatT();
      this.Testempty.Value.UnPackTo(_o.Testempty);
    } else {
      _o.Testempty = null;
    }
    _o.Testbool = this.Testbool;
    _o.Testhashs32Fnv1 = this.Testhashs32Fnv1;
    _o.Testhashu32Fnv1 = this.Testhashu32Fnv1;
    _o.Testhashs64Fnv1 = this.Testhashs64Fnv1;
    _o.Testhashu64Fnv1 = this.Testhashu64Fnv1;
    _o.Testhashs32Fnv1a = this.Testhashs32Fnv1a;
    _o.Testhashu32Fnv1a = this.Testhashu32Fnv1a;
    _o.Testhashs64Fnv1a = this.Testhashs64Fnv1a;
    _o.Testhashu64Fnv1a = this.Testhashu64Fnv1a;
    var _testarrayofbools_vec = this.Testarrayofbools;
    var _testarrayofbools_len = _testarrayofbools_vec.HasValue ? _testarrayofbools_vec.Value.Length : 0;
    if (_o.Testarrayofbools == null) {
      _o.Testarrayofbools = new List<bool>(_testarrayofbools_len);
    } else {
      _o.Testarrayofbools.Clear();
      if (_o.Testarrayofbools.Capacity < _testarrayofbools_len) {
        _o.Testarrayofbools.Capacity = _testarrayofbools_len;
      }
    }
    if (_testarrayofbools_vec.HasValue) {
      for (var _j = 0; _j < _testarrayofbools_len; ++_j) { _o.Testarrayofbools.Add(_testarrayofbools_vec.Value[_j]); }
    }
    _o.Testf = this.Testf;
    _o.Testf2 = this.Testf2;
    _o.Testf3 = this.Testf3;
    var _testarrayofstring2_vec = this.Testarrayofstring2;
    var _testarrayofstring2_len = _testarrayofstring2_vec.HasValue ? _testarrayofstring2_vec.Value.Length : 0;
    if (_o.Testarrayofstring2 == null) {
      _o.Testarrayofstring2 = new List<string>(_testarrayofstring2_len);
    } else {
      _o.Testarrayofstring2.Clear();
      if (_o.Testarrayofstring2.Capacity < _testarrayofstring2_len) {
        _o.Testarrayofstring2.Capacity = _testarrayofstring2_len;
      }
    }
    if (_testarrayofstring2_vec.HasValue) {
      var _testarrayofstring2_value = _testarrayofstring2_vec.Value;
      for (var _j = 0; _j < _testarrayofstring2_len; ++_j) { _o.Testarrayofstring2.Add(_testarrayofstring2_value[_j]); }
    }
    var _testarrayofsortedstruct_vec = this.Testarrayofsortedstruct;
    var _testarrayofsortedstruct_len = _testarrayofsortedstruct_vec.HasValue ? _testarrayofsortedstruct_vec.Value.Length : 0;
    if (_o.Testarrayofsortedstruct == null) {
      _o.Testarrayofsortedstruct = new List<MyGame.Example.AbilityT>(_testarrayofsortedstruct_len);
    }
    ObjectApiUtil.ResizeList(_o.Testarrayofsortedstruct, _testarrayofsortedstruct_len);
    if (_testarrayofsortedstruct_vec.HasValue) {
      var _testarrayofsortedstruct_value = _testarrayofsortedstruct_vec.Value;
      for (var _j = 0; _j < _testarrayofsortedstruct_len; ++_j) {
        var _src = _testarrayofsortedstruct_value[_j];
        if (_o.Testarrayofsortedstruct[_j] == null) { _o.Testarrayofsortedstruct[_j] = new AbilityT(); }
        _src.UnPackTo(_o.Testarrayofsortedstruct[_j]);
      }
    }
    var _flex_vec = this.Flex;
    var _flex_len = _flex_vec.HasValue ? _flex_vec.Value.Length : 0;
    if (_o.Flex == null) {
      _o.Flex = new List<byte>(_flex_len);
    }
    ObjectApiUtil.ResizeList(_o.Flex, _flex_len);
    if (_flex_vec.HasValue) { _flex_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Flex)); }
    var _test5_vec = this.Test5;
    var _test5_len = _test5_vec.HasValue ? _test5_vec.Value.Length : 0;
    if (_o.Test5 == null) {
      _o.Test5 = new List<MyGame.Example.TestT>(_test5_len);
    }
    ObjectApiUtil.ResizeList(_o.Test5, _test5_len);
    if (_test5_vec.HasValue) {
      var _test5_value = _test5_vec.Value;
      for (var _j = 0; _j < _test5_len; ++_j) {
        var _src = _test5_value[_j];
        if (_o.Test5[_j] == null) { _o.Test5[_j] = new TestT(); }
        _src.UnPackTo(_o.Test5[_j]);
      }
    }
    var _vector_of_longs_vec = this.VectorOfLongs;
    var _vector_of_longs_len = _vector_of_longs_vec.HasValue ? _vector_of_longs_vec.Value.Length : 0;
    if (_o.VectorOfLongs == null) {
      _o.VectorOfLongs = new List<long>(_vector_of_longs_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfLongs, _vector_of_longs_len);
    if (_vector_of_longs_vec.HasValue) { _vector_of_longs_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfLongs)); }
    var _vector_of_doubles_vec = this.VectorOfDoubles;
    var _vector_of_doubles_len = _vector_of_doubles_vec.HasValue ? _vector_of_doubles_vec.Value.Length : 0;
    if (_o.VectorOfDoubles == null) {
      _o.VectorOfDoubles = new List<double>(_vector_of_doubles_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfDoubles, _vector_of_doubles_len);
    if (_vector_of_doubles_vec.HasValue) { _vector_of_doubles_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfDoubles)); }
    if (this.ParentNamespaceTest.HasValue) {
      if (_o.ParentNamespaceTest == null) _o.ParentNamespaceTest = new MyGame.InParentNamespaceT();
      this.ParentNamespaceTest.Value.UnPackTo(_o.ParentNamespaceTest);
    } else {
      _o.ParentNamespaceTest = null;
    }
    var _vector_of_referrables_vec = this.VectorOfReferrables;
    var _vector_of_referrables_len = _vector_of_referrables_vec.HasValue ? _vector_of_referrables_vec.Value.Length : 0;
    if (_o.VectorOfReferrables == null) {
      _o.VectorOfReferrables = new List<MyGame.Example.ReferrableT>(_vector_of_referrables_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfReferrables, _vector_of_referrables_len);
    if (_vector_of_referrables_vec.HasValue) {
      var _vector_of_referrables_value = _vector_of_referrables_vec.Value;
      for (var _j = 0; _j < _vector_of_referrables_len; ++_j) {
        var _src = _vector_of_referrables_value[_j];
        if (_o.VectorOfReferrables[_j] == null) { _o.VectorOfReferrables[_j] = new ReferrableT(); }
        _src.UnPackTo(_o.VectorOfReferrables[_j]);
      }
    }
    _o.SingleWeakReference = this.SingleWeakReference;
    var _vector_of_weak_references_vec = this.VectorOfWeakReferences;
    var _vector_of_weak_references_len = _vector_of_weak_references_vec.HasValue ? _vector_of_weak_references_vec.Value.Length : 0;
    if (_o.VectorOfWeakReferences == null) {
      _o.VectorOfWeakReferences = new List<ulong>(_vector_of_weak_references_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfWeakReferences, _vector_of_weak_references_len);
    if (_vector_of_weak_references_vec.HasValue) { _vector_of_weak_references_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfWeakReferences)); }
    var _vector_of_strong_referrables_vec = this.VectorOfStrongReferrables;
    var _vector_of_strong_referrables_len = _vector_of_strong_referrables_vec.HasValue ? _vector_of_strong_referrables_vec.Value.Length : 0;
    if (_o.VectorOfStrongReferrables == null) {
      _o.VectorOfStrongReferrables = new List<MyGame.Example.ReferrableT>(_vector_of_strong_referrables_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfStrongReferrables, _vector_of_strong_referrables_len);
    if (_vector_of_strong_referrables_vec.HasValue) {
      var _vector_of_strong_referrables_value = _vector_of_strong_referrables_vec.Value;
      for (var _j = 0; _j < _vector_of_strong_referrables_len; ++_j) {
        var _src = _vector_of_strong_referrables_value[_j];
        if (_o.VectorOfStrongReferrables[_j] == null) { _o.VectorOfStrongReferrables[_j] = new ReferrableT(); }
        _src.UnPackTo(_o.VectorOfStrongReferrables[_j]);
      }
    }
    _o.CoOwningReference = this.CoOwningReference;
    var _vector_of_co_owning_references_vec = this.VectorOfCoOwningReferences;
    var _vector_of_co_owning_references_len = _vector_of_co_owning_references_vec.HasValue ? _vector_of_co_owning_references_vec.Value.Length : 0;
    if (_o.VectorOfCoOwningReferences == null) {
      _o.VectorOfCoOwningReferences = new List<ulong>(_vector_of_co_owning_references_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfCoOwningReferences, _vector_of_co_owning_references_len);
    if (_vector_of_co_owning_references_vec.HasValue) { _vector_of_co_owning_references_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfCoOwningReferences)); }
    _o.NonOwningReference = this.NonOwningReference;
    var _vector_of_non_owning_references_vec = this.VectorOfNonOwningReferences;
    var _vector_of_non_owning_references_len = _vector_of_non_owning_references_vec.HasValue ? _vector_of_non_owning_references_vec.Value.Length : 0;
    if (_o.VectorOfNonOwningReferences == null) {
      _o.VectorOfNonOwningReferences = new List<ulong>(_vector_of_non_owning_references_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfNonOwningReferences, _vector_of_non_owning_references_len);
    if (_vector_of_non_owning_references_vec.HasValue) { _vector_of_non_owning_references_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfNonOwningReferences)); }
    if (_o.AnyUnique == null) {
      _o.AnyUnique = new MyGame.Example.AnyUniqueAliasesUnion();
    }
    var _AnyUniqueOldType = _o.AnyUnique.Type;
    _o.AnyUnique.Type = this.AnyUniqueType;
    switch (this.AnyUniqueType) {
      default:
        _o.AnyUnique.Value = null;
        break;
      case MyGame.Example.AnyUniqueAliases.M:
        if (this.AnyUnique<MyGame.Example.StackBuffer.Monster>().HasValue) {
          if (_AnyUniqueOldType == MyGame.Example.AnyUniqueAliases.M) {
            this.AnyUnique<MyGame.Example.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyUnique.Value);
          } else {
            _o.AnyUnique.Value = this.AnyUnique<MyGame.Example.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyUnique.Value = null;
        }
        break;
      case MyGame.Example.AnyUniqueAliases.TS:
        if (this.AnyUnique<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().HasValue) {
          if (_AnyUniqueOldType == MyGame.Example.AnyUniqueAliases.TS) {
            this.AnyUnique<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().Value.UnPackTo((MyGame.Example.TestSimpleTableWithEnumT)_o.AnyUnique.Value);
          } else {
            _o.AnyUnique.Value = this.AnyUnique<MyGame.Example.StackBuffer.TestSimpleTableWithEnum>().Value.UnPack();
          }
        } else {
          _o.AnyUnique.Value = null;
        }
        break;
      case MyGame.Example.AnyUniqueAliases.M2:
        if (this.AnyUnique<MyGame.Example2.StackBuffer.Monster>().HasValue) {
          if (_AnyUniqueOldType == MyGame.Example.AnyUniqueAliases.M2) {
            this.AnyUnique<MyGame.Example2.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example2.MonsterT)_o.AnyUnique.Value);
          } else {
            _o.AnyUnique.Value = this.AnyUnique<MyGame.Example2.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyUnique.Value = null;
        }
        break;
    }
    if (_o.AnyAmbiguous == null) {
      _o.AnyAmbiguous = new MyGame.Example.AnyAmbiguousAliasesUnion();
    }
    var _AnyAmbiguousOldType = _o.AnyAmbiguous.Type;
    _o.AnyAmbiguous.Type = this.AnyAmbiguousType;
    switch (this.AnyAmbiguousType) {
      default:
        _o.AnyAmbiguous.Value = null;
        break;
      case MyGame.Example.AnyAmbiguousAliases.M1:
        if (this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().HasValue) {
          if (_AnyAmbiguousOldType == MyGame.Example.AnyAmbiguousAliases.M1) {
            this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyAmbiguous.Value);
          } else {
            _o.AnyAmbiguous.Value = this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyAmbiguous.Value = null;
        }
        break;
      case MyGame.Example.AnyAmbiguousAliases.M2:
        if (this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().HasValue) {
          if (_AnyAmbiguousOldType == MyGame.Example.AnyAmbiguousAliases.M2) {
            this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyAmbiguous.Value);
          } else {
            _o.AnyAmbiguous.Value = this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyAmbiguous.Value = null;
        }
        break;
      case MyGame.Example.AnyAmbiguousAliases.M3:
        if (this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().HasValue) {
          if (_AnyAmbiguousOldType == MyGame.Example.AnyAmbiguousAliases.M3) {
            this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyAmbiguous.Value);
          } else {
            _o.AnyAmbiguous.Value = this.AnyAmbiguous<MyGame.Example.StackBuffer.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyAmbiguous.Value = null;
        }
        break;
    }
    var _vector_of_enums_vec = this.VectorOfEnums;
    var _vector_of_enums_len = _vector_of_enums_vec.HasValue ? _vector_of_enums_vec.Value.Length : 0;
    if (_o.VectorOfEnums == null) {
      _o.VectorOfEnums = new List<MyGame.Example.Color>(_vector_of_enums_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfEnums, _vector_of_enums_len);
    if (_vector_of_enums_vec.HasValue) { _vector_of_enums_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfEnums)); }
    _o.SignedEnum = this.SignedEnum;
    var _testrequirednestedflatbuffer_vec = this.Testrequirednestedflatbuffer;
    var _testrequirednestedflatbuffer_len = _testrequirednestedflatbuffer_vec.HasValue ? _testrequirednestedflatbuffer_vec.Value.Length : 0;
    if (_o.Testrequirednestedflatbuffer == null) {
      _o.Testrequirednestedflatbuffer = new List<byte>(_testrequirednestedflatbuffer_len);
    }
    ObjectApiUtil.ResizeList(_o.Testrequirednestedflatbuffer, _testrequirednestedflatbuffer_len);
    if (_testrequirednestedflatbuffer_vec.HasValue) { _testrequirednestedflatbuffer_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Testrequirednestedflatbuffer)); }
    var _scalar_key_sorted_tables_vec = this.ScalarKeySortedTables;
    var _scalar_key_sorted_tables_len = _scalar_key_sorted_tables_vec.HasValue ? _scalar_key_sorted_tables_vec.Value.Length : 0;
    if (_o.ScalarKeySortedTables == null) {
      _o.ScalarKeySortedTables = new List<MyGame.Example.StatT>(_scalar_key_sorted_tables_len);
    }
    ObjectApiUtil.ResizeList(_o.ScalarKeySortedTables, _scalar_key_sorted_tables_len);
    if (_scalar_key_sorted_tables_vec.HasValue) {
      var _scalar_key_sorted_tables_value = _scalar_key_sorted_tables_vec.Value;
      for (var _j = 0; _j < _scalar_key_sorted_tables_len; ++_j) {
        var _src = _scalar_key_sorted_tables_value[_j];
        if (_o.ScalarKeySortedTables[_j] == null) { _o.ScalarKeySortedTables[_j] = new StatT(); }
        _src.UnPackTo(_o.ScalarKeySortedTables[_j]);
      }
    }
    if (this.NativeInline.HasValue) {
      if (_o.NativeInline == null) _o.NativeInline = new MyGame.Example.TestT();
      this.NativeInline.Value.UnPackTo(_o.NativeInline);
    } else {
      _o.NativeInline = null;
    }
    _o.LongEnumNonEnumDefault = this.LongEnumNonEnumDefault;
    _o.LongEnumNormalDefault = this.LongEnumNormalDefault;
    _o.NanDefault = this.NanDefault;
    _o.InfDefault = this.InfDefault;
    _o.PositiveInfDefault = this.PositiveInfDefault;
    _o.InfinityDefault = this.InfinityDefault;
    _o.PositiveInfinityDefault = this.PositiveInfinityDefault;
    _o.NegativeInfDefault = this.NegativeInfDefault;
    _o.NegativeInfinityDefault = this.NegativeInfinityDefault;
    _o.DoubleInfDefault = this.DoubleInfDefault;
  }
  public static Offset<MyGame.Example.StackBuffer.Monster> Pack(ref FlatSpanBufferBuilder builder, MonsterT _o) {
    if (_o == null) return default(Offset<MyGame.Example.StackBuffer.Monster>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _inventory = default(VectorOffset);
    if (_o.Inventory != null) {
      _inventory = CreateInventoryVector(ref builder, CollectionsMarshal.AsSpan(_o.Inventory));
    }
    var _test_type = _o.Test == null ? MyGame.Example.Any.NONE : _o.Test.Type;
    var _test = _o.Test == null ? 0 : MyGame.Example.AnyUnion.Pack(ref builder, _o.Test);
    var _test4 = default(VectorOffset);
    if (_o.Test4 != null) {
      StartTest4Vector(ref builder, _o.Test4.Count);
      for (var _j = _o.Test4.Count - 1; _j >= 0; --_j) { MyGame.Example.StackBuffer.Test.Pack(ref builder, _o.Test4[_j]); }
      _test4 = builder.EndVector();
    }
    var _testarrayofstring = default(VectorOffset);
    if (_o.Testarrayofstring != null) {
      var _testarrayofstring_len = _o.Testarrayofstring.Count;
      StringOffset[] _testarrayofstring_arr = null;
      try {
        Span<StringOffset> __testarrayofstring = _testarrayofstring_len <= 64
          ? stackalloc StringOffset[_testarrayofstring_len]
          : (_testarrayofstring_arr = ArrayPool<StringOffset>.Shared.Rent(_testarrayofstring_len)).AsSpan(0, _testarrayofstring_len);
        for (var _j = 0; _j < _testarrayofstring_len; ++_j) { __testarrayofstring[_j] = builder.CreateString(_o.Testarrayofstring[_j]); }
        _testarrayofstring = CreateTestarrayofstringVector(ref builder, __testarrayofstring);
      } finally {
        if (_testarrayofstring_arr != null) { ArrayPool<StringOffset>.Shared.Return(_testarrayofstring_arr); }
      }
    }
    var _testarrayoftables = default(VectorOffset);
    if (_o.Testarrayoftables != null) {
      var _testarrayoftables_len = _o.Testarrayoftables.Count;
      Offset<MyGame.Example.StackBuffer.Monster>[] _testarrayoftables_arr = null;
      try {
        Span<Offset<MyGame.Example.StackBuffer.Monster>> __testarrayoftables = _testarrayoftables_len <= 64
          ? stackalloc Offset<MyGame.Example.StackBuffer.Monster>[_testarrayoftables_len]
          : (_testarrayoftables_arr = ArrayPool<Offset<MyGame.Example.StackBuffer.Monster>>.Shared.Rent(_testarrayoftables_len)).AsSpan(0, _testarrayoftables_len);
        for (var _j = 0; _j < _testarrayoftables_len; ++_j) { __testarrayoftables[_j] = MyGame.Example.StackBuffer.Monster.Pack(ref builder, _o.Testarrayoftables[_j]); }
        _testarrayoftables = CreateTestarrayoftablesVector(ref builder, __testarrayoftables);
      } finally {
        if (_testarrayoftables_arr != null) { ArrayPool<Offset<MyGame.Example.StackBuffer.Monster>>.Shared.Return(_testarrayoftables_arr); }
      }
    }
    var _enemy = _o.Enemy == null ? default(Offset<MyGame.Example.StackBuffer.Monster>) : MyGame.Example.StackBuffer.Monster.Pack(ref builder, _o.Enemy);
    var _testnestedflatbuffer = default(VectorOffset);
    if (_o.Testnestedflatbuffer != null) {
      _testnestedflatbuffer = CreateTestnestedflatbufferVector(ref builder, CollectionsMarshal.AsSpan(_o.Testnestedflatbuffer));
    }
    var _testempty = _o.Testempty == null ? default(Offset<MyGame.Example.StackBuffer.Stat>) : MyGame.Example.StackBuffer.Stat.Pack(ref builder, _o.Testempty);
    var _testarrayofbools = default(VectorOffset);
    if (_o.Testarrayofbools != null) {
      _testarrayofbools = CreateTestarrayofboolsVector(ref builder, CollectionsMarshal.AsSpan(_o.Testarrayofbools));
    }
    var _testarrayofstring2 = default(VectorOffset);
    if (_o.Testarrayofstring2 != null) {
      var _testarrayofstring2_len = _o.Testarrayofstring2.Count;
      StringOffset[] _testarrayofstring2_arr = null;
      try {
        Span<StringOffset> __testarrayofstring2 = _testarrayofstring2_len <= 64
          ? stackalloc StringOffset[_testarrayofstring2_len]
          : (_testarrayofstring2_arr = ArrayPool<StringOffset>.Shared.Rent(_testarrayofstring2_len)).AsSpan(0, _testarrayofstring2_len);
        for (var _j = 0; _j < _testarrayofstring2_len; ++_j) { __testarrayofstring2[_j] = builder.CreateString(_o.Testarrayofstring2[_j]); }
        _testarrayofstring2 = CreateTestarrayofstring2Vector(ref builder, __testarrayofstring2);
      } finally {
        if (_testarrayofstring2_arr != null) { ArrayPool<StringOffset>.Shared.Return(_testarrayofstring2_arr); }
      }
    }
    var _testarrayofsortedstruct = default(VectorOffset);
    if (_o.Testarrayofsortedstruct != null) {
      StartTestarrayofsortedstructVector(ref builder, _o.Testarrayofsortedstruct.Count);
      for (var _j = _o.Testarrayofsortedstruct.Count - 1; _j >= 0; --_j) { MyGame.Example.StackBuffer.Ability.Pack(ref builder, _o.Testarrayofsortedstruct[_j]); }
      _testarrayofsortedstruct = builder.EndVector();
    }
    var _flex = default(VectorOffset);
    if (_o.Flex != null) {
      _flex = CreateFlexVector(ref builder, CollectionsMarshal.AsSpan(_o.Flex));
    }
    var _test5 = default(VectorOffset);
    if (_o.Test5 != null) {
      StartTest5Vector(ref builder, _o.Test5.Count);
      for (var _j = _o.Test5.Count - 1; _j >= 0; --_j) { MyGame.Example.StackBuffer.Test.Pack(ref builder, _o.Test5[_j]); }
      _test5 = builder.EndVector();
    }
    var _vector_of_longs = default(VectorOffset);
    if (_o.VectorOfLongs != null) {
      _vector_of_longs = CreateVectorOfLongsVector(ref builder, CollectionsMarshal.AsSpan(_o.VectorOfLongs));
    }
    var _vector_of_doubles = default(VectorOffset);
    if (_o.VectorOfDoubles != null) {
      _vector_of_doubles = CreateVectorOfDoublesVector(ref builder, CollectionsMarshal.AsSpan(_o.VectorOfDoubles));
    }
    var _parent_namespace_test = _o.ParentNamespaceTest == null ? default(Offset<MyGame.StackBuffer.InParentNamespace>) : MyGame.StackBuffer.InParentNamespace.Pack(ref builder, _o.ParentNamespaceTest);
    var _vector_of_referrables = default(VectorOffset);
    if (_o.VectorOfReferrables != null) {
      var _vector_of_referrables_len = _o.VectorOfReferrables.Count;
      Offset<MyGame.Example.StackBuffer.Referrable>[] _vector_of_referrables_arr = null;
      try {
        Span<Offset<MyGame.Example.StackBuffer.Referrable>> __vector_of_referrables = _vector_of_referrables_len <= 64
          ? stackalloc Offset<MyGame.Example.StackBuffer.Referrable>[_vector_of_referrables_len]
          : (_vector_of_referrables_arr = ArrayPool<Offset<MyGame.Example.StackBuffer.Referrable>>.Shared.Rent(_vector_of_referrables_len)).AsSpan(0, _vector_of_referrables_len);
        for (var _j = 0; _j < _vector_of_referrables_len; ++_j) { __vector_of_referrables[_j] = MyGame.Example.StackBuffer.Referrable.Pack(ref builder, _o.VectorOfReferrables[_j]); }
        _vector_of_referrables = CreateVectorOfReferrablesVector(ref builder, __vector_of_referrables);
      } finally {
        if (_vector_of_referrables_arr != null) { ArrayPool<Offset<MyGame.Example.StackBuffer.Referrable>>.Shared.Return(_vector_of_referrables_arr); }
      }
    }
    var _vector_of_weak_references = default(VectorOffset);
    if (_o.VectorOfWeakReferences != null) {
      _vector_of_weak_references = CreateVectorOfWeakReferencesVector(ref builder, CollectionsMarshal.AsSpan(_o.VectorOfWeakReferences));
    }
    var _vector_of_strong_referrables = default(VectorOffset);
    if (_o.VectorOfStrongReferrables != null) {
      var _vector_of_strong_referrables_len = _o.VectorOfStrongReferrables.Count;
      Offset<MyGame.Example.StackBuffer.Referrable>[] _vector_of_strong_referrables_arr = null;
      try {
        Span<Offset<MyGame.Example.StackBuffer.Referrable>> __vector_of_strong_referrables = _vector_of_strong_referrables_len <= 64
          ? stackalloc Offset<MyGame.Example.StackBuffer.Referrable>[_vector_of_strong_referrables_len]
          : (_vector_of_strong_referrables_arr = ArrayPool<Offset<MyGame.Example.StackBuffer.Referrable>>.Shared.Rent(_vector_of_strong_referrables_len)).AsSpan(0, _vector_of_strong_referrables_len);
        for (var _j = 0; _j < _vector_of_strong_referrables_len; ++_j) { __vector_of_strong_referrables[_j] = MyGame.Example.StackBuffer.Referrable.Pack(ref builder, _o.VectorOfStrongReferrables[_j]); }
        _vector_of_strong_referrables = CreateVectorOfStrongReferrablesVector(ref builder, __vector_of_strong_referrables);
      } finally {
        if (_vector_of_strong_referrables_arr != null) { ArrayPool<Offset<MyGame.Example.StackBuffer.Referrable>>.Shared.Return(_vector_of_strong_referrables_arr); }
      }
    }
    var _vector_of_co_owning_references = default(VectorOffset);
    if (_o.VectorOfCoOwningReferences != null) {
      _vector_of_co_owning_references = CreateVectorOfCoOwningReferencesVector(ref builder, CollectionsMarshal.AsSpan(_o.VectorOfCoOwningReferences));
    }
    var _vector_of_non_owning_references = default(VectorOffset);
    if (_o.VectorOfNonOwningReferences != null) {
      _vector_of_non_owning_references = CreateVectorOfNonOwningReferencesVector(ref builder, CollectionsMarshal.AsSpan(_o.VectorOfNonOwningReferences));
    }
    var _any_unique_type = _o.AnyUnique == null ? MyGame.Example.AnyUniqueAliases.NONE : _o.AnyUnique.Type;
    var _any_unique = _o.AnyUnique == null ? 0 : MyGame.Example.AnyUniqueAliasesUnion.Pack(ref builder, _o.AnyUnique);
    var _any_ambiguous_type = _o.AnyAmbiguous == null ? MyGame.Example.AnyAmbiguousAliases.NONE : _o.AnyAmbiguous.Type;
    var _any_ambiguous = _o.AnyAmbiguous == null ? 0 : MyGame.Example.AnyAmbiguousAliasesUnion.Pack(ref builder, _o.AnyAmbiguous);
    var _vector_of_enums = default(VectorOffset);
    if (_o.VectorOfEnums != null) {
      _vector_of_enums = CreateVectorOfEnumsVector(ref builder, CollectionsMarshal.AsSpan(_o.VectorOfEnums));
    }
    var _testrequirednestedflatbuffer = default(VectorOffset);
    if (_o.Testrequirednestedflatbuffer != null) {
      _testrequirednestedflatbuffer = CreateTestrequirednestedflatbufferVector(ref builder, CollectionsMarshal.AsSpan(_o.Testrequirednestedflatbuffer));
    }
    var _scalar_key_sorted_tables = default(VectorOffset);
    if (_o.ScalarKeySortedTables != null) {
      var _scalar_key_sorted_tables_len = _o.ScalarKeySortedTables.Count;
      Offset<MyGame.Example.StackBuffer.Stat>[] _scalar_key_sorted_tables_arr = null;
      try {
        Span<Offset<MyGame.Example.StackBuffer.Stat>> __scalar_key_sorted_tables = _scalar_key_sorted_tables_len <= 64
          ? stackalloc Offset<MyGame.Example.StackBuffer.Stat>[_scalar_key_sorted_tables_len]
          : (_scalar_key_sorted_tables_arr = ArrayPool<Offset<MyGame.Example.StackBuffer.Stat>>.Shared.Rent(_scalar_key_sorted_tables_len)).AsSpan(0, _scalar_key_sorted_tables_len);
        for (var _j = 0; _j < _scalar_key_sorted_tables_len; ++_j) { __scalar_key_sorted_tables[_j] = MyGame.Example.StackBuffer.Stat.Pack(ref builder, _o.ScalarKeySortedTables[_j]); }
        _scalar_key_sorted_tables = CreateScalarKeySortedTablesVector(ref builder, __scalar_key_sorted_tables);
      } finally {
        if (_scalar_key_sorted_tables_arr != null) { ArrayPool<Offset<MyGame.Example.StackBuffer.Stat>>.Shared.Return(_scalar_key_sorted_tables_arr); }
      }
    }
    StartMonster(ref builder);
    AddPos(ref builder, MyGame.Example.StackBuffer.Vec3.Pack(ref builder, _o.Pos));
    AddMana(ref builder, _o.Mana);
    AddHp(ref builder, _o.Hp);
    AddName(ref builder, _name);
    AddInventory(ref builder, _inventory);
    AddColor(ref builder, _o.Color);
    AddTestType(ref builder, _test_type);
    AddTest(ref builder, _test);
    AddTest4(ref builder, _test4);
    AddTestarrayofstring(ref builder, _testarrayofstring);
    AddTestarrayoftables(ref builder, _testarrayoftables);
    AddEnemy(ref builder, _enemy);
    AddTestnestedflatbuffer(ref builder, _testnestedflatbuffer);
    AddTestempty(ref builder, _testempty);
    AddTestbool(ref builder, _o.Testbool);
    AddTesthashs32Fnv1(ref builder, _o.Testhashs32Fnv1);
    AddTesthashu32Fnv1(ref builder, _o.Testhashu32Fnv1);
    AddTesthashs64Fnv1(ref builder, _o.Testhashs64Fnv1);
    AddTesthashu64Fnv1(ref builder, _o.Testhashu64Fnv1);
    AddTesthashs32Fnv1a(ref builder, _o.Testhashs32Fnv1a);
    AddTesthashu32Fnv1a(ref builder, _o.Testhashu32Fnv1a);
    AddTesthashs64Fnv1a(ref builder, _o.Testhashs64Fnv1a);
    AddTesthashu64Fnv1a(ref builder, _o.Testhashu64Fnv1a);
    AddTestarrayofbools(ref builder, _testarrayofbools);
    AddTestf(ref builder, _o.Testf);
    AddTestf2(ref builder, _o.Testf2);
    AddTestf3(ref builder, _o.Testf3);
    AddTestarrayofstring2(ref builder, _testarrayofstring2);
    AddTestarrayofsortedstruct(ref builder, _testarrayofsortedstruct);
    AddFlex(ref builder, _flex);
    AddTest5(ref builder, _test5);
    AddVectorOfLongs(ref builder, _vector_of_longs);
    AddVectorOfDoubles(ref builder, _vector_of_doubles);
    AddParentNamespaceTest(ref builder, _parent_namespace_test);
    AddVectorOfReferrables(ref builder, _vector_of_referrables);
    AddSingleWeakReference(ref builder, _o.SingleWeakReference);
    AddVectorOfWeakReferences(ref builder, _vector_of_weak_references);
    AddVectorOfStrongReferrables(ref builder, _vector_of_strong_referrables);
    AddCoOwningReference(ref builder, _o.CoOwningReference);
    AddVectorOfCoOwningReferences(ref builder, _vector_of_co_owning_references);
    AddNonOwningReference(ref builder, _o.NonOwningReference);
    AddVectorOfNonOwningReferences(ref builder, _vector_of_non_owning_references);
    AddAnyUniqueType(ref builder, _any_unique_type);
    AddAnyUnique(ref builder, _any_unique);
    AddAnyAmbiguousType(ref builder, _any_ambiguous_type);
    AddAnyAmbiguous(ref builder, _any_ambiguous);
    AddVectorOfEnums(ref builder, _vector_of_enums);
    AddSignedEnum(ref builder, _o.SignedEnum);
    AddTestrequirednestedflatbuffer(ref builder, _testrequirednestedflatbuffer);
    AddScalarKeySortedTables(ref builder, _scalar_key_sorted_tables);
    AddNativeInline(ref builder, MyGame.Example.StackBuffer.Test.Pack(ref builder, _o.NativeInline));
    AddLongEnumNonEnumDefault(ref builder, _o.LongEnumNonEnumDefault);
    AddLongEnumNormalDefault(ref builder, _o.LongEnumNormalDefault);
    AddNanDefault(ref builder, _o.NanDefault);
    AddInfDefault(ref builder, _o.InfDefault);
    AddPositiveInfDefault(ref builder, _o.PositiveInfDefault);
    AddInfinityDefault(ref builder, _o.InfinityDefault);
    AddPositiveInfinityDefault(ref builder, _o.PositiveInfinityDefault);
    AddNegativeInfDefault(ref builder, _o.NegativeInfDefault);
    AddNegativeInfinityDefault(ref builder, _o.NegativeInfinityDefault);
    AddDoubleInfDefault(ref builder, _o.DoubleInfDefault);
    return EndMonster(ref builder);
  }
}


}

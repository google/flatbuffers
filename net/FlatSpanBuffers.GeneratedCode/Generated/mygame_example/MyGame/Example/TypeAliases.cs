// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MyGame.Example
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
public struct TypeAliases : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static TypeAliases GetRootAsTypeAliases(ByteBuffer _bb) { return GetRootAsTypeAliases(_bb, new TypeAliases()); }
  public static TypeAliases GetRootAsTypeAliases(ByteBuffer _bb, TypeAliases obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TypeAliases __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public sbyte I8 { get { int o = __p.__offset(4); return o != 0 ? __p.bb.Get<sbyte>(o + __p.bb_pos) : (sbyte)0; } }
  public bool MutateI8(sbyte i8) { int o = __p.__offset(4); if (o != 0) { __p.bb.Put<sbyte>(o + __p.bb_pos, i8); return true; } else { return false; } }
  public byte U8 { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get<byte>(o + __p.bb_pos) : (byte)0; } }
  public bool MutateU8(byte u8) { int o = __p.__offset(6); if (o != 0) { __p.bb.PutByte(o + __p.bb_pos, u8); return true; } else { return false; } }
  public short I16 { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)0; } }
  public bool MutateI16(short i16) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, i16); return true; } else { return false; } }
  public ushort U16 { get { int o = __p.__offset(10); return o != 0 ? __p.bb.Get<ushort>(o + __p.bb_pos) : (ushort)0; } }
  public bool MutateU16(ushort u16) { int o = __p.__offset(10); if (o != 0) { __p.bb.Put<ushort>(o + __p.bb_pos, u16); return true; } else { return false; } }
  public int I32 { get { int o = __p.__offset(12); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)0; } }
  public bool MutateI32(int i32) { int o = __p.__offset(12); if (o != 0) { __p.bb.Put<int>(o + __p.bb_pos, i32); return true; } else { return false; } }
  public uint U32 { get { int o = __p.__offset(14); return o != 0 ? __p.bb.Get<uint>(o + __p.bb_pos) : (uint)0; } }
  public bool MutateU32(uint u32) { int o = __p.__offset(14); if (o != 0) { __p.bb.Put<uint>(o + __p.bb_pos, u32); return true; } else { return false; } }
  public long I64 { get { int o = __p.__offset(16); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public bool MutateI64(long i64) { int o = __p.__offset(16); if (o != 0) { __p.bb.Put<long>(o + __p.bb_pos, i64); return true; } else { return false; } }
  public ulong U64 { get { int o = __p.__offset(18); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateU64(ulong u64) { int o = __p.__offset(18); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, u64); return true; } else { return false; } }
  public float F32 { get { int o = __p.__offset(20); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)0.0f; } }
  public bool MutateF32(float f32) { int o = __p.__offset(20); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, f32); return true; } else { return false; } }
  public double F64 { get { int o = __p.__offset(22); return o != 0 ? __p.bb.Get<double>(o + __p.bb_pos) : (double)0.0; } }
  public bool MutateF64(double f64) { int o = __p.__offset(22); if (o != 0) { __p.bb.Put<double>(o + __p.bb_pos, f64); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<sbyte>> V8 { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<ReadOnlySpan<sbyte>>(__p.__vector_as_span<sbyte>(24)) : default; } }
  public RefStructNullable<Span<sbyte>> MutableV8 { get { int o = __p.__offset(24); return o != 0 ? new RefStructNullable<Span<sbyte>>(__p.__vector_as_span<sbyte>(24)) : default; } }
  public bool MutateV8(int j, sbyte v8) { int o = __p.__offset(24); if (o != 0) { __p.bb.Put<sbyte>(__p.__vector(o) + j * 1, v8); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<double>> Vf64 { get { int o = __p.__offset(26); return o != 0 ? new RefStructNullable<ReadOnlySpan<double>>(__p.__vector_as_span<double>(26)) : default; } }
  public RefStructNullable<Span<double>> MutableVf64 { get { int o = __p.__offset(26); return o != 0 ? new RefStructNullable<Span<double>>(__p.__vector_as_span<double>(26)) : default; } }
  public bool MutateVf64(int j, double vf64) { int o = __p.__offset(26); if (o != 0) { __p.bb.Put<double>(__p.__vector(o) + j * 8, vf64); return true; } else { return false; } }

  public static Offset<MyGame.Example.TypeAliases> CreateTypeAliases(FlatBufferBuilder builder,
      sbyte i8 = 0,
      byte u8 = 0,
      short i16 = 0,
      ushort u16 = 0,
      int i32 = 0,
      uint u32 = 0,
      long i64 = 0,
      ulong u64 = 0,
      float f32 = 0.0f,
      double f64 = 0.0,
      VectorOffset v8Offset = default(VectorOffset),
      VectorOffset vf64Offset = default(VectorOffset)) {
    builder.StartTable(12);
    TypeAliases.AddF64(builder, f64);
    TypeAliases.AddU64(builder, u64);
    TypeAliases.AddI64(builder, i64);
    TypeAliases.AddVf64(builder, vf64Offset);
    TypeAliases.AddV8(builder, v8Offset);
    TypeAliases.AddF32(builder, f32);
    TypeAliases.AddU32(builder, u32);
    TypeAliases.AddI32(builder, i32);
    TypeAliases.AddU16(builder, u16);
    TypeAliases.AddI16(builder, i16);
    TypeAliases.AddU8(builder, u8);
    TypeAliases.AddI8(builder, i8);
    return TypeAliases.EndTypeAliases(builder);
  }

  public static void StartTypeAliases(FlatBufferBuilder builder) { builder.StartTable(12); }
  public static void AddI8(FlatBufferBuilder builder, sbyte i8) { builder.Add<sbyte>(0, i8, 0); }
  public static void AddU8(FlatBufferBuilder builder, byte u8) { builder.Add<byte>(1, u8, 0); }
  public static void AddI16(FlatBufferBuilder builder, short i16) { builder.Add<short>(2, i16, 0); }
  public static void AddU16(FlatBufferBuilder builder, ushort u16) { builder.Add<ushort>(3, u16, 0); }
  public static void AddI32(FlatBufferBuilder builder, int i32) { builder.Add<int>(4, i32, 0); }
  public static void AddU32(FlatBufferBuilder builder, uint u32) { builder.Add<uint>(5, u32, 0); }
  public static void AddI64(FlatBufferBuilder builder, long i64) { builder.Add<long>(6, i64, 0); }
  public static void AddU64(FlatBufferBuilder builder, ulong u64) { builder.Add<ulong>(7, u64, 0); }
  public static void AddF32(FlatBufferBuilder builder, float f32) { builder.Add<float>(8, f32, 0.0f); }
  public static void AddF64(FlatBufferBuilder builder, double f64) { builder.Add<double>(9, f64, 0.0); }
  public static void AddV8(FlatBufferBuilder builder, VectorOffset v8Offset) { builder.AddOffset(10, v8Offset, 0); }
  public static VectorOffset CreateV8VectorBlock(FlatBufferBuilder builder, Span<sbyte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<sbyte>(data); return builder.EndVector(); }
  public static VectorOffset CreateV8Vector(FlatBufferBuilder builder, Span<sbyte> data) { return CreateV8VectorBlock(builder, data); }
  public static void StartV8Vector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddVf64(FlatBufferBuilder builder, VectorOffset vf64Offset) { builder.AddOffset(11, vf64Offset, 0); }
  public static VectorOffset CreateVf64VectorBlock(FlatBufferBuilder builder, Span<double> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<double>(data); return builder.EndVector(); }
  public static VectorOffset CreateVf64Vector(FlatBufferBuilder builder, Span<double> data) { return CreateVf64VectorBlock(builder, data); }
  public static void StartVf64Vector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static Offset<MyGame.Example.TypeAliases> EndTypeAliases(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<MyGame.Example.TypeAliases>(o);
  }
  public TypeAliasesT UnPack() {
    var _o = new TypeAliasesT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TypeAliasesT _o) {
    _o.I8 = this.I8;
    _o.U8 = this.U8;
    _o.I16 = this.I16;
    _o.U16 = this.U16;
    _o.I32 = this.I32;
    _o.U32 = this.U32;
    _o.I64 = this.I64;
    _o.U64 = this.U64;
    _o.F32 = this.F32;
    _o.F64 = this.F64;
    var _v8_vec = this.V8;
    var _v8_len = _v8_vec.HasValue ? _v8_vec.Value.Length : 0;
    if (_o.V8 == null) {
      _o.V8 = new List<sbyte>(_v8_len);
    }
    ObjectApiUtil.ResizeList(_o.V8, _v8_len);
    if (_v8_vec.HasValue) { _v8_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.V8)); }
    var _vf64_vec = this.Vf64;
    var _vf64_len = _vf64_vec.HasValue ? _vf64_vec.Value.Length : 0;
    if (_o.Vf64 == null) {
      _o.Vf64 = new List<double>(_vf64_len);
    }
    ObjectApiUtil.ResizeList(_o.Vf64, _vf64_len);
    if (_vf64_vec.HasValue) { _vf64_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Vf64)); }
  }
  public static Offset<MyGame.Example.TypeAliases> Pack(FlatBufferBuilder builder, TypeAliasesT _o) {
    if (_o == null) return default(Offset<MyGame.Example.TypeAliases>);
    var _v8 = default(VectorOffset);
    if (_o.V8 != null) {
      _v8 = CreateV8Vector(builder, CollectionsMarshal.AsSpan(_o.V8));
    }
    var _vf64 = default(VectorOffset);
    if (_o.Vf64 != null) {
      _vf64 = CreateVf64Vector(builder, CollectionsMarshal.AsSpan(_o.Vf64));
    }
    return CreateTypeAliases(
      builder,
      _o.I8,
      _o.U8,
      _o.I16,
      _o.U16,
      _o.I32,
      _o.U32,
      _o.I64,
      _o.U64,
      _o.F32,
      _o.F64,
      _v8,
      _vf64);
  }
}

public class TypeAliasesT
{
  [System.Text.Json.Serialization.JsonPropertyName("i8")]
  public sbyte I8 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("u8")]
  public byte U8 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("i16")]
  public short I16 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("u16")]
  public ushort U16 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("i32")]
  public int I32 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("u32")]
  public uint U32 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("i64")]
  public long I64 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("u64")]
  public ulong U64 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("f32")]
  public float F32 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("f64")]
  public double F64 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("v8")]
  public List<sbyte> V8 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vf64")]
  public List<double> Vf64 { get; set; }

  public TypeAliasesT() {
    this.I8 = 0;
    this.U8 = 0;
    this.I16 = 0;
    this.U16 = 0;
    this.I32 = 0;
    this.U32 = 0;
    this.I64 = 0;
    this.U64 = 0;
    this.F32 = 0.0f;
    this.F64 = 0.0;
    this.V8 = null;
    this.Vf64 = null;
  }
}


static public class TypeAliasesVerify
{
  static public bool Verify(ref Google.FlatSpanBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*I8*/, 1 /*sbyte*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*U8*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*I16*/, 2 /*short*/, 2, false)
      && verifier.VerifyField(tablePos, 10 /*U16*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 12 /*I32*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*U32*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*I64*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 18 /*U64*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 20 /*F32*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 22 /*F64*/, 8 /*double*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 24 /*V8*/, 1 /*sbyte*/, false)
      && verifier.VerifyVectorOfData(tablePos, 26 /*Vf64*/, 8 /*double*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}

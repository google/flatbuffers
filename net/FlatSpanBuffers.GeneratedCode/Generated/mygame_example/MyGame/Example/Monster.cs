// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace MyGame.Example
{

using global::System;
using global::System.Buffers;
using global::System.Collections.Generic;
using global::System.Runtime.InteropServices;
using global::Google.FlatSpanBuffers;
using global::Google.FlatSpanBuffers.Operations;
using global::Google.FlatSpanBuffers.Utils;
using global::Google.FlatSpanBuffers.Vectors;
/// an example documentation comment: "monster object"
public struct Monster : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
  public static Monster GetRootAsMonster(ByteBuffer _bb) { return GetRootAsMonster(_bb, new Monster()); }
  public static Monster GetRootAsMonster(ByteBuffer _bb, Monster obj) { return (obj.__assign(_bb.Get<int>(_bb.Position) + _bb.Position, _bb)); }
  public static bool MonsterBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "MONS"); }
  public static bool VerifyMonster(ByteBuffer _bb) {Google.FlatSpanBuffers.Verifier verifier = new Google.FlatSpanBuffers.Verifier(_bb); return verifier.VerifyBuffer("MONS", false, MyGame.Example.MonsterVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Monster __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public MyGame.Example.Vec3? Pos { get { int o = __p.__offset(4); return o != 0 ? (MyGame.Example.Vec3?)(new MyGame.Example.Vec3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public short Mana { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)150; } }
  public bool MutateMana(short mana) { int o = __p.__offset(6); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, mana); return true; } else { return false; } }
  public short Hp { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get<short>(o + __p.bb_pos) : (short)100; } }
  public bool MutateHp(short hp) { int o = __p.__offset(8); if (o != 0) { __p.bb.Put<short>(o + __p.bb_pos, hp); return true; } else { return false; } }
  public string Name { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
  public ReadOnlySpan<byte> GetNameBytes() { return __p.__vector_as_span<byte>(10); }
  public RefStructNullable<Span<byte>> MutableName { get { int o = __p.__offset(10); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(10)) : default; } }
  public RefStructNullable<ReadOnlySpan<byte>> Inventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public RefStructNullable<Span<byte>> MutableInventory { get { int o = __p.__offset(14); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(14)) : default; } }
  public bool MutateInventory(int j, byte inventory) { int o = __p.__offset(14); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, inventory); return true; } else { return false; } }
  public MyGame.Example.Color Color { get { int o = __p.__offset(16); return o != 0 ? (MyGame.Example.Color)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.Color.Blue; } }
  public bool MutateColor(MyGame.Example.Color color) { int o = __p.__offset(16); if (o != 0) { __p.bb.PutByte(o + __p.bb_pos, (byte)color); return true; } else { return false; } }
  public MyGame.Example.Any TestType { get { int o = __p.__offset(18); return o != 0 ? (MyGame.Example.Any)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.Any.NONE; } }
  public TTable? Test<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(20); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public MyGame.Example.Monster TestAsMonster() { return Test<MyGame.Example.Monster>().Value; }
  public MyGame.Example.TestSimpleTableWithEnum TestAsTestSimpleTableWithEnum() { return Test<MyGame.Example.TestSimpleTableWithEnum>().Value; }
  public MyGame.Example2.Monster TestAsMyGame_Example2_Monster() { return Test<MyGame.Example2.Monster>().Value; }
  public StructVector<MyGame.Example.Test>? Test4 { get { int o = __p.__offset(22); return o != 0 ? new StructVector<MyGame.Example.Test>(__p, o, 4) : null; } }
  public StringVector? Testarrayofstring { get { int o = __p.__offset(24); return o != 0 ? new StringVector(__p, o) : null; } }
  /// an example documentation comment: this will end up in the generated code
  /// multiline too
  public TableVector<MyGame.Example.Monster>? Testarrayoftables { get { int o = __p.__offset(26); return o != 0 ? new TableVector<MyGame.Example.Monster>(__p, o, 4) : null; } }
  public bool TryGetTestarrayoftablesByKey(string key, out MyGame.Example.Monster value) { int o = __p.__offset(26); if (o != 0) { return MyGame.Example.Monster.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public MyGame.Example.Monster? Enemy { get { int o = __p.__offset(28); return o != 0 ? (MyGame.Example.Monster?)(new MyGame.Example.Monster()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public RefStructNullable<ReadOnlySpan<byte>> Testnestedflatbuffer { get { int o = __p.__offset(30); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(30)) : default; } }
  public RefStructNullable<Span<byte>> MutableTestnestedflatbuffer { get { int o = __p.__offset(30); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(30)) : default; } }
  public MyGame.Example.Monster? GetTestnestedflatbufferAsMonster() { int o = __p.__offset(30); return o != 0 ? (MyGame.Example.Monster?)(new MyGame.Example.Monster()).__assign(__p.__indirect(__p.__vector(o)), __p.bb) : null; }
  public bool MutateTestnestedflatbuffer(int j, byte testnestedflatbuffer) { int o = __p.__offset(30); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, testnestedflatbuffer); return true; } else { return false; } }
  public MyGame.Example.Stat? Testempty { get { int o = __p.__offset(32); return o != 0 ? (MyGame.Example.Stat?)(new MyGame.Example.Stat()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public bool Testbool { get { int o = __p.__offset(34); return o != 0 ? __p.bb.Get<bool>(o + __p.bb_pos) : (bool)false; } }
  public bool MutateTestbool(bool testbool) { int o = __p.__offset(34); if (o != 0) { __p.bb.PutByte(o + __p.bb_pos, (byte)(testbool ? 1 : 0)); return true; } else { return false; } }
  public int Testhashs32Fnv1 { get { int o = __p.__offset(36); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)0; } }
  public bool MutateTesthashs32Fnv1(int testhashs32_fnv1) { int o = __p.__offset(36); if (o != 0) { __p.bb.Put<int>(o + __p.bb_pos, testhashs32_fnv1); return true; } else { return false; } }
  public uint Testhashu32Fnv1 { get { int o = __p.__offset(38); return o != 0 ? __p.bb.Get<uint>(o + __p.bb_pos) : (uint)0; } }
  public bool MutateTesthashu32Fnv1(uint testhashu32_fnv1) { int o = __p.__offset(38); if (o != 0) { __p.bb.Put<uint>(o + __p.bb_pos, testhashu32_fnv1); return true; } else { return false; } }
  public long Testhashs64Fnv1 { get { int o = __p.__offset(40); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public bool MutateTesthashs64Fnv1(long testhashs64_fnv1) { int o = __p.__offset(40); if (o != 0) { __p.bb.Put<long>(o + __p.bb_pos, testhashs64_fnv1); return true; } else { return false; } }
  public ulong Testhashu64Fnv1 { get { int o = __p.__offset(42); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateTesthashu64Fnv1(ulong testhashu64_fnv1) { int o = __p.__offset(42); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, testhashu64_fnv1); return true; } else { return false; } }
  public int Testhashs32Fnv1a { get { int o = __p.__offset(44); return o != 0 ? __p.bb.Get<int>(o + __p.bb_pos) : (int)0; } }
  public bool MutateTesthashs32Fnv1a(int testhashs32_fnv1a) { int o = __p.__offset(44); if (o != 0) { __p.bb.Put<int>(o + __p.bb_pos, testhashs32_fnv1a); return true; } else { return false; } }
  public uint Testhashu32Fnv1a { get { int o = __p.__offset(46); return o != 0 ? __p.bb.Get<uint>(o + __p.bb_pos) : (uint)0; } }
  public bool MutateTesthashu32Fnv1a(uint testhashu32_fnv1a) { int o = __p.__offset(46); if (o != 0) { __p.bb.Put<uint>(o + __p.bb_pos, testhashu32_fnv1a); return true; } else { return false; } }
  public long Testhashs64Fnv1a { get { int o = __p.__offset(48); return o != 0 ? __p.bb.Get<long>(o + __p.bb_pos) : (long)0; } }
  public bool MutateTesthashs64Fnv1a(long testhashs64_fnv1a) { int o = __p.__offset(48); if (o != 0) { __p.bb.Put<long>(o + __p.bb_pos, testhashs64_fnv1a); return true; } else { return false; } }
  public ulong Testhashu64Fnv1a { get { int o = __p.__offset(50); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateTesthashu64Fnv1a(ulong testhashu64_fnv1a) { int o = __p.__offset(50); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, testhashu64_fnv1a); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<bool>> Testarrayofbools { get { int o = __p.__offset(52); return o != 0 ? new RefStructNullable<ReadOnlySpan<bool>>(__p.__vector_as_span<bool>(52)) : default; } }
  public RefStructNullable<Span<bool>> MutableTestarrayofbools { get { int o = __p.__offset(52); return o != 0 ? new RefStructNullable<Span<bool>>(__p.__vector_as_span<bool>(52)) : default; } }
  public bool MutateTestarrayofbools(int j, bool testarrayofbools) { int o = __p.__offset(52); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, (byte)(testarrayofbools ? 1 : 0)); return true; } else { return false; } }
  public float Testf { get { int o = __p.__offset(54); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)3.14159f; } }
  public bool MutateTestf(float testf) { int o = __p.__offset(54); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, testf); return true; } else { return false; } }
  public float Testf2 { get { int o = __p.__offset(56); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)3.0f; } }
  public bool MutateTestf2(float testf2) { int o = __p.__offset(56); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, testf2); return true; } else { return false; } }
  public float Testf3 { get { int o = __p.__offset(58); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)0.0f; } }
  public bool MutateTestf3(float testf3) { int o = __p.__offset(58); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, testf3); return true; } else { return false; } }
  public StringVector? Testarrayofstring2 { get { int o = __p.__offset(60); return o != 0 ? new StringVector(__p, o) : null; } }
  public StructVector<MyGame.Example.Ability>? Testarrayofsortedstruct { get { int o = __p.__offset(62); return o != 0 ? new StructVector<MyGame.Example.Ability>(__p, o, 8) : null; } }
  public RefStructNullable<ReadOnlySpan<byte>> Flex { get { int o = __p.__offset(64); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(64)) : default; } }
  public RefStructNullable<Span<byte>> MutableFlex { get { int o = __p.__offset(64); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(64)) : default; } }
  public bool MutateFlex(int j, byte flex) { int o = __p.__offset(64); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, flex); return true; } else { return false; } }
  public StructVector<MyGame.Example.Test>? Test5 { get { int o = __p.__offset(66); return o != 0 ? new StructVector<MyGame.Example.Test>(__p, o, 4) : null; } }
  public RefStructNullable<ReadOnlySpan<long>> VectorOfLongs { get { int o = __p.__offset(68); return o != 0 ? new RefStructNullable<ReadOnlySpan<long>>(__p.__vector_as_span<long>(68)) : default; } }
  public RefStructNullable<Span<long>> MutableVectorOfLongs { get { int o = __p.__offset(68); return o != 0 ? new RefStructNullable<Span<long>>(__p.__vector_as_span<long>(68)) : default; } }
  public bool MutateVectorOfLongs(int j, long vector_of_longs) { int o = __p.__offset(68); if (o != 0) { __p.bb.Put<long>(__p.__vector(o) + j * 8, vector_of_longs); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<double>> VectorOfDoubles { get { int o = __p.__offset(70); return o != 0 ? new RefStructNullable<ReadOnlySpan<double>>(__p.__vector_as_span<double>(70)) : default; } }
  public RefStructNullable<Span<double>> MutableVectorOfDoubles { get { int o = __p.__offset(70); return o != 0 ? new RefStructNullable<Span<double>>(__p.__vector_as_span<double>(70)) : default; } }
  public bool MutateVectorOfDoubles(int j, double vector_of_doubles) { int o = __p.__offset(70); if (o != 0) { __p.bb.Put<double>(__p.__vector(o) + j * 8, vector_of_doubles); return true; } else { return false; } }
  public MyGame.InParentNamespace? ParentNamespaceTest { get { int o = __p.__offset(72); return o != 0 ? (MyGame.InParentNamespace?)(new MyGame.InParentNamespace()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public TableVector<MyGame.Example.Referrable>? VectorOfReferrables { get { int o = __p.__offset(74); return o != 0 ? new TableVector<MyGame.Example.Referrable>(__p, o, 4) : null; } }
  public bool TryGetVectorOfReferrablesByKey(ulong key, out MyGame.Example.Referrable value) { int o = __p.__offset(74); if (o != 0) { return MyGame.Example.Referrable.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public ulong SingleWeakReference { get { int o = __p.__offset(76); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateSingleWeakReference(ulong single_weak_reference) { int o = __p.__offset(76); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, single_weak_reference); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<ulong>> VectorOfWeakReferences { get { int o = __p.__offset(78); return o != 0 ? new RefStructNullable<ReadOnlySpan<ulong>>(__p.__vector_as_span<ulong>(78)) : default; } }
  public RefStructNullable<Span<ulong>> MutableVectorOfWeakReferences { get { int o = __p.__offset(78); return o != 0 ? new RefStructNullable<Span<ulong>>(__p.__vector_as_span<ulong>(78)) : default; } }
  public bool MutateVectorOfWeakReferences(int j, ulong vector_of_weak_references) { int o = __p.__offset(78); if (o != 0) { __p.bb.Put<ulong>(__p.__vector(o) + j * 8, vector_of_weak_references); return true; } else { return false; } }
  public TableVector<MyGame.Example.Referrable>? VectorOfStrongReferrables { get { int o = __p.__offset(80); return o != 0 ? new TableVector<MyGame.Example.Referrable>(__p, o, 4) : null; } }
  public bool TryGetVectorOfStrongReferrablesByKey(ulong key, out MyGame.Example.Referrable value) { int o = __p.__offset(80); if (o != 0) { return MyGame.Example.Referrable.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public ulong CoOwningReference { get { int o = __p.__offset(82); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateCoOwningReference(ulong co_owning_reference) { int o = __p.__offset(82); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, co_owning_reference); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<ulong>> VectorOfCoOwningReferences { get { int o = __p.__offset(84); return o != 0 ? new RefStructNullable<ReadOnlySpan<ulong>>(__p.__vector_as_span<ulong>(84)) : default; } }
  public RefStructNullable<Span<ulong>> MutableVectorOfCoOwningReferences { get { int o = __p.__offset(84); return o != 0 ? new RefStructNullable<Span<ulong>>(__p.__vector_as_span<ulong>(84)) : default; } }
  public bool MutateVectorOfCoOwningReferences(int j, ulong vector_of_co_owning_references) { int o = __p.__offset(84); if (o != 0) { __p.bb.Put<ulong>(__p.__vector(o) + j * 8, vector_of_co_owning_references); return true; } else { return false; } }
  public ulong NonOwningReference { get { int o = __p.__offset(86); return o != 0 ? __p.bb.Get<ulong>(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateNonOwningReference(ulong non_owning_reference) { int o = __p.__offset(86); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, non_owning_reference); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<ulong>> VectorOfNonOwningReferences { get { int o = __p.__offset(88); return o != 0 ? new RefStructNullable<ReadOnlySpan<ulong>>(__p.__vector_as_span<ulong>(88)) : default; } }
  public RefStructNullable<Span<ulong>> MutableVectorOfNonOwningReferences { get { int o = __p.__offset(88); return o != 0 ? new RefStructNullable<Span<ulong>>(__p.__vector_as_span<ulong>(88)) : default; } }
  public bool MutateVectorOfNonOwningReferences(int j, ulong vector_of_non_owning_references) { int o = __p.__offset(88); if (o != 0) { __p.bb.Put<ulong>(__p.__vector(o) + j * 8, vector_of_non_owning_references); return true; } else { return false; } }
  public MyGame.Example.AnyUniqueAliases AnyUniqueType { get { int o = __p.__offset(90); return o != 0 ? (MyGame.Example.AnyUniqueAliases)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.AnyUniqueAliases.NONE; } }
  public TTable? AnyUnique<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(92); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public MyGame.Example.Monster AnyUniqueAsM() { return AnyUnique<MyGame.Example.Monster>().Value; }
  public MyGame.Example.TestSimpleTableWithEnum AnyUniqueAsTS() { return AnyUnique<MyGame.Example.TestSimpleTableWithEnum>().Value; }
  public MyGame.Example2.Monster AnyUniqueAsM2() { return AnyUnique<MyGame.Example2.Monster>().Value; }
  public MyGame.Example.AnyAmbiguousAliases AnyAmbiguousType { get { int o = __p.__offset(94); return o != 0 ? (MyGame.Example.AnyAmbiguousAliases)__p.bb.Get<byte>(o + __p.bb_pos) : MyGame.Example.AnyAmbiguousAliases.NONE; } }
  public TTable? AnyAmbiguous<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(96); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public MyGame.Example.Monster AnyAmbiguousAsM1() { return AnyAmbiguous<MyGame.Example.Monster>().Value; }
  public MyGame.Example.Monster AnyAmbiguousAsM2() { return AnyAmbiguous<MyGame.Example.Monster>().Value; }
  public MyGame.Example.Monster AnyAmbiguousAsM3() { return AnyAmbiguous<MyGame.Example.Monster>().Value; }
  public RefStructNullable<ReadOnlySpan<MyGame.Example.Color>> VectorOfEnums { get { int o = __p.__offset(98); return o != 0 ? new RefStructNullable<ReadOnlySpan<MyGame.Example.Color>>(__p.__vector_as_span<MyGame.Example.Color>(98)) : default; } }
  public RefStructNullable<Span<MyGame.Example.Color>> MutableVectorOfEnums { get { int o = __p.__offset(98); return o != 0 ? new RefStructNullable<Span<MyGame.Example.Color>>(__p.__vector_as_span<MyGame.Example.Color>(98)) : default; } }
  public bool MutateVectorOfEnums(int j, MyGame.Example.Color vector_of_enums) { int o = __p.__offset(98); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, (byte)vector_of_enums); return true; } else { return false; } }
  public MyGame.Example.Race SignedEnum { get { int o = __p.__offset(100); return o != 0 ? (MyGame.Example.Race)__p.bb.Get<sbyte>(o + __p.bb_pos) : MyGame.Example.Race.None; } }
  public bool MutateSignedEnum(MyGame.Example.Race signed_enum) { int o = __p.__offset(100); if (o != 0) { __p.bb.Put<sbyte>(o + __p.bb_pos, (sbyte)signed_enum); return true; } else { return false; } }
  public RefStructNullable<ReadOnlySpan<byte>> Testrequirednestedflatbuffer { get { int o = __p.__offset(102); return o != 0 ? new RefStructNullable<ReadOnlySpan<byte>>(__p.__vector_as_span<byte>(102)) : default; } }
  public RefStructNullable<Span<byte>> MutableTestrequirednestedflatbuffer { get { int o = __p.__offset(102); return o != 0 ? new RefStructNullable<Span<byte>>(__p.__vector_as_span<byte>(102)) : default; } }
  public MyGame.Example.Monster? GetTestrequirednestedflatbufferAsMonster() { int o = __p.__offset(102); return o != 0 ? (MyGame.Example.Monster?)(new MyGame.Example.Monster()).__assign(__p.__indirect(__p.__vector(o)), __p.bb) : null; }
  public bool MutateTestrequirednestedflatbuffer(int j, byte testrequirednestedflatbuffer) { int o = __p.__offset(102); if (o != 0) { __p.bb.PutByte(__p.__vector(o) + j * 1, testrequirednestedflatbuffer); return true; } else { return false; } }
  public TableVector<MyGame.Example.Stat>? ScalarKeySortedTables { get { int o = __p.__offset(104); return o != 0 ? new TableVector<MyGame.Example.Stat>(__p, o, 4) : null; } }
  public bool TryGetScalarKeySortedTablesByKey(ushort key, out MyGame.Example.Stat value) { int o = __p.__offset(104); if (o != 0) { return MyGame.Example.Stat.TryGetByKey(__p.__vector(o), key, __p.bb, out value); } value = default; return false; }
  public MyGame.Example.Test? NativeInline { get { int o = __p.__offset(106); return o != 0 ? (MyGame.Example.Test?)(new MyGame.Example.Test()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public MyGame.Example.LongEnum LongEnumNonEnumDefault { get { int o = __p.__offset(108); return o != 0 ? (MyGame.Example.LongEnum)__p.bb.Get<ulong>(o + __p.bb_pos) : 0; } }
  public bool MutateLongEnumNonEnumDefault(MyGame.Example.LongEnum long_enum_non_enum_default) { int o = __p.__offset(108); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, (ulong)long_enum_non_enum_default); return true; } else { return false; } }
  public MyGame.Example.LongEnum LongEnumNormalDefault { get { int o = __p.__offset(110); return o != 0 ? (MyGame.Example.LongEnum)__p.bb.Get<ulong>(o + __p.bb_pos) : MyGame.Example.LongEnum.LongOne; } }
  public bool MutateLongEnumNormalDefault(MyGame.Example.LongEnum long_enum_normal_default) { int o = __p.__offset(110); if (o != 0) { __p.bb.Put<ulong>(o + __p.bb_pos, (ulong)long_enum_normal_default); return true; } else { return false; } }
  public float NanDefault { get { int o = __p.__offset(112); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.NaN; } }
  public bool MutateNanDefault(float nan_default) { int o = __p.__offset(112); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, nan_default); return true; } else { return false; } }
  public float InfDefault { get { int o = __p.__offset(114); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutateInfDefault(float inf_default) { int o = __p.__offset(114); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, inf_default); return true; } else { return false; } }
  public float PositiveInfDefault { get { int o = __p.__offset(116); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutatePositiveInfDefault(float positive_inf_default) { int o = __p.__offset(116); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, positive_inf_default); return true; } else { return false; } }
  public float InfinityDefault { get { int o = __p.__offset(118); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutateInfinityDefault(float infinity_default) { int o = __p.__offset(118); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, infinity_default); return true; } else { return false; } }
  public float PositiveInfinityDefault { get { int o = __p.__offset(120); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.PositiveInfinity; } }
  public bool MutatePositiveInfinityDefault(float positive_infinity_default) { int o = __p.__offset(120); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, positive_infinity_default); return true; } else { return false; } }
  public float NegativeInfDefault { get { int o = __p.__offset(122); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.NegativeInfinity; } }
  public bool MutateNegativeInfDefault(float negative_inf_default) { int o = __p.__offset(122); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, negative_inf_default); return true; } else { return false; } }
  public float NegativeInfinityDefault { get { int o = __p.__offset(124); return o != 0 ? __p.bb.Get<float>(o + __p.bb_pos) : (float)Single.NegativeInfinity; } }
  public bool MutateNegativeInfinityDefault(float negative_infinity_default) { int o = __p.__offset(124); if (o != 0) { __p.bb.Put<float>(o + __p.bb_pos, negative_infinity_default); return true; } else { return false; } }
  public double DoubleInfDefault { get { int o = __p.__offset(126); return o != 0 ? __p.bb.Get<double>(o + __p.bb_pos) : (double)Double.PositiveInfinity; } }
  public bool MutateDoubleInfDefault(double double_inf_default) { int o = __p.__offset(126); if (o != 0) { __p.bb.Put<double>(o + __p.bb_pos, double_inf_default); return true; } else { return false; } }

  public static Offset<MyGame.Example.Monster> CreateMonster(FlatBufferBuilder builder,
      MyGame.Example.Vec3T pos = null,
      short mana = 150,
      short hp = 100,
      StringOffset nameOffset = default(StringOffset),
      VectorOffset inventoryOffset = default(VectorOffset),
      MyGame.Example.Color color = MyGame.Example.Color.Blue,
      MyGame.Example.Any test_type = MyGame.Example.Any.NONE,
      int testOffset = 0,
      VectorOffset test4Offset = default(VectorOffset),
      VectorOffset testarrayofstringOffset = default(VectorOffset),
      VectorOffset testarrayoftablesOffset = default(VectorOffset),
      Offset<MyGame.Example.Monster> enemyOffset = default(Offset<MyGame.Example.Monster>),
      VectorOffset testnestedflatbufferOffset = default(VectorOffset),
      Offset<MyGame.Example.Stat> testemptyOffset = default(Offset<MyGame.Example.Stat>),
      bool testbool = false,
      int testhashs32_fnv1 = 0,
      uint testhashu32_fnv1 = 0,
      long testhashs64_fnv1 = 0,
      ulong testhashu64_fnv1 = 0,
      int testhashs32_fnv1a = 0,
      uint testhashu32_fnv1a = 0,
      long testhashs64_fnv1a = 0,
      ulong testhashu64_fnv1a = 0,
      VectorOffset testarrayofboolsOffset = default(VectorOffset),
      float testf = 3.14159f,
      float testf2 = 3.0f,
      float testf3 = 0.0f,
      VectorOffset testarrayofstring2Offset = default(VectorOffset),
      VectorOffset testarrayofsortedstructOffset = default(VectorOffset),
      VectorOffset flexOffset = default(VectorOffset),
      VectorOffset test5Offset = default(VectorOffset),
      VectorOffset vector_of_longsOffset = default(VectorOffset),
      VectorOffset vector_of_doublesOffset = default(VectorOffset),
      Offset<MyGame.InParentNamespace> parent_namespace_testOffset = default(Offset<MyGame.InParentNamespace>),
      VectorOffset vector_of_referrablesOffset = default(VectorOffset),
      ulong single_weak_reference = 0,
      VectorOffset vector_of_weak_referencesOffset = default(VectorOffset),
      VectorOffset vector_of_strong_referrablesOffset = default(VectorOffset),
      ulong co_owning_reference = 0,
      VectorOffset vector_of_co_owning_referencesOffset = default(VectorOffset),
      ulong non_owning_reference = 0,
      VectorOffset vector_of_non_owning_referencesOffset = default(VectorOffset),
      MyGame.Example.AnyUniqueAliases any_unique_type = MyGame.Example.AnyUniqueAliases.NONE,
      int any_uniqueOffset = 0,
      MyGame.Example.AnyAmbiguousAliases any_ambiguous_type = MyGame.Example.AnyAmbiguousAliases.NONE,
      int any_ambiguousOffset = 0,
      VectorOffset vector_of_enumsOffset = default(VectorOffset),
      MyGame.Example.Race signed_enum = MyGame.Example.Race.None,
      VectorOffset testrequirednestedflatbufferOffset = default(VectorOffset),
      VectorOffset scalar_key_sorted_tablesOffset = default(VectorOffset),
      MyGame.Example.TestT native_inline = null,
      MyGame.Example.LongEnum long_enum_non_enum_default = 0,
      MyGame.Example.LongEnum long_enum_normal_default = MyGame.Example.LongEnum.LongOne,
      float nan_default = Single.NaN,
      float inf_default = Single.PositiveInfinity,
      float positive_inf_default = Single.PositiveInfinity,
      float infinity_default = Single.PositiveInfinity,
      float positive_infinity_default = Single.PositiveInfinity,
      float negative_inf_default = Single.NegativeInfinity,
      float negative_infinity_default = Single.NegativeInfinity,
      double double_inf_default = Double.PositiveInfinity) {
    builder.StartTable(62);
    Monster.AddDoubleInfDefault(builder, double_inf_default);
    Monster.AddLongEnumNormalDefault(builder, long_enum_normal_default);
    Monster.AddLongEnumNonEnumDefault(builder, long_enum_non_enum_default);
    Monster.AddNonOwningReference(builder, non_owning_reference);
    Monster.AddCoOwningReference(builder, co_owning_reference);
    Monster.AddSingleWeakReference(builder, single_weak_reference);
    Monster.AddTesthashu64Fnv1a(builder, testhashu64_fnv1a);
    Monster.AddTesthashs64Fnv1a(builder, testhashs64_fnv1a);
    Monster.AddTesthashu64Fnv1(builder, testhashu64_fnv1);
    Monster.AddTesthashs64Fnv1(builder, testhashs64_fnv1);
    Monster.AddNegativeInfinityDefault(builder, negative_infinity_default);
    Monster.AddNegativeInfDefault(builder, negative_inf_default);
    Monster.AddPositiveInfinityDefault(builder, positive_infinity_default);
    Monster.AddInfinityDefault(builder, infinity_default);
    Monster.AddPositiveInfDefault(builder, positive_inf_default);
    Monster.AddInfDefault(builder, inf_default);
    Monster.AddNanDefault(builder, nan_default);
    Monster.AddNativeInline(builder, MyGame.Example.Test.Pack(builder, native_inline));
    Monster.AddScalarKeySortedTables(builder, scalar_key_sorted_tablesOffset);
    Monster.AddTestrequirednestedflatbuffer(builder, testrequirednestedflatbufferOffset);
    Monster.AddVectorOfEnums(builder, vector_of_enumsOffset);
    Monster.AddAnyAmbiguous(builder, any_ambiguousOffset);
    Monster.AddAnyUnique(builder, any_uniqueOffset);
    Monster.AddVectorOfNonOwningReferences(builder, vector_of_non_owning_referencesOffset);
    Monster.AddVectorOfCoOwningReferences(builder, vector_of_co_owning_referencesOffset);
    Monster.AddVectorOfStrongReferrables(builder, vector_of_strong_referrablesOffset);
    Monster.AddVectorOfWeakReferences(builder, vector_of_weak_referencesOffset);
    Monster.AddVectorOfReferrables(builder, vector_of_referrablesOffset);
    Monster.AddParentNamespaceTest(builder, parent_namespace_testOffset);
    Monster.AddVectorOfDoubles(builder, vector_of_doublesOffset);
    Monster.AddVectorOfLongs(builder, vector_of_longsOffset);
    Monster.AddTest5(builder, test5Offset);
    Monster.AddFlex(builder, flexOffset);
    Monster.AddTestarrayofsortedstruct(builder, testarrayofsortedstructOffset);
    Monster.AddTestarrayofstring2(builder, testarrayofstring2Offset);
    Monster.AddTestf3(builder, testf3);
    Monster.AddTestf2(builder, testf2);
    Monster.AddTestf(builder, testf);
    Monster.AddTestarrayofbools(builder, testarrayofboolsOffset);
    Monster.AddTesthashu32Fnv1a(builder, testhashu32_fnv1a);
    Monster.AddTesthashs32Fnv1a(builder, testhashs32_fnv1a);
    Monster.AddTesthashu32Fnv1(builder, testhashu32_fnv1);
    Monster.AddTesthashs32Fnv1(builder, testhashs32_fnv1);
    Monster.AddTestempty(builder, testemptyOffset);
    Monster.AddTestnestedflatbuffer(builder, testnestedflatbufferOffset);
    Monster.AddEnemy(builder, enemyOffset);
    Monster.AddTestarrayoftables(builder, testarrayoftablesOffset);
    Monster.AddTestarrayofstring(builder, testarrayofstringOffset);
    Monster.AddTest4(builder, test4Offset);
    Monster.AddTest(builder, testOffset);
    Monster.AddInventory(builder, inventoryOffset);
    Monster.AddName(builder, nameOffset);
    Monster.AddPos(builder, MyGame.Example.Vec3.Pack(builder, pos));
    Monster.AddHp(builder, hp);
    Monster.AddMana(builder, mana);
    Monster.AddSignedEnum(builder, signed_enum);
    Monster.AddAnyAmbiguousType(builder, any_ambiguous_type);
    Monster.AddAnyUniqueType(builder, any_unique_type);
    Monster.AddTestbool(builder, testbool);
    Monster.AddTestType(builder, test_type);
    Monster.AddColor(builder, color);
    return Monster.EndMonster(builder);
  }

  public static void StartMonster(FlatBufferBuilder builder) { builder.StartTable(62); }
  public static void AddPos(FlatBufferBuilder builder, Offset<MyGame.Example.Vec3> posOffset) { builder.AddStruct(0, posOffset, 0); }
  public static void AddMana(FlatBufferBuilder builder, short mana) { builder.Add<short>(1, mana, 150); }
  public static void AddHp(FlatBufferBuilder builder, short hp) { builder.Add<short>(2, hp, 100); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(3, nameOffset, 0); }
  public static void AddInventory(FlatBufferBuilder builder, VectorOffset inventoryOffset) { builder.AddOffset(5, inventoryOffset, 0); }
  public static VectorOffset CreateInventoryVectorBlock(FlatBufferBuilder builder, Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateInventoryVector(FlatBufferBuilder builder, Span<byte> data) { return CreateInventoryVectorBlock(builder, data); }
  public static void StartInventoryVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddColor(FlatBufferBuilder builder, MyGame.Example.Color color) { builder.Add<byte>(6, (byte)color, 8); }
  public static void AddTestType(FlatBufferBuilder builder, MyGame.Example.Any testType) { builder.Add<byte>(7, (byte)testType, 0); }
  public static void AddTest(FlatBufferBuilder builder, int testOffset) { builder.AddOffset(8, testOffset, 0); }
  public static void AddTest4(FlatBufferBuilder builder, VectorOffset test4Offset) { builder.AddOffset(9, test4Offset, 0); }
  public static void StartTest4Vector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 2); }
  public static void AddTestarrayofstring(FlatBufferBuilder builder, VectorOffset testarrayofstringOffset) { builder.AddOffset(10, testarrayofstringOffset, 0); }
  public static VectorOffset CreateTestarrayofstringVectorBlock(FlatBufferBuilder builder, Span<StringOffset> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<StringOffset>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayofstringVector(FlatBufferBuilder builder, Span<StringOffset> data) { return CreateTestarrayofstringVectorBlock(builder, data); }
  public static void StartTestarrayofstringVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTestarrayoftables(FlatBufferBuilder builder, VectorOffset testarrayoftablesOffset) { builder.AddOffset(11, testarrayoftablesOffset, 0); }
  public static VectorOffset CreateTestarrayoftablesVectorBlock(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Monster>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.Monster>>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayoftablesVector(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Monster>> data) { return CreateTestarrayoftablesVectorBlock(builder, data); }
  public static void StartTestarrayoftablesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEnemy(FlatBufferBuilder builder, Offset<MyGame.Example.Monster> enemyOffset) { builder.AddOffset(12, enemyOffset, 0); }
  public static void AddTestnestedflatbuffer(FlatBufferBuilder builder, VectorOffset testnestedflatbufferOffset) { builder.AddOffset(13, testnestedflatbufferOffset, 0); }
  public static VectorOffset CreateTestnestedflatbufferVectorBlock(FlatBufferBuilder builder, Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestnestedflatbufferVector(FlatBufferBuilder builder, Span<byte> data) { return CreateTestnestedflatbufferVectorBlock(builder, data); }
  public static void StartTestnestedflatbufferVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTestempty(FlatBufferBuilder builder, Offset<MyGame.Example.Stat> testemptyOffset) { builder.AddOffset(14, testemptyOffset, 0); }
  public static void AddTestbool(FlatBufferBuilder builder, bool testbool) { builder.Add<bool>(15, testbool, false); }
  public static void AddTesthashs32Fnv1(FlatBufferBuilder builder, int testhashs32Fnv1) { builder.Add<int>(16, testhashs32Fnv1, 0); }
  public static void AddTesthashu32Fnv1(FlatBufferBuilder builder, uint testhashu32Fnv1) { builder.Add<uint>(17, testhashu32Fnv1, 0); }
  public static void AddTesthashs64Fnv1(FlatBufferBuilder builder, long testhashs64Fnv1) { builder.Add<long>(18, testhashs64Fnv1, 0); }
  public static void AddTesthashu64Fnv1(FlatBufferBuilder builder, ulong testhashu64Fnv1) { builder.Add<ulong>(19, testhashu64Fnv1, 0); }
  public static void AddTesthashs32Fnv1a(FlatBufferBuilder builder, int testhashs32Fnv1a) { builder.Add<int>(20, testhashs32Fnv1a, 0); }
  public static void AddTesthashu32Fnv1a(FlatBufferBuilder builder, uint testhashu32Fnv1a) { builder.Add<uint>(21, testhashu32Fnv1a, 0); }
  public static void AddTesthashs64Fnv1a(FlatBufferBuilder builder, long testhashs64Fnv1a) { builder.Add<long>(22, testhashs64Fnv1a, 0); }
  public static void AddTesthashu64Fnv1a(FlatBufferBuilder builder, ulong testhashu64Fnv1a) { builder.Add<ulong>(23, testhashu64Fnv1a, 0); }
  public static void AddTestarrayofbools(FlatBufferBuilder builder, VectorOffset testarrayofboolsOffset) { builder.AddOffset(24, testarrayofboolsOffset, 0); }
  public static VectorOffset CreateTestarrayofboolsVectorBlock(FlatBufferBuilder builder, Span<bool> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<bool>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayofboolsVector(FlatBufferBuilder builder, Span<bool> data) { return CreateTestarrayofboolsVectorBlock(builder, data); }
  public static void StartTestarrayofboolsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTestf(FlatBufferBuilder builder, float testf) { builder.Add<float>(25, testf, 3.14159f); }
  public static void AddTestf2(FlatBufferBuilder builder, float testf2) { builder.Add<float>(26, testf2, 3.0f); }
  public static void AddTestf3(FlatBufferBuilder builder, float testf3) { builder.Add<float>(27, testf3, 0.0f); }
  public static void AddTestarrayofstring2(FlatBufferBuilder builder, VectorOffset testarrayofstring2Offset) { builder.AddOffset(28, testarrayofstring2Offset, 0); }
  public static VectorOffset CreateTestarrayofstring2VectorBlock(FlatBufferBuilder builder, Span<StringOffset> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<StringOffset>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestarrayofstring2Vector(FlatBufferBuilder builder, Span<StringOffset> data) { return CreateTestarrayofstring2VectorBlock(builder, data); }
  public static void StartTestarrayofstring2Vector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTestarrayofsortedstruct(FlatBufferBuilder builder, VectorOffset testarrayofsortedstructOffset) { builder.AddOffset(29, testarrayofsortedstructOffset, 0); }
  public static void StartTestarrayofsortedstructVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 4); }
  public static void AddFlex(FlatBufferBuilder builder, VectorOffset flexOffset) { builder.AddOffset(30, flexOffset, 0); }
  public static VectorOffset CreateFlexVectorBlock(FlatBufferBuilder builder, Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateFlexVector(FlatBufferBuilder builder, Span<byte> data) { return CreateFlexVectorBlock(builder, data); }
  public static void StartFlexVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTest5(FlatBufferBuilder builder, VectorOffset test5Offset) { builder.AddOffset(31, test5Offset, 0); }
  public static void StartTest5Vector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 2); }
  public static void AddVectorOfLongs(FlatBufferBuilder builder, VectorOffset vectorOfLongsOffset) { builder.AddOffset(32, vectorOfLongsOffset, 0); }
  public static VectorOffset CreateVectorOfLongsVectorBlock(FlatBufferBuilder builder, Span<long> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<long>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfLongsVector(FlatBufferBuilder builder, Span<long> data) { return CreateVectorOfLongsVectorBlock(builder, data); }
  public static void StartVectorOfLongsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddVectorOfDoubles(FlatBufferBuilder builder, VectorOffset vectorOfDoublesOffset) { builder.AddOffset(33, vectorOfDoublesOffset, 0); }
  public static VectorOffset CreateVectorOfDoublesVectorBlock(FlatBufferBuilder builder, Span<double> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<double>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfDoublesVector(FlatBufferBuilder builder, Span<double> data) { return CreateVectorOfDoublesVectorBlock(builder, data); }
  public static void StartVectorOfDoublesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddParentNamespaceTest(FlatBufferBuilder builder, Offset<MyGame.InParentNamespace> parentNamespaceTestOffset) { builder.AddOffset(34, parentNamespaceTestOffset, 0); }
  public static void AddVectorOfReferrables(FlatBufferBuilder builder, VectorOffset vectorOfReferrablesOffset) { builder.AddOffset(35, vectorOfReferrablesOffset, 0); }
  public static VectorOffset CreateVectorOfReferrablesVectorBlock(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Referrable>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.Referrable>>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfReferrablesVector(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Referrable>> data) { return CreateVectorOfReferrablesVectorBlock(builder, data); }
  public static void StartVectorOfReferrablesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSingleWeakReference(FlatBufferBuilder builder, ulong singleWeakReference) { builder.Add<ulong>(36, singleWeakReference, 0); }
  public static void AddVectorOfWeakReferences(FlatBufferBuilder builder, VectorOffset vectorOfWeakReferencesOffset) { builder.AddOffset(37, vectorOfWeakReferencesOffset, 0); }
  public static VectorOffset CreateVectorOfWeakReferencesVectorBlock(FlatBufferBuilder builder, Span<ulong> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<ulong>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfWeakReferencesVector(FlatBufferBuilder builder, Span<ulong> data) { return CreateVectorOfWeakReferencesVectorBlock(builder, data); }
  public static void StartVectorOfWeakReferencesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddVectorOfStrongReferrables(FlatBufferBuilder builder, VectorOffset vectorOfStrongReferrablesOffset) { builder.AddOffset(38, vectorOfStrongReferrablesOffset, 0); }
  public static VectorOffset CreateVectorOfStrongReferrablesVectorBlock(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Referrable>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.Referrable>>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfStrongReferrablesVector(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Referrable>> data) { return CreateVectorOfStrongReferrablesVectorBlock(builder, data); }
  public static void StartVectorOfStrongReferrablesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCoOwningReference(FlatBufferBuilder builder, ulong coOwningReference) { builder.Add<ulong>(39, coOwningReference, 0); }
  public static void AddVectorOfCoOwningReferences(FlatBufferBuilder builder, VectorOffset vectorOfCoOwningReferencesOffset) { builder.AddOffset(40, vectorOfCoOwningReferencesOffset, 0); }
  public static VectorOffset CreateVectorOfCoOwningReferencesVectorBlock(FlatBufferBuilder builder, Span<ulong> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<ulong>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfCoOwningReferencesVector(FlatBufferBuilder builder, Span<ulong> data) { return CreateVectorOfCoOwningReferencesVectorBlock(builder, data); }
  public static void StartVectorOfCoOwningReferencesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddNonOwningReference(FlatBufferBuilder builder, ulong nonOwningReference) { builder.Add<ulong>(41, nonOwningReference, 0); }
  public static void AddVectorOfNonOwningReferences(FlatBufferBuilder builder, VectorOffset vectorOfNonOwningReferencesOffset) { builder.AddOffset(42, vectorOfNonOwningReferencesOffset, 0); }
  public static VectorOffset CreateVectorOfNonOwningReferencesVectorBlock(FlatBufferBuilder builder, Span<ulong> data) { builder.StartVector(8, data.Length, 8); builder.AddSpan<ulong>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfNonOwningReferencesVector(FlatBufferBuilder builder, Span<ulong> data) { return CreateVectorOfNonOwningReferencesVectorBlock(builder, data); }
  public static void StartVectorOfNonOwningReferencesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddAnyUniqueType(FlatBufferBuilder builder, MyGame.Example.AnyUniqueAliases anyUniqueType) { builder.Add<byte>(43, (byte)anyUniqueType, 0); }
  public static void AddAnyUnique(FlatBufferBuilder builder, int anyUniqueOffset) { builder.AddOffset(44, anyUniqueOffset, 0); }
  public static void AddAnyAmbiguousType(FlatBufferBuilder builder, MyGame.Example.AnyAmbiguousAliases anyAmbiguousType) { builder.Add<byte>(45, (byte)anyAmbiguousType, 0); }
  public static void AddAnyAmbiguous(FlatBufferBuilder builder, int anyAmbiguousOffset) { builder.AddOffset(46, anyAmbiguousOffset, 0); }
  public static void AddVectorOfEnums(FlatBufferBuilder builder, VectorOffset vectorOfEnumsOffset) { builder.AddOffset(47, vectorOfEnumsOffset, 0); }
  public static VectorOffset CreateVectorOfEnumsVectorBlock(FlatBufferBuilder builder, Span<MyGame.Example.Color> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<MyGame.Example.Color>(data); return builder.EndVector(); }
  public static VectorOffset CreateVectorOfEnumsVector(FlatBufferBuilder builder, Span<MyGame.Example.Color> data) { return CreateVectorOfEnumsVectorBlock(builder, data); }
  public static void StartVectorOfEnumsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddSignedEnum(FlatBufferBuilder builder, MyGame.Example.Race signedEnum) { builder.Add<sbyte>(48, (sbyte)signedEnum, -1); }
  public static void AddTestrequirednestedflatbuffer(FlatBufferBuilder builder, VectorOffset testrequirednestedflatbufferOffset) { builder.AddOffset(49, testrequirednestedflatbufferOffset, 0); }
  public static VectorOffset CreateTestrequirednestedflatbufferVectorBlock(FlatBufferBuilder builder, Span<byte> data) { builder.StartVector(1, data.Length, 1); builder.AddSpan<byte>(data); return builder.EndVector(); }
  public static VectorOffset CreateTestrequirednestedflatbufferVector(FlatBufferBuilder builder, Span<byte> data) { return CreateTestrequirednestedflatbufferVectorBlock(builder, data); }
  public static void StartTestrequirednestedflatbufferVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddScalarKeySortedTables(FlatBufferBuilder builder, VectorOffset scalarKeySortedTablesOffset) { builder.AddOffset(50, scalarKeySortedTablesOffset, 0); }
  public static VectorOffset CreateScalarKeySortedTablesVectorBlock(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Stat>> data) { builder.StartVector(4, data.Length, 4); builder.AddOffsetSpan<Offset<MyGame.Example.Stat>>(data); return builder.EndVector(); }
  public static VectorOffset CreateScalarKeySortedTablesVector(FlatBufferBuilder builder, Span<Offset<MyGame.Example.Stat>> data) { return CreateScalarKeySortedTablesVectorBlock(builder, data); }
  public static void StartScalarKeySortedTablesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddNativeInline(FlatBufferBuilder builder, Offset<MyGame.Example.Test> nativeInlineOffset) { builder.AddStruct(51, nativeInlineOffset, 0); }
  public static void AddLongEnumNonEnumDefault(FlatBufferBuilder builder, MyGame.Example.LongEnum longEnumNonEnumDefault) { builder.Add<ulong>(52, (ulong)longEnumNonEnumDefault, 0); }
  public static void AddLongEnumNormalDefault(FlatBufferBuilder builder, MyGame.Example.LongEnum longEnumNormalDefault) { builder.Add<ulong>(53, (ulong)longEnumNormalDefault, 2); }
  public static void AddNanDefault(FlatBufferBuilder builder, float nanDefault) { builder.Add<float>(54, nanDefault, Single.NaN); }
  public static void AddInfDefault(FlatBufferBuilder builder, float infDefault) { builder.Add<float>(55, infDefault, Single.PositiveInfinity); }
  public static void AddPositiveInfDefault(FlatBufferBuilder builder, float positiveInfDefault) { builder.Add<float>(56, positiveInfDefault, Single.PositiveInfinity); }
  public static void AddInfinityDefault(FlatBufferBuilder builder, float infinityDefault) { builder.Add<float>(57, infinityDefault, Single.PositiveInfinity); }
  public static void AddPositiveInfinityDefault(FlatBufferBuilder builder, float positiveInfinityDefault) { builder.Add<float>(58, positiveInfinityDefault, Single.PositiveInfinity); }
  public static void AddNegativeInfDefault(FlatBufferBuilder builder, float negativeInfDefault) { builder.Add<float>(59, negativeInfDefault, Single.NegativeInfinity); }
  public static void AddNegativeInfinityDefault(FlatBufferBuilder builder, float negativeInfinityDefault) { builder.Add<float>(60, negativeInfinityDefault, Single.NegativeInfinity); }
  public static void AddDoubleInfDefault(FlatBufferBuilder builder, double doubleInfDefault) { builder.Add<double>(61, doubleInfDefault, Double.PositiveInfinity); }
  public static Offset<MyGame.Example.Monster> EndMonster(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 10);  // name
    return new Offset<MyGame.Example.Monster>(o);
  }
  public static void FinishMonsterBuffer(FlatBufferBuilder builder, Offset<MyGame.Example.Monster> offset) { builder.Finish(offset.Value, "MONS"); }
  public static void FinishSizePrefixedMonsterBuffer(FlatBufferBuilder builder, Offset<MyGame.Example.Monster> offset) { builder.FinishSizePrefixed(offset.Value, "MONS"); }

  public static VectorOffset CreateSortedVectorOfMonster(FlatBufferBuilder builder, Span<Offset<Monster>> offsets) {
    var comparer = new SortedVectorUtils.VectorOffsetComparer<Monster, ByteBuffer, byte>(builder.DataBuffer, 10);
    RefStructSorters.Sort(offsets, ref comparer);
    return builder.CreateVectorOfTables<Monster>(offsets);
  }

  public static bool TryGetByKey(int vectorLocation, string key, ByteBuffer bb, out Monster value) {
    return SortedVectorUtils.TryGetByKey<Monster, ByteBuffer>(vectorLocation, key, ref bb, 10, out value);
  }
  public MonsterT UnPack() {
    var _o = new MonsterT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MonsterT _o) {
    if (this.Pos.HasValue) {
      if (_o.Pos == null) _o.Pos = new MyGame.Example.Vec3T();
      this.Pos.Value.UnPackTo(_o.Pos);
    } else {
      _o.Pos = null;
    }
    _o.Mana = this.Mana;
    _o.Hp = this.Hp;
    _o.Name = this.Name;
    var _inventory_vec = this.Inventory;
    var _inventory_len = _inventory_vec.HasValue ? _inventory_vec.Value.Length : 0;
    if (_o.Inventory == null) {
      _o.Inventory = new List<byte>(_inventory_len);
    }
    ObjectApiUtil.ResizeList(_o.Inventory, _inventory_len);
    if (_inventory_vec.HasValue) { _inventory_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Inventory)); }
    _o.Color = this.Color;
    if (_o.Test == null) {
      _o.Test = new MyGame.Example.AnyUnion();
    }
    var _TestOldType = _o.Test.Type;
    _o.Test.Type = this.TestType;
    switch (this.TestType) {
      default:
        _o.Test.Value = null;
        break;
      case MyGame.Example.Any.Monster:
        if (this.Test<MyGame.Example.Monster>().HasValue) {
          if (_TestOldType == MyGame.Example.Any.Monster) {
            this.Test<MyGame.Example.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.Test.Value);
          } else {
            _o.Test.Value = this.Test<MyGame.Example.Monster>().Value.UnPack();
          }
        } else {
          _o.Test.Value = null;
        }
        break;
      case MyGame.Example.Any.TestSimpleTableWithEnum:
        if (this.Test<MyGame.Example.TestSimpleTableWithEnum>().HasValue) {
          if (_TestOldType == MyGame.Example.Any.TestSimpleTableWithEnum) {
            this.Test<MyGame.Example.TestSimpleTableWithEnum>().Value.UnPackTo((MyGame.Example.TestSimpleTableWithEnumT)_o.Test.Value);
          } else {
            _o.Test.Value = this.Test<MyGame.Example.TestSimpleTableWithEnum>().Value.UnPack();
          }
        } else {
          _o.Test.Value = null;
        }
        break;
      case MyGame.Example.Any.MyGame_Example2_Monster:
        if (this.Test<MyGame.Example2.Monster>().HasValue) {
          if (_TestOldType == MyGame.Example.Any.MyGame_Example2_Monster) {
            this.Test<MyGame.Example2.Monster>().Value.UnPackTo((MyGame.Example2.MonsterT)_o.Test.Value);
          } else {
            _o.Test.Value = this.Test<MyGame.Example2.Monster>().Value.UnPack();
          }
        } else {
          _o.Test.Value = null;
        }
        break;
    }
    var _test4_vec = this.Test4;
    var _test4_len = _test4_vec.HasValue ? _test4_vec.Value.Length : 0;
    if (_o.Test4 == null) {
      _o.Test4 = new List<MyGame.Example.TestT>(_test4_len);
    }
    ObjectApiUtil.ResizeList(_o.Test4, _test4_len);
    if (_test4_vec.HasValue) {
      var _test4_value = _test4_vec.Value;
      for (var _j = 0; _j < _test4_len; ++_j) {
        var _src = _test4_value[_j];
        if (_o.Test4[_j] == null) { _o.Test4[_j] = new TestT(); }
        _src.UnPackTo(_o.Test4[_j]);
      }
    }
    var _testarrayofstring_vec = this.Testarrayofstring;
    var _testarrayofstring_len = _testarrayofstring_vec.HasValue ? _testarrayofstring_vec.Value.Length : 0;
    if (_o.Testarrayofstring == null) {
      _o.Testarrayofstring = new List<string>(_testarrayofstring_len);
    } else {
      _o.Testarrayofstring.Clear();
      if (_o.Testarrayofstring.Capacity < _testarrayofstring_len) {
        _o.Testarrayofstring.Capacity = _testarrayofstring_len;
      }
    }
    if (_testarrayofstring_vec.HasValue) {
      var _testarrayofstring_value = _testarrayofstring_vec.Value;
      for (var _j = 0; _j < _testarrayofstring_len; ++_j) { _o.Testarrayofstring.Add(_testarrayofstring_value[_j]); }
    }
    var _testarrayoftables_vec = this.Testarrayoftables;
    var _testarrayoftables_len = _testarrayoftables_vec.HasValue ? _testarrayoftables_vec.Value.Length : 0;
    if (_o.Testarrayoftables == null) {
      _o.Testarrayoftables = new List<MyGame.Example.MonsterT>(_testarrayoftables_len);
    }
    ObjectApiUtil.ResizeList(_o.Testarrayoftables, _testarrayoftables_len);
    if (_testarrayoftables_vec.HasValue) {
      var _testarrayoftables_value = _testarrayoftables_vec.Value;
      for (var _j = 0; _j < _testarrayoftables_len; ++_j) {
        var _src = _testarrayoftables_value[_j];
        if (_o.Testarrayoftables[_j] == null) { _o.Testarrayoftables[_j] = new MonsterT(); }
        _src.UnPackTo(_o.Testarrayoftables[_j]);
      }
    }
    if (this.Enemy.HasValue) {
      if (_o.Enemy == null) _o.Enemy = new MyGame.Example.MonsterT();
      this.Enemy.Value.UnPackTo(_o.Enemy);
    } else {
      _o.Enemy = null;
    }
    var _testnestedflatbuffer_vec = this.Testnestedflatbuffer;
    var _testnestedflatbuffer_len = _testnestedflatbuffer_vec.HasValue ? _testnestedflatbuffer_vec.Value.Length : 0;
    if (_o.Testnestedflatbuffer == null) {
      _o.Testnestedflatbuffer = new List<byte>(_testnestedflatbuffer_len);
    }
    ObjectApiUtil.ResizeList(_o.Testnestedflatbuffer, _testnestedflatbuffer_len);
    if (_testnestedflatbuffer_vec.HasValue) { _testnestedflatbuffer_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Testnestedflatbuffer)); }
    if (this.Testempty.HasValue) {
      if (_o.Testempty == null) _o.Testempty = new MyGame.Example.StatT();
      this.Testempty.Value.UnPackTo(_o.Testempty);
    } else {
      _o.Testempty = null;
    }
    _o.Testbool = this.Testbool;
    _o.Testhashs32Fnv1 = this.Testhashs32Fnv1;
    _o.Testhashu32Fnv1 = this.Testhashu32Fnv1;
    _o.Testhashs64Fnv1 = this.Testhashs64Fnv1;
    _o.Testhashu64Fnv1 = this.Testhashu64Fnv1;
    _o.Testhashs32Fnv1a = this.Testhashs32Fnv1a;
    _o.Testhashu32Fnv1a = this.Testhashu32Fnv1a;
    _o.Testhashs64Fnv1a = this.Testhashs64Fnv1a;
    _o.Testhashu64Fnv1a = this.Testhashu64Fnv1a;
    var _testarrayofbools_vec = this.Testarrayofbools;
    var _testarrayofbools_len = _testarrayofbools_vec.HasValue ? _testarrayofbools_vec.Value.Length : 0;
    if (_o.Testarrayofbools == null) {
      _o.Testarrayofbools = new List<bool>(_testarrayofbools_len);
    } else {
      _o.Testarrayofbools.Clear();
      if (_o.Testarrayofbools.Capacity < _testarrayofbools_len) {
        _o.Testarrayofbools.Capacity = _testarrayofbools_len;
      }
    }
    if (_testarrayofbools_vec.HasValue) {
      for (var _j = 0; _j < _testarrayofbools_len; ++_j) { _o.Testarrayofbools.Add(_testarrayofbools_vec.Value[_j]); }
    }
    _o.Testf = this.Testf;
    _o.Testf2 = this.Testf2;
    _o.Testf3 = this.Testf3;
    var _testarrayofstring2_vec = this.Testarrayofstring2;
    var _testarrayofstring2_len = _testarrayofstring2_vec.HasValue ? _testarrayofstring2_vec.Value.Length : 0;
    if (_o.Testarrayofstring2 == null) {
      _o.Testarrayofstring2 = new List<string>(_testarrayofstring2_len);
    } else {
      _o.Testarrayofstring2.Clear();
      if (_o.Testarrayofstring2.Capacity < _testarrayofstring2_len) {
        _o.Testarrayofstring2.Capacity = _testarrayofstring2_len;
      }
    }
    if (_testarrayofstring2_vec.HasValue) {
      var _testarrayofstring2_value = _testarrayofstring2_vec.Value;
      for (var _j = 0; _j < _testarrayofstring2_len; ++_j) { _o.Testarrayofstring2.Add(_testarrayofstring2_value[_j]); }
    }
    var _testarrayofsortedstruct_vec = this.Testarrayofsortedstruct;
    var _testarrayofsortedstruct_len = _testarrayofsortedstruct_vec.HasValue ? _testarrayofsortedstruct_vec.Value.Length : 0;
    if (_o.Testarrayofsortedstruct == null) {
      _o.Testarrayofsortedstruct = new List<MyGame.Example.AbilityT>(_testarrayofsortedstruct_len);
    }
    ObjectApiUtil.ResizeList(_o.Testarrayofsortedstruct, _testarrayofsortedstruct_len);
    if (_testarrayofsortedstruct_vec.HasValue) {
      var _testarrayofsortedstruct_value = _testarrayofsortedstruct_vec.Value;
      for (var _j = 0; _j < _testarrayofsortedstruct_len; ++_j) {
        var _src = _testarrayofsortedstruct_value[_j];
        if (_o.Testarrayofsortedstruct[_j] == null) { _o.Testarrayofsortedstruct[_j] = new AbilityT(); }
        _src.UnPackTo(_o.Testarrayofsortedstruct[_j]);
      }
    }
    var _flex_vec = this.Flex;
    var _flex_len = _flex_vec.HasValue ? _flex_vec.Value.Length : 0;
    if (_o.Flex == null) {
      _o.Flex = new List<byte>(_flex_len);
    }
    ObjectApiUtil.ResizeList(_o.Flex, _flex_len);
    if (_flex_vec.HasValue) { _flex_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Flex)); }
    var _test5_vec = this.Test5;
    var _test5_len = _test5_vec.HasValue ? _test5_vec.Value.Length : 0;
    if (_o.Test5 == null) {
      _o.Test5 = new List<MyGame.Example.TestT>(_test5_len);
    }
    ObjectApiUtil.ResizeList(_o.Test5, _test5_len);
    if (_test5_vec.HasValue) {
      var _test5_value = _test5_vec.Value;
      for (var _j = 0; _j < _test5_len; ++_j) {
        var _src = _test5_value[_j];
        if (_o.Test5[_j] == null) { _o.Test5[_j] = new TestT(); }
        _src.UnPackTo(_o.Test5[_j]);
      }
    }
    var _vector_of_longs_vec = this.VectorOfLongs;
    var _vector_of_longs_len = _vector_of_longs_vec.HasValue ? _vector_of_longs_vec.Value.Length : 0;
    if (_o.VectorOfLongs == null) {
      _o.VectorOfLongs = new List<long>(_vector_of_longs_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfLongs, _vector_of_longs_len);
    if (_vector_of_longs_vec.HasValue) { _vector_of_longs_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfLongs)); }
    var _vector_of_doubles_vec = this.VectorOfDoubles;
    var _vector_of_doubles_len = _vector_of_doubles_vec.HasValue ? _vector_of_doubles_vec.Value.Length : 0;
    if (_o.VectorOfDoubles == null) {
      _o.VectorOfDoubles = new List<double>(_vector_of_doubles_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfDoubles, _vector_of_doubles_len);
    if (_vector_of_doubles_vec.HasValue) { _vector_of_doubles_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfDoubles)); }
    if (this.ParentNamespaceTest.HasValue) {
      if (_o.ParentNamespaceTest == null) _o.ParentNamespaceTest = new MyGame.InParentNamespaceT();
      this.ParentNamespaceTest.Value.UnPackTo(_o.ParentNamespaceTest);
    } else {
      _o.ParentNamespaceTest = null;
    }
    var _vector_of_referrables_vec = this.VectorOfReferrables;
    var _vector_of_referrables_len = _vector_of_referrables_vec.HasValue ? _vector_of_referrables_vec.Value.Length : 0;
    if (_o.VectorOfReferrables == null) {
      _o.VectorOfReferrables = new List<MyGame.Example.ReferrableT>(_vector_of_referrables_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfReferrables, _vector_of_referrables_len);
    if (_vector_of_referrables_vec.HasValue) {
      var _vector_of_referrables_value = _vector_of_referrables_vec.Value;
      for (var _j = 0; _j < _vector_of_referrables_len; ++_j) {
        var _src = _vector_of_referrables_value[_j];
        if (_o.VectorOfReferrables[_j] == null) { _o.VectorOfReferrables[_j] = new ReferrableT(); }
        _src.UnPackTo(_o.VectorOfReferrables[_j]);
      }
    }
    _o.SingleWeakReference = this.SingleWeakReference;
    var _vector_of_weak_references_vec = this.VectorOfWeakReferences;
    var _vector_of_weak_references_len = _vector_of_weak_references_vec.HasValue ? _vector_of_weak_references_vec.Value.Length : 0;
    if (_o.VectorOfWeakReferences == null) {
      _o.VectorOfWeakReferences = new List<ulong>(_vector_of_weak_references_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfWeakReferences, _vector_of_weak_references_len);
    if (_vector_of_weak_references_vec.HasValue) { _vector_of_weak_references_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfWeakReferences)); }
    var _vector_of_strong_referrables_vec = this.VectorOfStrongReferrables;
    var _vector_of_strong_referrables_len = _vector_of_strong_referrables_vec.HasValue ? _vector_of_strong_referrables_vec.Value.Length : 0;
    if (_o.VectorOfStrongReferrables == null) {
      _o.VectorOfStrongReferrables = new List<MyGame.Example.ReferrableT>(_vector_of_strong_referrables_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfStrongReferrables, _vector_of_strong_referrables_len);
    if (_vector_of_strong_referrables_vec.HasValue) {
      var _vector_of_strong_referrables_value = _vector_of_strong_referrables_vec.Value;
      for (var _j = 0; _j < _vector_of_strong_referrables_len; ++_j) {
        var _src = _vector_of_strong_referrables_value[_j];
        if (_o.VectorOfStrongReferrables[_j] == null) { _o.VectorOfStrongReferrables[_j] = new ReferrableT(); }
        _src.UnPackTo(_o.VectorOfStrongReferrables[_j]);
      }
    }
    _o.CoOwningReference = this.CoOwningReference;
    var _vector_of_co_owning_references_vec = this.VectorOfCoOwningReferences;
    var _vector_of_co_owning_references_len = _vector_of_co_owning_references_vec.HasValue ? _vector_of_co_owning_references_vec.Value.Length : 0;
    if (_o.VectorOfCoOwningReferences == null) {
      _o.VectorOfCoOwningReferences = new List<ulong>(_vector_of_co_owning_references_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfCoOwningReferences, _vector_of_co_owning_references_len);
    if (_vector_of_co_owning_references_vec.HasValue) { _vector_of_co_owning_references_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfCoOwningReferences)); }
    _o.NonOwningReference = this.NonOwningReference;
    var _vector_of_non_owning_references_vec = this.VectorOfNonOwningReferences;
    var _vector_of_non_owning_references_len = _vector_of_non_owning_references_vec.HasValue ? _vector_of_non_owning_references_vec.Value.Length : 0;
    if (_o.VectorOfNonOwningReferences == null) {
      _o.VectorOfNonOwningReferences = new List<ulong>(_vector_of_non_owning_references_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfNonOwningReferences, _vector_of_non_owning_references_len);
    if (_vector_of_non_owning_references_vec.HasValue) { _vector_of_non_owning_references_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfNonOwningReferences)); }
    if (_o.AnyUnique == null) {
      _o.AnyUnique = new MyGame.Example.AnyUniqueAliasesUnion();
    }
    var _AnyUniqueOldType = _o.AnyUnique.Type;
    _o.AnyUnique.Type = this.AnyUniqueType;
    switch (this.AnyUniqueType) {
      default:
        _o.AnyUnique.Value = null;
        break;
      case MyGame.Example.AnyUniqueAliases.M:
        if (this.AnyUnique<MyGame.Example.Monster>().HasValue) {
          if (_AnyUniqueOldType == MyGame.Example.AnyUniqueAliases.M) {
            this.AnyUnique<MyGame.Example.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyUnique.Value);
          } else {
            _o.AnyUnique.Value = this.AnyUnique<MyGame.Example.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyUnique.Value = null;
        }
        break;
      case MyGame.Example.AnyUniqueAliases.TS:
        if (this.AnyUnique<MyGame.Example.TestSimpleTableWithEnum>().HasValue) {
          if (_AnyUniqueOldType == MyGame.Example.AnyUniqueAliases.TS) {
            this.AnyUnique<MyGame.Example.TestSimpleTableWithEnum>().Value.UnPackTo((MyGame.Example.TestSimpleTableWithEnumT)_o.AnyUnique.Value);
          } else {
            _o.AnyUnique.Value = this.AnyUnique<MyGame.Example.TestSimpleTableWithEnum>().Value.UnPack();
          }
        } else {
          _o.AnyUnique.Value = null;
        }
        break;
      case MyGame.Example.AnyUniqueAliases.M2:
        if (this.AnyUnique<MyGame.Example2.Monster>().HasValue) {
          if (_AnyUniqueOldType == MyGame.Example.AnyUniqueAliases.M2) {
            this.AnyUnique<MyGame.Example2.Monster>().Value.UnPackTo((MyGame.Example2.MonsterT)_o.AnyUnique.Value);
          } else {
            _o.AnyUnique.Value = this.AnyUnique<MyGame.Example2.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyUnique.Value = null;
        }
        break;
    }
    if (_o.AnyAmbiguous == null) {
      _o.AnyAmbiguous = new MyGame.Example.AnyAmbiguousAliasesUnion();
    }
    var _AnyAmbiguousOldType = _o.AnyAmbiguous.Type;
    _o.AnyAmbiguous.Type = this.AnyAmbiguousType;
    switch (this.AnyAmbiguousType) {
      default:
        _o.AnyAmbiguous.Value = null;
        break;
      case MyGame.Example.AnyAmbiguousAliases.M1:
        if (this.AnyAmbiguous<MyGame.Example.Monster>().HasValue) {
          if (_AnyAmbiguousOldType == MyGame.Example.AnyAmbiguousAliases.M1) {
            this.AnyAmbiguous<MyGame.Example.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyAmbiguous.Value);
          } else {
            _o.AnyAmbiguous.Value = this.AnyAmbiguous<MyGame.Example.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyAmbiguous.Value = null;
        }
        break;
      case MyGame.Example.AnyAmbiguousAliases.M2:
        if (this.AnyAmbiguous<MyGame.Example.Monster>().HasValue) {
          if (_AnyAmbiguousOldType == MyGame.Example.AnyAmbiguousAliases.M2) {
            this.AnyAmbiguous<MyGame.Example.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyAmbiguous.Value);
          } else {
            _o.AnyAmbiguous.Value = this.AnyAmbiguous<MyGame.Example.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyAmbiguous.Value = null;
        }
        break;
      case MyGame.Example.AnyAmbiguousAliases.M3:
        if (this.AnyAmbiguous<MyGame.Example.Monster>().HasValue) {
          if (_AnyAmbiguousOldType == MyGame.Example.AnyAmbiguousAliases.M3) {
            this.AnyAmbiguous<MyGame.Example.Monster>().Value.UnPackTo((MyGame.Example.MonsterT)_o.AnyAmbiguous.Value);
          } else {
            _o.AnyAmbiguous.Value = this.AnyAmbiguous<MyGame.Example.Monster>().Value.UnPack();
          }
        } else {
          _o.AnyAmbiguous.Value = null;
        }
        break;
    }
    var _vector_of_enums_vec = this.VectorOfEnums;
    var _vector_of_enums_len = _vector_of_enums_vec.HasValue ? _vector_of_enums_vec.Value.Length : 0;
    if (_o.VectorOfEnums == null) {
      _o.VectorOfEnums = new List<MyGame.Example.Color>(_vector_of_enums_len);
    }
    ObjectApiUtil.ResizeList(_o.VectorOfEnums, _vector_of_enums_len);
    if (_vector_of_enums_vec.HasValue) { _vector_of_enums_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.VectorOfEnums)); }
    _o.SignedEnum = this.SignedEnum;
    var _testrequirednestedflatbuffer_vec = this.Testrequirednestedflatbuffer;
    var _testrequirednestedflatbuffer_len = _testrequirednestedflatbuffer_vec.HasValue ? _testrequirednestedflatbuffer_vec.Value.Length : 0;
    if (_o.Testrequirednestedflatbuffer == null) {
      _o.Testrequirednestedflatbuffer = new List<byte>(_testrequirednestedflatbuffer_len);
    }
    ObjectApiUtil.ResizeList(_o.Testrequirednestedflatbuffer, _testrequirednestedflatbuffer_len);
    if (_testrequirednestedflatbuffer_vec.HasValue) { _testrequirednestedflatbuffer_vec.Value.CopyTo(CollectionsMarshal.AsSpan(_o.Testrequirednestedflatbuffer)); }
    var _scalar_key_sorted_tables_vec = this.ScalarKeySortedTables;
    var _scalar_key_sorted_tables_len = _scalar_key_sorted_tables_vec.HasValue ? _scalar_key_sorted_tables_vec.Value.Length : 0;
    if (_o.ScalarKeySortedTables == null) {
      _o.ScalarKeySortedTables = new List<MyGame.Example.StatT>(_scalar_key_sorted_tables_len);
    }
    ObjectApiUtil.ResizeList(_o.ScalarKeySortedTables, _scalar_key_sorted_tables_len);
    if (_scalar_key_sorted_tables_vec.HasValue) {
      var _scalar_key_sorted_tables_value = _scalar_key_sorted_tables_vec.Value;
      for (var _j = 0; _j < _scalar_key_sorted_tables_len; ++_j) {
        var _src = _scalar_key_sorted_tables_value[_j];
        if (_o.ScalarKeySortedTables[_j] == null) { _o.ScalarKeySortedTables[_j] = new StatT(); }
        _src.UnPackTo(_o.ScalarKeySortedTables[_j]);
      }
    }
    if (this.NativeInline.HasValue) {
      if (_o.NativeInline == null) _o.NativeInline = new MyGame.Example.TestT();
      this.NativeInline.Value.UnPackTo(_o.NativeInline);
    } else {
      _o.NativeInline = null;
    }
    _o.LongEnumNonEnumDefault = this.LongEnumNonEnumDefault;
    _o.LongEnumNormalDefault = this.LongEnumNormalDefault;
    _o.NanDefault = this.NanDefault;
    _o.InfDefault = this.InfDefault;
    _o.PositiveInfDefault = this.PositiveInfDefault;
    _o.InfinityDefault = this.InfinityDefault;
    _o.PositiveInfinityDefault = this.PositiveInfinityDefault;
    _o.NegativeInfDefault = this.NegativeInfDefault;
    _o.NegativeInfinityDefault = this.NegativeInfinityDefault;
    _o.DoubleInfDefault = this.DoubleInfDefault;
  }
  public static Offset<MyGame.Example.Monster> Pack(FlatBufferBuilder builder, MonsterT _o) {
    if (_o == null) return default(Offset<MyGame.Example.Monster>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _inventory = default(VectorOffset);
    if (_o.Inventory != null) {
      _inventory = CreateInventoryVector(builder, CollectionsMarshal.AsSpan(_o.Inventory));
    }
    var _test_type = _o.Test == null ? MyGame.Example.Any.NONE : _o.Test.Type;
    var _test = _o.Test == null ? 0 : MyGame.Example.AnyUnion.Pack(builder, _o.Test);
    var _test4 = default(VectorOffset);
    if (_o.Test4 != null) {
      StartTest4Vector(builder, _o.Test4.Count);
      for (var _j = _o.Test4.Count - 1; _j >= 0; --_j) { MyGame.Example.Test.Pack(builder, _o.Test4[_j]); }
      _test4 = builder.EndVector();
    }
    var _testarrayofstring = default(VectorOffset);
    if (_o.Testarrayofstring != null) {
      var _testarrayofstring_len = _o.Testarrayofstring.Count;
      StringOffset[] _testarrayofstring_arr = null;
      try {
        Span<StringOffset> __testarrayofstring = _testarrayofstring_len <= 64
          ? stackalloc StringOffset[_testarrayofstring_len]
          : (_testarrayofstring_arr = ArrayPool<StringOffset>.Shared.Rent(_testarrayofstring_len)).AsSpan(0, _testarrayofstring_len);
        for (var _j = 0; _j < _testarrayofstring_len; ++_j) { __testarrayofstring[_j] = builder.CreateString(_o.Testarrayofstring[_j]); }
        _testarrayofstring = CreateTestarrayofstringVector(builder, __testarrayofstring);
      } finally {
        if (_testarrayofstring_arr != null) { ArrayPool<StringOffset>.Shared.Return(_testarrayofstring_arr); }
      }
    }
    var _testarrayoftables = default(VectorOffset);
    if (_o.Testarrayoftables != null) {
      var _testarrayoftables_len = _o.Testarrayoftables.Count;
      Offset<MyGame.Example.Monster>[] _testarrayoftables_arr = null;
      try {
        Span<Offset<MyGame.Example.Monster>> __testarrayoftables = _testarrayoftables_len <= 64
          ? stackalloc Offset<MyGame.Example.Monster>[_testarrayoftables_len]
          : (_testarrayoftables_arr = ArrayPool<Offset<MyGame.Example.Monster>>.Shared.Rent(_testarrayoftables_len)).AsSpan(0, _testarrayoftables_len);
        for (var _j = 0; _j < _testarrayoftables_len; ++_j) { __testarrayoftables[_j] = MyGame.Example.Monster.Pack(builder, _o.Testarrayoftables[_j]); }
        _testarrayoftables = CreateTestarrayoftablesVector(builder, __testarrayoftables);
      } finally {
        if (_testarrayoftables_arr != null) { ArrayPool<Offset<MyGame.Example.Monster>>.Shared.Return(_testarrayoftables_arr); }
      }
    }
    var _enemy = _o.Enemy == null ? default(Offset<MyGame.Example.Monster>) : MyGame.Example.Monster.Pack(builder, _o.Enemy);
    var _testnestedflatbuffer = default(VectorOffset);
    if (_o.Testnestedflatbuffer != null) {
      _testnestedflatbuffer = CreateTestnestedflatbufferVector(builder, CollectionsMarshal.AsSpan(_o.Testnestedflatbuffer));
    }
    var _testempty = _o.Testempty == null ? default(Offset<MyGame.Example.Stat>) : MyGame.Example.Stat.Pack(builder, _o.Testempty);
    var _testarrayofbools = default(VectorOffset);
    if (_o.Testarrayofbools != null) {
      _testarrayofbools = CreateTestarrayofboolsVector(builder, CollectionsMarshal.AsSpan(_o.Testarrayofbools));
    }
    var _testarrayofstring2 = default(VectorOffset);
    if (_o.Testarrayofstring2 != null) {
      var _testarrayofstring2_len = _o.Testarrayofstring2.Count;
      StringOffset[] _testarrayofstring2_arr = null;
      try {
        Span<StringOffset> __testarrayofstring2 = _testarrayofstring2_len <= 64
          ? stackalloc StringOffset[_testarrayofstring2_len]
          : (_testarrayofstring2_arr = ArrayPool<StringOffset>.Shared.Rent(_testarrayofstring2_len)).AsSpan(0, _testarrayofstring2_len);
        for (var _j = 0; _j < _testarrayofstring2_len; ++_j) { __testarrayofstring2[_j] = builder.CreateString(_o.Testarrayofstring2[_j]); }
        _testarrayofstring2 = CreateTestarrayofstring2Vector(builder, __testarrayofstring2);
      } finally {
        if (_testarrayofstring2_arr != null) { ArrayPool<StringOffset>.Shared.Return(_testarrayofstring2_arr); }
      }
    }
    var _testarrayofsortedstruct = default(VectorOffset);
    if (_o.Testarrayofsortedstruct != null) {
      StartTestarrayofsortedstructVector(builder, _o.Testarrayofsortedstruct.Count);
      for (var _j = _o.Testarrayofsortedstruct.Count - 1; _j >= 0; --_j) { MyGame.Example.Ability.Pack(builder, _o.Testarrayofsortedstruct[_j]); }
      _testarrayofsortedstruct = builder.EndVector();
    }
    var _flex = default(VectorOffset);
    if (_o.Flex != null) {
      _flex = CreateFlexVector(builder, CollectionsMarshal.AsSpan(_o.Flex));
    }
    var _test5 = default(VectorOffset);
    if (_o.Test5 != null) {
      StartTest5Vector(builder, _o.Test5.Count);
      for (var _j = _o.Test5.Count - 1; _j >= 0; --_j) { MyGame.Example.Test.Pack(builder, _o.Test5[_j]); }
      _test5 = builder.EndVector();
    }
    var _vector_of_longs = default(VectorOffset);
    if (_o.VectorOfLongs != null) {
      _vector_of_longs = CreateVectorOfLongsVector(builder, CollectionsMarshal.AsSpan(_o.VectorOfLongs));
    }
    var _vector_of_doubles = default(VectorOffset);
    if (_o.VectorOfDoubles != null) {
      _vector_of_doubles = CreateVectorOfDoublesVector(builder, CollectionsMarshal.AsSpan(_o.VectorOfDoubles));
    }
    var _parent_namespace_test = _o.ParentNamespaceTest == null ? default(Offset<MyGame.InParentNamespace>) : MyGame.InParentNamespace.Pack(builder, _o.ParentNamespaceTest);
    var _vector_of_referrables = default(VectorOffset);
    if (_o.VectorOfReferrables != null) {
      var _vector_of_referrables_len = _o.VectorOfReferrables.Count;
      Offset<MyGame.Example.Referrable>[] _vector_of_referrables_arr = null;
      try {
        Span<Offset<MyGame.Example.Referrable>> __vector_of_referrables = _vector_of_referrables_len <= 64
          ? stackalloc Offset<MyGame.Example.Referrable>[_vector_of_referrables_len]
          : (_vector_of_referrables_arr = ArrayPool<Offset<MyGame.Example.Referrable>>.Shared.Rent(_vector_of_referrables_len)).AsSpan(0, _vector_of_referrables_len);
        for (var _j = 0; _j < _vector_of_referrables_len; ++_j) { __vector_of_referrables[_j] = MyGame.Example.Referrable.Pack(builder, _o.VectorOfReferrables[_j]); }
        _vector_of_referrables = CreateVectorOfReferrablesVector(builder, __vector_of_referrables);
      } finally {
        if (_vector_of_referrables_arr != null) { ArrayPool<Offset<MyGame.Example.Referrable>>.Shared.Return(_vector_of_referrables_arr); }
      }
    }
    var _vector_of_weak_references = default(VectorOffset);
    if (_o.VectorOfWeakReferences != null) {
      _vector_of_weak_references = CreateVectorOfWeakReferencesVector(builder, CollectionsMarshal.AsSpan(_o.VectorOfWeakReferences));
    }
    var _vector_of_strong_referrables = default(VectorOffset);
    if (_o.VectorOfStrongReferrables != null) {
      var _vector_of_strong_referrables_len = _o.VectorOfStrongReferrables.Count;
      Offset<MyGame.Example.Referrable>[] _vector_of_strong_referrables_arr = null;
      try {
        Span<Offset<MyGame.Example.Referrable>> __vector_of_strong_referrables = _vector_of_strong_referrables_len <= 64
          ? stackalloc Offset<MyGame.Example.Referrable>[_vector_of_strong_referrables_len]
          : (_vector_of_strong_referrables_arr = ArrayPool<Offset<MyGame.Example.Referrable>>.Shared.Rent(_vector_of_strong_referrables_len)).AsSpan(0, _vector_of_strong_referrables_len);
        for (var _j = 0; _j < _vector_of_strong_referrables_len; ++_j) { __vector_of_strong_referrables[_j] = MyGame.Example.Referrable.Pack(builder, _o.VectorOfStrongReferrables[_j]); }
        _vector_of_strong_referrables = CreateVectorOfStrongReferrablesVector(builder, __vector_of_strong_referrables);
      } finally {
        if (_vector_of_strong_referrables_arr != null) { ArrayPool<Offset<MyGame.Example.Referrable>>.Shared.Return(_vector_of_strong_referrables_arr); }
      }
    }
    var _vector_of_co_owning_references = default(VectorOffset);
    if (_o.VectorOfCoOwningReferences != null) {
      _vector_of_co_owning_references = CreateVectorOfCoOwningReferencesVector(builder, CollectionsMarshal.AsSpan(_o.VectorOfCoOwningReferences));
    }
    var _vector_of_non_owning_references = default(VectorOffset);
    if (_o.VectorOfNonOwningReferences != null) {
      _vector_of_non_owning_references = CreateVectorOfNonOwningReferencesVector(builder, CollectionsMarshal.AsSpan(_o.VectorOfNonOwningReferences));
    }
    var _any_unique_type = _o.AnyUnique == null ? MyGame.Example.AnyUniqueAliases.NONE : _o.AnyUnique.Type;
    var _any_unique = _o.AnyUnique == null ? 0 : MyGame.Example.AnyUniqueAliasesUnion.Pack(builder, _o.AnyUnique);
    var _any_ambiguous_type = _o.AnyAmbiguous == null ? MyGame.Example.AnyAmbiguousAliases.NONE : _o.AnyAmbiguous.Type;
    var _any_ambiguous = _o.AnyAmbiguous == null ? 0 : MyGame.Example.AnyAmbiguousAliasesUnion.Pack(builder, _o.AnyAmbiguous);
    var _vector_of_enums = default(VectorOffset);
    if (_o.VectorOfEnums != null) {
      _vector_of_enums = CreateVectorOfEnumsVector(builder, CollectionsMarshal.AsSpan(_o.VectorOfEnums));
    }
    var _testrequirednestedflatbuffer = default(VectorOffset);
    if (_o.Testrequirednestedflatbuffer != null) {
      _testrequirednestedflatbuffer = CreateTestrequirednestedflatbufferVector(builder, CollectionsMarshal.AsSpan(_o.Testrequirednestedflatbuffer));
    }
    var _scalar_key_sorted_tables = default(VectorOffset);
    if (_o.ScalarKeySortedTables != null) {
      var _scalar_key_sorted_tables_len = _o.ScalarKeySortedTables.Count;
      Offset<MyGame.Example.Stat>[] _scalar_key_sorted_tables_arr = null;
      try {
        Span<Offset<MyGame.Example.Stat>> __scalar_key_sorted_tables = _scalar_key_sorted_tables_len <= 64
          ? stackalloc Offset<MyGame.Example.Stat>[_scalar_key_sorted_tables_len]
          : (_scalar_key_sorted_tables_arr = ArrayPool<Offset<MyGame.Example.Stat>>.Shared.Rent(_scalar_key_sorted_tables_len)).AsSpan(0, _scalar_key_sorted_tables_len);
        for (var _j = 0; _j < _scalar_key_sorted_tables_len; ++_j) { __scalar_key_sorted_tables[_j] = MyGame.Example.Stat.Pack(builder, _o.ScalarKeySortedTables[_j]); }
        _scalar_key_sorted_tables = CreateScalarKeySortedTablesVector(builder, __scalar_key_sorted_tables);
      } finally {
        if (_scalar_key_sorted_tables_arr != null) { ArrayPool<Offset<MyGame.Example.Stat>>.Shared.Return(_scalar_key_sorted_tables_arr); }
      }
    }
    return CreateMonster(
      builder,
      _o.Pos,
      _o.Mana,
      _o.Hp,
      _name,
      _inventory,
      _o.Color,
      _test_type,
      _test,
      _test4,
      _testarrayofstring,
      _testarrayoftables,
      _enemy,
      _testnestedflatbuffer,
      _testempty,
      _o.Testbool,
      _o.Testhashs32Fnv1,
      _o.Testhashu32Fnv1,
      _o.Testhashs64Fnv1,
      _o.Testhashu64Fnv1,
      _o.Testhashs32Fnv1a,
      _o.Testhashu32Fnv1a,
      _o.Testhashs64Fnv1a,
      _o.Testhashu64Fnv1a,
      _testarrayofbools,
      _o.Testf,
      _o.Testf2,
      _o.Testf3,
      _testarrayofstring2,
      _testarrayofsortedstruct,
      _flex,
      _test5,
      _vector_of_longs,
      _vector_of_doubles,
      _parent_namespace_test,
      _vector_of_referrables,
      _o.SingleWeakReference,
      _vector_of_weak_references,
      _vector_of_strong_referrables,
      _o.CoOwningReference,
      _vector_of_co_owning_references,
      _o.NonOwningReference,
      _vector_of_non_owning_references,
      _any_unique_type,
      _any_unique,
      _any_ambiguous_type,
      _any_ambiguous,
      _vector_of_enums,
      _o.SignedEnum,
      _testrequirednestedflatbuffer,
      _scalar_key_sorted_tables,
      _o.NativeInline,
      _o.LongEnumNonEnumDefault,
      _o.LongEnumNormalDefault,
      _o.NanDefault,
      _o.InfDefault,
      _o.PositiveInfDefault,
      _o.InfinityDefault,
      _o.PositiveInfinityDefault,
      _o.NegativeInfDefault,
      _o.NegativeInfinityDefault,
      _o.DoubleInfDefault);
  }
}

public class MonsterT
{
  [System.Text.Json.Serialization.JsonPropertyName("pos")]
  public MyGame.Example.Vec3T Pos { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("mana")]
  public short Mana { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("hp")]
  public short Hp { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("name")]
  public string Name { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("inventory")]
  public List<byte> Inventory { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("color")]
  public MyGame.Example.Color Color { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("test_type")]
  private MyGame.Example.Any TestType {
    get {
      return this.Test != null ? this.Test.Type : MyGame.Example.Any.NONE;
    }
    set {
      this.Test = new MyGame.Example.AnyUnion();
      this.Test.Type = value;
    }
  }
  [System.Text.Json.Serialization.JsonPropertyName("test")]
  [System.Text.Json.Serialization.JsonConverter(typeof(MyGame.Example.AnyUnion_JsonConverter))]
  public MyGame.Example.AnyUnion Test { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("test4")]
  public List<MyGame.Example.TestT> Test4 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testarrayofstring")]
  public List<string> Testarrayofstring { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testarrayoftables")]
  public List<MyGame.Example.MonsterT> Testarrayoftables { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("enemy")]
  public MyGame.Example.MonsterT Enemy { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testnestedflatbuffer")]
  public List<byte> Testnestedflatbuffer { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testempty")]
  public MyGame.Example.StatT Testempty { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testbool")]
  public bool Testbool { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashs32_fnv1")]
  public int Testhashs32Fnv1 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashu32_fnv1")]
  public uint Testhashu32Fnv1 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashs64_fnv1")]
  public long Testhashs64Fnv1 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashu64_fnv1")]
  public ulong Testhashu64Fnv1 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashs32_fnv1a")]
  public int Testhashs32Fnv1a { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashu32_fnv1a")]
  public uint Testhashu32Fnv1a { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashs64_fnv1a")]
  public long Testhashs64Fnv1a { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testhashu64_fnv1a")]
  public ulong Testhashu64Fnv1a { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testarrayofbools")]
  public List<bool> Testarrayofbools { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testf")]
  public float Testf { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testf2")]
  public float Testf2 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testf3")]
  public float Testf3 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testarrayofstring2")]
  public List<string> Testarrayofstring2 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testarrayofsortedstruct")]
  public List<MyGame.Example.AbilityT> Testarrayofsortedstruct { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("flex")]
  public List<byte> Flex { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("test5")]
  public List<MyGame.Example.TestT> Test5 { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_longs")]
  public List<long> VectorOfLongs { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_doubles")]
  public List<double> VectorOfDoubles { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("parent_namespace_test")]
  public MyGame.InParentNamespaceT ParentNamespaceTest { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_referrables")]
  public List<MyGame.Example.ReferrableT> VectorOfReferrables { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("single_weak_reference")]
  public ulong SingleWeakReference { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_weak_references")]
  public List<ulong> VectorOfWeakReferences { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_strong_referrables")]
  public List<MyGame.Example.ReferrableT> VectorOfStrongReferrables { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("co_owning_reference")]
  public ulong CoOwningReference { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_co_owning_references")]
  public List<ulong> VectorOfCoOwningReferences { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("non_owning_reference")]
  public ulong NonOwningReference { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_non_owning_references")]
  public List<ulong> VectorOfNonOwningReferences { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("any_unique_type")]
  private MyGame.Example.AnyUniqueAliases AnyUniqueType {
    get {
      return this.AnyUnique != null ? this.AnyUnique.Type : MyGame.Example.AnyUniqueAliases.NONE;
    }
    set {
      this.AnyUnique = new MyGame.Example.AnyUniqueAliasesUnion();
      this.AnyUnique.Type = value;
    }
  }
  [System.Text.Json.Serialization.JsonPropertyName("any_unique")]
  [System.Text.Json.Serialization.JsonConverter(typeof(MyGame.Example.AnyUniqueAliasesUnion_JsonConverter))]
  public MyGame.Example.AnyUniqueAliasesUnion AnyUnique { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("any_ambiguous_type")]
  private MyGame.Example.AnyAmbiguousAliases AnyAmbiguousType {
    get {
      return this.AnyAmbiguous != null ? this.AnyAmbiguous.Type : MyGame.Example.AnyAmbiguousAliases.NONE;
    }
    set {
      this.AnyAmbiguous = new MyGame.Example.AnyAmbiguousAliasesUnion();
      this.AnyAmbiguous.Type = value;
    }
  }
  [System.Text.Json.Serialization.JsonPropertyName("any_ambiguous")]
  [System.Text.Json.Serialization.JsonConverter(typeof(MyGame.Example.AnyAmbiguousAliasesUnion_JsonConverter))]
  public MyGame.Example.AnyAmbiguousAliasesUnion AnyAmbiguous { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("vector_of_enums")]
  public List<MyGame.Example.Color> VectorOfEnums { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("signed_enum")]
  public MyGame.Example.Race SignedEnum { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("testrequirednestedflatbuffer")]
  public List<byte> Testrequirednestedflatbuffer { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("scalar_key_sorted_tables")]
  public List<MyGame.Example.StatT> ScalarKeySortedTables { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("native_inline")]
  public MyGame.Example.TestT NativeInline { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("long_enum_non_enum_default")]
  public MyGame.Example.LongEnum LongEnumNonEnumDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("long_enum_normal_default")]
  public MyGame.Example.LongEnum LongEnumNormalDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("nan_default")]
  public float NanDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("inf_default")]
  public float InfDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("positive_inf_default")]
  public float PositiveInfDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("infinity_default")]
  public float InfinityDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("positive_infinity_default")]
  public float PositiveInfinityDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("negative_inf_default")]
  public float NegativeInfDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("negative_infinity_default")]
  public float NegativeInfinityDefault { get; set; }
  [System.Text.Json.Serialization.JsonPropertyName("double_inf_default")]
  public double DoubleInfDefault { get; set; }

  public MonsterT() {
    this.Pos = new MyGame.Example.Vec3T();
    this.Mana = 150;
    this.Hp = 100;
    this.Name = null;
    this.Inventory = null;
    this.Color = MyGame.Example.Color.Blue;
    this.Test = null;
    this.Test4 = null;
    this.Testarrayofstring = null;
    this.Testarrayoftables = null;
    this.Enemy = null;
    this.Testnestedflatbuffer = null;
    this.Testempty = null;
    this.Testbool = false;
    this.Testhashs32Fnv1 = 0;
    this.Testhashu32Fnv1 = 0;
    this.Testhashs64Fnv1 = 0;
    this.Testhashu64Fnv1 = 0;
    this.Testhashs32Fnv1a = 0;
    this.Testhashu32Fnv1a = 0;
    this.Testhashs64Fnv1a = 0;
    this.Testhashu64Fnv1a = 0;
    this.Testarrayofbools = null;
    this.Testf = 3.14159f;
    this.Testf2 = 3.0f;
    this.Testf3 = 0.0f;
    this.Testarrayofstring2 = null;
    this.Testarrayofsortedstruct = null;
    this.Flex = null;
    this.Test5 = null;
    this.VectorOfLongs = null;
    this.VectorOfDoubles = null;
    this.ParentNamespaceTest = null;
    this.VectorOfReferrables = null;
    this.SingleWeakReference = 0;
    this.VectorOfWeakReferences = null;
    this.VectorOfStrongReferrables = null;
    this.CoOwningReference = 0;
    this.VectorOfCoOwningReferences = null;
    this.NonOwningReference = 0;
    this.VectorOfNonOwningReferences = null;
    this.AnyUnique = null;
    this.AnyAmbiguous = null;
    this.VectorOfEnums = null;
    this.SignedEnum = MyGame.Example.Race.None;
    this.Testrequirednestedflatbuffer = null;
    this.ScalarKeySortedTables = null;
    this.NativeInline = new MyGame.Example.TestT();
    this.LongEnumNonEnumDefault = 0;
    this.LongEnumNormalDefault = MyGame.Example.LongEnum.LongOne;
    this.NanDefault = Single.NaN;
    this.InfDefault = Single.PositiveInfinity;
    this.PositiveInfDefault = Single.PositiveInfinity;
    this.InfinityDefault = Single.PositiveInfinity;
    this.PositiveInfinityDefault = Single.PositiveInfinity;
    this.NegativeInfDefault = Single.NegativeInfinity;
    this.NegativeInfinityDefault = Single.NegativeInfinity;
    this.DoubleInfDefault = Double.PositiveInfinity;
  }

  private static readonly System.Text.Json.JsonSerializerOptions _jsonOptions = new System.Text.Json.JsonSerializerOptions { WriteIndented = true, NumberHandling = System.Text.Json.Serialization.JsonNumberHandling.AllowNamedFloatingPointLiterals, Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() } };
  public static MonsterT DeserializeFromJson(string jsonText) {
    return System.Text.Json.JsonSerializer.Deserialize<MonsterT>(jsonText, _jsonOptions);
  }
  public string SerializeToJson() {
    return System.Text.Json.JsonSerializer.Serialize(this, _jsonOptions);
  }
  public static MonsterT DeserializeFromBinary(byte[] fbBuffer) {
    return Monster.GetRootAsMonster(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    Monster.FinishMonsterBuffer(fbb, Monster.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedSpan().ToArray();
  }
}


static public class MonsterVerify
{
  static public bool Verify(ref Google.FlatSpanBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Pos*/, 32 /*MyGame.Example.Vec3*/, 8, false)
      && verifier.VerifyField(tablePos, 6 /*Mana*/, 2 /*short*/, 2, false)
      && verifier.VerifyField(tablePos, 8 /*Hp*/, 2 /*short*/, 2, false)
      && verifier.VerifyString(tablePos, 10 /*Name*/, true)
      && verifier.VerifyVectorOfData(tablePos, 14 /*Inventory*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 16 /*Color*/, 1 /*MyGame.Example.Color*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*TestType*/, 1 /*MyGame.Example.Any*/, 1, false)
      && verifier.VerifyUnion(tablePos, 18, 20 /*Test*/, MyGame.Example.AnyVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 22 /*Test4*/, 4 /*MyGame.Example.Test*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 24 /*Testarrayofstring*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 26 /*Testarrayoftables*/, MyGame.Example.MonsterVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 28 /*Enemy*/, MyGame.Example.MonsterVerify.Verify, false)
      && verifier.VerifyNestedBuffer(tablePos, 30 /*Testnestedflatbuffer*/, MyGame.Example.MonsterVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 32 /*Testempty*/, MyGame.Example.StatVerify.Verify, false)
      && verifier.VerifyField(tablePos, 34 /*Testbool*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 36 /*Testhashs32Fnv1*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 38 /*Testhashu32Fnv1*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 40 /*Testhashs64Fnv1*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 42 /*Testhashu64Fnv1*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 44 /*Testhashs32Fnv1a*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 46 /*Testhashu32Fnv1a*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 48 /*Testhashs64Fnv1a*/, 8 /*long*/, 8, false)
      && verifier.VerifyField(tablePos, 50 /*Testhashu64Fnv1a*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 52 /*Testarrayofbools*/, 1 /*bool*/, false)
      && verifier.VerifyField(tablePos, 54 /*Testf*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 56 /*Testf2*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 58 /*Testf3*/, 4 /*float*/, 4, false)
      && verifier.VerifyVectorOfStrings(tablePos, 60 /*Testarrayofstring2*/, false)
      && verifier.VerifyVectorOfData(tablePos, 62 /*Testarrayofsortedstruct*/, 8 /*MyGame.Example.Ability*/, false)
      && verifier.VerifyVectorOfData(tablePos, 64 /*Flex*/, 1 /*byte*/, false)
      && verifier.VerifyVectorOfData(tablePos, 66 /*Test5*/, 4 /*MyGame.Example.Test*/, false)
      && verifier.VerifyVectorOfData(tablePos, 68 /*VectorOfLongs*/, 8 /*long*/, false)
      && verifier.VerifyVectorOfData(tablePos, 70 /*VectorOfDoubles*/, 8 /*double*/, false)
      && verifier.VerifyTable(tablePos, 72 /*ParentNamespaceTest*/, MyGame.InParentNamespaceVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 74 /*VectorOfReferrables*/, MyGame.Example.ReferrableVerify.Verify, false)
      && verifier.VerifyField(tablePos, 76 /*SingleWeakReference*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 78 /*VectorOfWeakReferences*/, 8 /*ulong*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 80 /*VectorOfStrongReferrables*/, MyGame.Example.ReferrableVerify.Verify, false)
      && verifier.VerifyField(tablePos, 82 /*CoOwningReference*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 84 /*VectorOfCoOwningReferences*/, 8 /*ulong*/, false)
      && verifier.VerifyField(tablePos, 86 /*NonOwningReference*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyVectorOfData(tablePos, 88 /*VectorOfNonOwningReferences*/, 8 /*ulong*/, false)
      && verifier.VerifyField(tablePos, 90 /*AnyUniqueType*/, 1 /*MyGame.Example.AnyUniqueAliases*/, 1, false)
      && verifier.VerifyUnion(tablePos, 90, 92 /*AnyUnique*/, MyGame.Example.AnyUniqueAliasesVerify.Verify, false)
      && verifier.VerifyField(tablePos, 94 /*AnyAmbiguousType*/, 1 /*MyGame.Example.AnyAmbiguousAliases*/, 1, false)
      && verifier.VerifyUnion(tablePos, 94, 96 /*AnyAmbiguous*/, MyGame.Example.AnyAmbiguousAliasesVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 98 /*VectorOfEnums*/, 1 /*MyGame.Example.Color*/, false)
      && verifier.VerifyField(tablePos, 100 /*SignedEnum*/, 1 /*MyGame.Example.Race*/, 1, false)
      && verifier.VerifyNestedBuffer(tablePos, 102 /*Testrequirednestedflatbuffer*/, MyGame.Example.MonsterVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 104 /*ScalarKeySortedTables*/, MyGame.Example.StatVerify.Verify, false)
      && verifier.VerifyField(tablePos, 106 /*NativeInline*/, 4 /*MyGame.Example.Test*/, 2, false)
      && verifier.VerifyField(tablePos, 108 /*LongEnumNonEnumDefault*/, 8 /*MyGame.Example.LongEnum*/, 8, false)
      && verifier.VerifyField(tablePos, 110 /*LongEnumNormalDefault*/, 8 /*MyGame.Example.LongEnum*/, 8, false)
      && verifier.VerifyField(tablePos, 112 /*NanDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 114 /*InfDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 116 /*PositiveInfDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 118 /*InfinityDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 120 /*PositiveInfinityDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 122 /*NegativeInfDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 124 /*NegativeInfinityDefault*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 126 /*DoubleInfDefault*/, 8 /*double*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
